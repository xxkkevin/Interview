{"./":{"url":"./","title":"Python 版本刷题","keywords":"","body":"Leetcode solutions and summarizations! 看左侧栏，开始你的表演！ 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"001._two_sum.html":{"url":"001._two_sum.html","title":"001 two sum","keywords":"","body":"1. Two Sum 两数之和 难度: Easy 刷题内容 原题连接 https://leetcode.com/problems/two-sum https://leetcode-cn.com/problems/two-sum/description 内容描述 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] 解题方案 思路 1 可以用O(n^2) loop 但是也可以牺牲空间换取时间，异常聪明的AC解法 2 7 11 15 不存在 存在之中 lookup {2:0} [0，1] 建立字典 lookup 存放第一个数字，并存放该数字的 index 判断 lookup 种是否存在： target - 当前数字， 则表面 当前值和 lookup中的值加和为 target. 如果存在，则返回： target - 当前数字 的 index 和 当前值的 index class Solution(object): def twoSum(self, nums, target): \"\"\" :type nums: List[int] :type target: int :rtype: List[int] \"\"\" lookup = {} for i, num in enumerate(nums): if target - num in lookup: return [lookup[target - num],i] lookup[num] = i return [] 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"002._add_two_numbers.html":{"url":"002._add_two_numbers.html","title":"002 add two numbers","keywords":"","body":"2. Add Two Numbers 难度: 中等 刷题内容 原题连接 https://leetcode.com/problems/add-two-numbers/description/ 内容描述 You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example: Input: (2 -> 4 -> 3) + (5 -> 6 -> 4) Output: 7 -> 0 -> 8 Explanation: 342 + 465 = 807. 解题方案 思路 1 全部变成数字做加法再换回去呗，这多暴力，爽！ class Solution(object): def addTwoNumbers(self, l1, l2): \"\"\" :type l1: ListNode :type l2: ListNode :rtype: ListNode \"\"\" if not l1: return l2 if not l2: return l1 val1, val2 = [l1.val], [l2.val] while l1.next: val1.append(l1.next.val) l1 = l1.next while l2.next: val2.append(l2.next.val) l2 = l2.next num1 = ''.join([str(i) for i in val1[::-1]]) num2 = ''.join([str(i) for i in val2[::-1]]) tmp = str(int(num1) + int(num2))[::-1] res = ListNode(tmp[0]) run_res = res for i in range(1, len(tmp)): run_res.next = ListNode(tmp[i]) run_res = run_res.next return res 思路 2 可以使用递归，每次算一位的相加 class Solution(object): def addTwoNumbers(self, l1, l2): \"\"\" :type l1: ListNode :type l2: ListNode :rtype: ListNode \"\"\" if not l1: return l2 if not l2: return l1 if l1.val + l2.val 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"003._longest_substring_without_repeating_characters.html":{"url":"003._longest_substring_without_repeating_characters.html","title":"003 longest substring without repeating characters","keywords":"","body":"3. Longest Substring Without Repeating Characters 题目: https://leetcode.com/problems/longest-substring-without-repeating-characters/ 难度: Medium 思路 粗一看是dp，细一看是greedy 我们先从第一个字符开始，只要碰到已经出现过的字符我们就必须从之前出现该字符的index开始重新往后看。 例如‘xyzxlkjh’，当看到第二个‘x’时我们就应该从y开始重新往后看了。 那么怎么判断字符已经出现过了呢？我们使用一个hashmap，将每一个已经阅读过的字符作为键，而它的值就是它在原字符串中的index，如果我们现在的字符不在hashmap里面我们就把它加进hashmap中去，因此，只要目前的这个字符在该hashmap中的值大于等于了这一轮字符串的首字符，就说明它已经出现过了，我们就将首字符的index加1，即从后一位又重新开始读，然后比较目前的子串长度与之前的最大长度，取大者。 程序变量解释 l(字母L) 代表目前最大子串的长度 start 是这一轮未重复子串首字母的index maps 放置每一个字符的index，如果maps.get(s[i], -1)大于等于start的话，就说明字符重复了，此时就要重置 l(字母L) 和start的值了， class Solution(object): def lengthOfLongestSubstring(self, s): \"\"\" :type s: str :rtype: int \"\"\" l, start, n = 0, 0, len(s) maps = {} for i in range(n): start = max(start, maps.get(s[i], -1)+1) l = max(l, i - start+1) maps[s[i]] = i return l class Solution(object): def lengthOfLongestSubstring(self, s): \"\"\" :type s: str :rtype: int \"\"\" maps = {} begin, end, counter, d = 0, 0, 0, 0 while end 1: counter += 1 end += 1 while counter > 0: if maps[s[begin]] > 1: counter -= 1 maps[s[begin]] -= 1 begin += 1 d = max(d, end - begin) return d Author: Keqi Huang If you like it, please spread your support 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"004._median_of_two_sorted_arrays.html":{"url":"004._median_of_two_sorted_arrays.html","title":"004 median of two sorted arrays","keywords":"","body":"4. Median of Two Sorted Arrays 题目: https://leetcode.com/problems/median-of-two-sorted-arrays/ 难度: Hard 一看到的时候，觉得跟CLRS书上的一道习题类似 求X[1....n] Y[1....n] 的 median 习题 9.3-8 Let X[1..n] and Y [1..n] be two arrays, each containing n numbers already in sorted order. Give an O(lg n)-time algorithn to find the median of all 2n elements in arrays X and Y . The median can be obtained recursively as follows. Pick the median of the sorted array A. This is just O(1) time as median is the n/2th element in the sorted array. Now compare the median of A, call is a∗ with median of B, b∗. We have two cases. a∗ a∗ > b∗ : In this case, we can still throw away B[1··· n/2] and also A[ n/ · · · n] and solve a smaller subproblem recursively. In either case, our subproblem size reduces by a factor of half and we spend only constant time to compare the medians of A and B. So the recurrence relation would be T (n) = T (n/2) + O(1) which has a solution T (n) = O(log n). divide and conquer 如果X[n/2] == Y[n/2]，则找到，return 如果X[n/2] 否则找X[1..n/2]和Y[n/2…n] 但是实际上不同，这里需要考虑的问题更多： 两个数组长度不一样 并不是只找一个median，如果median有两个，需要算平均 思路 把它转化成经典的findKth问题 参考： http://chaoren.is-programmer.com/posts/42890.html 首先转成求A和B数组中第k小的数的问题, 然后用k/2在A和B中分别找。 比如k = 6, 分别看A和B中的第3个数, 已知 A1 B3至少大于5个数, 所以第6小的数有可能是B1 (A1 发问，为什么要从k/2开始寻找，依旧k = 6, 我可以比较A1 和 B5的关系么，可以这样做，但是明显的问题出现在如果A1 > B5，那么这个第6小的数应该存在于B6和A1中。 如果A1 这个跟习题算法的区别是每次扔的东西明显少一些，但是k也在不断变小。下面的代码的时间复杂度是O(lg(m+n)) class Solution(object): def findMedianSortedArrays(self, nums1, nums2): \"\"\" :type nums1: List[int] :type nums2: List[int] :rtype: float \"\"\" n = len(nums1) + len(nums2) if n % 2 == 1: return self.findKth(nums1, nums2, n / 2 + 1) else: smaller = self.findKth(nums1, nums2, n / 2) bigger = self.findKth(nums1, nums2, n / 2 + 1) return (smaller + bigger) / 2.0 def findKth(self, A, B, k): if len(A) == 0: return B[k-1] if len(B) == 0: return A[k-1] if k == 1 : return min(A[0],B[0]) a = A[ k / 2 - 1 ] if len(A) >= k / 2 else None b = B[ k / 2 - 1 ] if len(B) >= k / 2 else None if b is None or (a is not None and a #python3里面要用向下取整函数才可以AC，否则报错，TypeError: list indices must be integers or slices, not float from math import floor class Solution: def findMedianSortedArrays(self, nums1, nums2): \"\"\" :type nums1: List[int] :type nums2: List[int] :rtype: float \"\"\" n = len(nums1) + len(nums2) if n % 2 == 1: return self.findKth(nums1, nums2, floor(n/2)+1) else: smaller = self.findKth(nums1, nums2, floor(n/2)) bigger = self.findKth(nums1, nums2, floor(n/2)+1) return (smaller + bigger) / 2.0 def findKth(self, A, B, k): if len(A) == 0: return B[k-1] if len(B) == 0: return A[k-1] if k == 1: return min(A[0], B[0]) a = A[floor(k/2)-1] if len(A) >= k/2 else None b = B[floor(k/2)-1] if len(B) >= k/2 else None if b is None or (a is not None and a 这个findKth的算法单独抽出来也是题目。 寻找最小的k个数 题目描述 输入n个整数，输出其中最小的k个。 分析与解法 解法一 要求一个序列中最小的k个数，按照惯有的思维方式，则是先对这个序列从小到大排序，然后输出前面的最小的k个数。 至于选取什么的排序方法，我想你可能会第一时间想到快速排序（我们知道，快速排序平均所费时间为nlogn），然后再遍历序列中前k个元素输出即可。因此，总的时间复杂度：```O（n log n)+O(k)=O（n * log n）```。 解法二 咱们再进一步想想，题目没有要求最小的k个数有序，也没要求最后n-k个数有序。既然如此，就没有必要对所有元素进行排序。这时，咱们想到了用选择或交换排序，即： 遍历n个数，把最先遍历到的k个数存入到大小为k的数组中，假设它们即是最小的k个数； 对这k个数，利用选择或交换排序找到这k个元素中的最大值kmax（找最大值需要遍历这k个数，时间复杂度为O（k））； 继续遍历剩余n-k个数。假设每一次遍历到的新的元素的值为x，把x与kmax比较：如果x kmax ，用x替换kmax，并回到第二步重新找出k个元素的数组中最大元素kmax‘；如果x >= kmax，则继续遍历不更新数组。 每次遍历，更新或不更新数组的所用的时间为O（k）或O（0）。故整趟下来，时间复杂度为n*O（k）=O（n*k）。解法三 更好的办法是维护容量为k的最大堆，原理跟解法二的方法相似： 用容量为k的最大堆存储最先遍历到的k个数，同样假设它们即是最小的k个数； 堆中元素是有序的，令k1（kmax设为最大堆中的最大元素） 遍历剩余n-k个数。假设每一次遍历到的新的元素的值为x，把x与堆顶元素kmax比较：如果x ，用x替换kmax，然后更新堆（用时logk）；否则不更新堆。 这样下来，总的时间复杂度:O（k+（n-k）logk）=O（nlogk）。此方法得益于堆中进行查找和更新的时间复杂度均为：O(logk)（若使用解法二：在数组中找出最大元素，时间复杂度：O（k））。 解法四 在《数据结构与算法分析--c语言描述》一书，第7章第7.7.6节中，阐述了一种在平均情况下，时间复杂度为O（N）的快速选择算法。如下述文字： 选取S中一个元素作为枢纽元v，将集合S-{v}分割成S1和S2，就像快速排序那样 如果k 如果k = 1 + |S1|，那么枢纽元素就是第k个最小元素，即找到，直接返回它。 否则，这第k个最小元素就在S2中，即S2中的第（k - |S1| - 1）个最小元素，我们递归调用并返回QuickSelect(S2, k - |S1| - 1)。此算法的平均运行时间为O(n)。 示例代码如下： //QuickSelect 将第k小的元素放在 a[k-1] void QuickSelect( int a[], int k, int left, int right ) { int i, j; int pivot; if( left + cutoff pivot ){ } if( i i + 1 ) QuickSelect( a, k, i + 1, right ); } else InsertSort( a + left, right - left + 1 ); } 这个快速选择SELECT算法，类似快速排序的划分方法。N个数存储在数组S中，再从数组中选取“中位数的中位数”作为枢纽元X，把数组划分为Sa和Sb俩部分，Sa 给定两个已经排序好的数组，求第k大的，算法有O(m+n).类似merge sort的原理。否则利用的就是之上提到的，利用已经有序的原理，然后每次丢。 之所以这里还有一个丢弃条件是b is None 丢A的一部分，是因为B的数组长度是有限的，这个时候很明显丢A的k/2是不影响的，因为无论B[-1]是如何大或者小，因为整个B的长度没有达到k/2小，所以丢掉的这部分最大的A[k/2-1]也不可能是第k个，因为即使整个B都比A[k/2-1]小，拼起来也不能使A[k/2-1]第k大，所以可以放心丢弃。 这里是两个sorted list/array findKth，想到了类似的题目，如果给一个n个linked list，findKth，能想到的办法也只能是用heap吧，类似merge k sorted lists. 再写一个O(m+n)类似merge sort的也可以AC的代码 class Solution(object): def findMedianSortedArrays(self, nums1, nums2): \"\"\" :type nums1: List[int] :type nums2: List[int] :rtype: float \"\"\" def findKth(A, pa, B, pb, k): res = 0 m = 0 while pa 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"005._longest_palindromic_substring.html":{"url":"005._longest_palindromic_substring.html","title":"005 longest palindromic substring","keywords":"","body":"5. Longest Palindromic Substring 题目: https://leetcode.com/problems/longest-palindromic-substring/ 难度: Medium 思路0: 暴力解法绝对不行 思路1: 所以一个好的想法是 s 和 reverse(s) 共有的最长的 substring就是longest palindromic substring -> 问题转成求Longest common substring problem 参见wikipedia ，典型动归 LCSuff(S1...p, T1...q) = LCS(S1...p1, T1...q-1) if S[p] = T[q] else 0 伪码也有了，代码也有： https://en.wikibooks.org/wiki/Algorithm_Implementation/Strings/Longest_common_substring#Python_2 这样也超时？ class Solution(object): def longestPalindrome(self, s): \"\"\" :type s: str :rtype: str \"\"\" def lcs(s1, s2): m = [[0] * (1 + len(s2)) for i in xrange(1 + len(s1))] longest, x_longest = 0, 0 for x in xrange(1, 1 + len(s1)): for y in xrange(1, 1 + len(s2)): if s1[x - 1] == s2[y - 1]: m[x][y] = m[x - 1][y - 1] + 1 if m[x][y] > longest: longest = m[x][y] x_longest = x else: m[x][y] = 0 return s1[x_longest - longest: x_longest] return lcs(s, s[::-1]) 因为以为这样s[::-1]已经很快了. 这个方法是buggy的，看字符串abcxgcba,它reverse之后是abcgxcba,它们有公共字符串，但是这里面没有回文，修复方式是： we check if the substring’s indices are the same as the reversed substring’s original indices. If it is, then we attempt to update the longest palindrome found so far; if not, we skip this and find the next candidate. 我觉得的修复方式这样么： 原本 翻转 ABXYBA ABYXBA 求出来的substring indices是 0:2 但是这个s1[0:2] 和 s2[0:2]一样，所以不行 同理common substring indices还是s[4:6] 和s2[4:6]一样，不行 而比如ABAD和 DABA substring indice 一个是0：3， 一个是1:4，这样就没问题 思路2: 依次把每一个字符当做回文字符串的中间字符，找到以该字符为中间字符的回文串的最大长度。分别对奇偶的情况进行讨论，接下来的关键就是对边界的把握，确保下标不要越界。当子串已经包含首字符或最后一个字符且此时还是回文串的时候，下标分别会向两边多移一位，需要补回来。 参考https://shenjie1993.gitbooks.io/leetcode-python/content/005%20Longest%20Palindromic%20Substring.html class Solution(object): def longestPalindrome(self, s): \"\"\" :type s: str :rtype: str \"\"\" n = len(s) # empty or one char if n m : l = i - j + 1 - b r = i + j + b m = c b = True # Even situation for j in range(min(n - i - 1, i + 1)): if (s[i - j] != s[i + j + 1]): b = False break else: c = 2 * j + 2 if (c > m): l = i - j + 1 - b r = i + j + 1 + b m = c b = True return s[l:r] 以上是参考版本，自己写的版本： class Solution(object): def longestPalindrome(self, s): \"\"\" :type s: str :rtype: str \"\"\" n = len(s) m,l,r = 0,0,0 for i in range(n): # odd case for j in range(min(i+1,n-i)): if s[i-j] != s[i+j]: break if 2*j + 1 > m : m = 2 * j + 1 l = i-j r = i+j if i+1 m : m = 2*j +2 l = i-j r = i+j+1 return s[l:r+1] 思路3: Manacher算法 Manacher算法增加两个辅助变量id和mx，其中id表示最大回文子串中心的位置，mx则为id+P[id]，也就是最大回文子串的边界。得到一个很重要的结论： 如果mx > i，那么P[i] >= Min(P[2 * id - i], mx - i) . 为什么这样说呢，下面解释 下面，令j = 2*id - i，也就是说j是i关于id的对称点。 当 mx - i > P[j] 的时候，以S[j]为中心的回文子串包含在以S[id]为中心的回文子串中，由于i和j对称，以S[i]为中心的回文子串必然包含在以S[id]为中心的回文子串中，所以必有P[i] = P[j]； 当 P[j] >= mx - i 的时候，以S[j]为中心的回文子串不一定完全包含于以S[id]为中心的回文子串中，但是基于对称性可知，下图中两个绿框所包围的部分是相同的，也就是说以S[i]为中心的回文子串，其向右至少会扩张到mx的位置，也就是说 P[i] >= mx - i。至于mx之后的部分是否对称，再具体匹配。 所以P[i] >= Min(P[2 id - i], mx - i)，因为以j为中心的绘回文子串的左边界可能会比mx关于id的对称点要大，此时只能证明P[i]=P[2 id - i] 此外，对于 mx 在下面的程序中我的P数组保存的是，以当前字符为回文子串中心时，该回文子串的长度（不包含当前字符自身） 简单地用一个小例子来解释：原字符串为'qacbcaw'，一眼就可以看出来最大回文子串是'acbca'， 下面是我做的图，累shi了！ 所以最终代码中的max_i就是字符'b'所对应的index8，start的值就是(max_i - P[max_i] - 1) / 2 = 1,最终输出结果为s[1:6],即‘acbca’ class Solution(object): def longestPalindrome(self, s): \"\"\" :type s: str :rtype: str \"\"\" def preProcess(s): if not s: return ['^', '&'] T = ['^'] for i in s: T += ['#', i] T += ['#', '$'] return T T = preProcess(s) P = [0] * len(T) id, mx = 0, 0 for i in range(1, len(T)-1): j = 2 * id - i if mx > i: P[i] = min(P[j], mx-i) else: P[i]= 0 while T[i+P[i]+1] == T[i-P[i]-1]: P[i] += 1 if i + P[i] > mx: id, mx = i, i + P[i] max_i = P.index(max(P)) #保存的是当前最大回文子串中心位置的index start = (max_i - P[max_i] - 1) / 2 res = s[start:start+P[max_i]] return res run code的时候结果会跟expected不一样，但是该input确实2个结果都可以，所以放心地submit吧 还可以转到647题去看一看，也可以用这个算法解 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"006._ZigZag_Conversion.html":{"url":"006._ZigZag_Conversion.html","title":"006 ZigZag Conversion","keywords":"","body":"6. ZigZag Conversion 难度: 中等 刷题内容 原题连接 https://leetcode.com/problems/zigzag-conversion/ 内容描述 The string \"PAYPALISHIRING\" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility) P A H N A P L S I I G Y I R And then read line by line: \"PAHNAPLSIIGYIR\" Write the code that will take a string and make this conversion given a number of rows: string convert(string s, int numRows); Example 1: Input: s = \"PAYPALISHIRING\", numRows = 3 Output: \"PAHNAPLSIIGYIR\" Example 2: Input: s = \"PAYPALISHIRING\", numRows = 4 Output: \"PINALSIGYAHRPI\" Explanation: P I N A L S I G Y A H R P I 解题方案 思路 1 参考大神pharrellyhy-Solution-in-96ms-(99.43)?page=2)的思路, 纵向思维考虑，index从0开始，我们要一直自增直到numRows-1，此后又一直自减到0，重复执行。 给个例子容易懂一些：s = “abcdefghijklmn”, numRows = 4 a g m b f h l n c e i k d j 看明白了吗，下来上去，下来上去，zigzag class Solution(object): def convert(self, s, numRows): \"\"\" :type s: str :type numRows: int :rtype: str \"\"\" if numRows == 1 or numRows >= len(s): return s res = [''] * numRows idx, step = 0, 1 for x in s: res[idx] += x if idx == 0: ## 第一行，一直向下走 step = 1 elif idx == numRows - 1: ## 最后一行了，向上走 step = -1 idx += step return ''.join(res) 假设用我上面给的例子，并且在L[index] += x这一行后面打印出index, step, L的值, 输出结果如下： (0, 1, ['a', '', '', '']) (1, 1, ['a', 'b', '', '']) (2, 1, ['a', 'b', 'c', '']) (3, 1, ['a', 'b', 'c', 'd']) (2, -1, ['a', 'b', 'ce', 'd']) (1, -1, ['a', 'bf', 'ce', 'd']) (0, -1, ['ag', 'bf', 'ce', 'd']) (1, 1, ['ag', 'bfh', 'ce', 'd']) (2, 1, ['ag', 'bfh', 'cei', 'd']) (3, 1, ['ag', 'bfh', 'cei', 'dj']) (2, -1, ['ag', 'bfh', 'ceik', 'dj']) (1, -1, ['ag', 'bfhl', 'ceik', 'dj']) (0, -1, ['agm', 'bfhl', 'ceik', 'dj']) (1, 1, ['agm', 'bfhln', 'ceik', 'dj']) 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"007._Reverse_Integer.html":{"url":"007._Reverse_Integer.html","title":"007 Reverse Integer","keywords":"","body":"7. Reverse Integer 反转整数 题目 https://leetcode.com/problems/Reverse-Integer https://leetcode-cn.com/problems/reverse-integer/description/ 给定一个 32 位有符号整数，将整数中的数字进行反转。 > 示例 1: 输入: 123 输出: 321 > 示例 2: 输入: -123 输出: -321 > 示例 3: 输入: 120 输出: 21 注意: 假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231, 231 − 1]。 根据这个假设，如果反转后的整数溢出，则返回 0。 难度: Easy 翻转数字问题需要注意的就是溢出问题，为什么会存在溢出问题呢，我们知道int型的数值范围是 -2147483648～2147483647(负的2的31次方~2的31次方-1)， 那么如果我们要翻转 1000000009 这个在范围内的数得到 9000000001，而翻转后的数就超过了范围。 思路1 如果输入的是负数，就递归调用原函数，参数变成-x即可 class Solution(object): def reverse(self, x): \"\"\" :type x: int :rtype: int \"\"\" if x 思路2 按照参数正负号先将其转成字符串，然后再反转，根据是否溢出决定输出0还是反转结果 class Solution(object): def reverse(self, x): \"\"\" :type x: int :rtype: int \"\"\" x = -int(str(x)[::-1][:-1]) if x 0x7FFFFFFF else x return x 思路3(StefanPochmann大神)： 看这个解法前先看backticks cmp函数在python3.x中用不了了，import operator用gt或者lt吧，或者回归if/else condition爸爸的怀抱吧！ class Solution(object): def reverse(self, x): \"\"\" :type x: int :rtype: int \"\"\" s = cmp(x, 0) r = int(`s * x`[::-1]) return s * r * (r 思路4 1.记录符号 2.将数字当字符串处理 3.判断是否阈值区间，进行比较就行 class Solution: def reverse(self, x): \"\"\" :type x: int :rtype: int \"\"\" mark = 1 if x>=0 else -1 x_abs = abs(x) result = mark * int(str(x_abs)[::-1]) return result if -2**31 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"009._Palindrome_Number.html":{"url":"009._Palindrome_Number.html","title":"009 Palindrome Number","keywords":"","body":"9. Palindrome Number 回文数 题目 https://leetcode.com/problems/palindrome-number https://leetcode-cn.com/problems/palindrome-number/description 判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 示例 1: 输入: 121 输出: true 示例 2: 输入: -121 输出: false 解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 示例 3: 输入: 10 输出: false 解释: 从右向左读, 为 01 。因此它不是一个回文数。 进阶: 你能不将整数转为字符串来解决这个问题吗？ 难度：Medium 思路1 （满足Follow up) 首先负数肯定不是palindrome 其次如果一个数字是一个正数，并且能被我0整除那它肯定也不是palindrome 这样降低了复杂度 class Solution(object): def isPalindrome(self, x): \"\"\" :type x: int :rtype: bool \"\"\" if x 0: rev = rev * 10 + x % 10 x /= 10 return y == rev 思路2 排除小于0的数 通过字符串进行反转，对比数字是否相等就行 class Solution: def isPalindrome(self, x): \"\"\" :type x: int :rtype: bool \"\"\" if x 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"010._regular_expression_matching.html":{"url":"010._regular_expression_matching.html","title":"010 regular expression matching","keywords":"","body":"010. Regular Expression Matching 题目: https://leetcode.com/problems/regular-expression-matching/ 难度: Hard 先尝试暴力解法，难点就在 身上， 不会单独出现，它一定是和前面一个字母或\".\"配成一对。看成一对后\"X*\"，它的性质就是：要不匹配0个，要不匹配连续的“X”.所以尝试暴力解法的时候一个trick是从后往前匹配. 暴力解法居然也能AC? 是这样来分情况看得: 如果s[i] = p[j] 或者 p[j]= . ： 往前匹配一位 如果p[j] = ' ', 检查一下，如果这个时候p[j-1] = . 或者p[j-1] = s[i] ，那么就往前匹配，如果这样能匹配过，就return True， 否者我们忽略 ' X ',这里注意里面的递推关系 再处理一下边界状况： s已经匹配完了， 如果此时p还有，那么如果剩下的是 X* 这种可以过，所以检查 p匹配完毕，如果s还有那么报错 class Solution(object): def isMatch(self, s, p): \"\"\" :type s: str :type p: str :rtype: bool \"\"\" def helper(s, i, p, j): if j == -1: return i == -1 if i == -1: if p[j] != '*': return False return helper(s, i, p, j-2) if p[j] == '*': if p[j-1] == '.' or p[j-1] == s[i]: if helper(s, i-1, p, j): return True return helper(s, i, p, j-2) if p[j] == '.' or p[j] == s[i]: return helper(s, i-1, p, j-1) return False return helper(s, len(s)-1, p, len(p)-1) dp优化，感觉和edit distance很像。 DP优化待代码化，感觉学DP的一个重点除了递归学好以外，另一点是一定要会画表格。 画一个表格来看一下状况 c * a * b 0 1 2 3 4 5 0 1 0 1 0 1 0 a 1 0 0 0 1 1 0 a 2 0 0 0 0 1 0 b 3 0 0 0 0 0 1 这里有几个取巧/容易出问题的敌方，这里画的表用的是1-based string。一上来，做的事包括： 初始化，空字符匹配：dp[0][0] =1 第一行，c 可以匹配空字符，c a* 可以匹配空字符，p[j-1] != s[i]，匹配空字符 然后进入第二行再来看，实际上我们可以看到，如果没有碰到 匹配还是很朴素的，但是碰到 ： 1这个匹配可以从左侧传来，dp[i][j] = dp[i][j-1]，that is 匹配 1个 1 也可以有上方传来，这种情况是p[j-1] = s[i]，匹配多个 dp[i][j] = dp[i-1][j] 1 这个匹配也可以从间隔一个的左侧传来，that is也可以有个性的匹配0个,如同匹配空字符一样dp[i][j] = dp[i][j-2]，但是注意匹配0个实际上有两种状况，如果p[j-1]!=s[i],强制匹配0个，即使p[j-1] == s[i],我们也可以傲娇的用它来匹配0个。 再代码化一点： s[i] == p[j] 或者 p[j] == '.' : dp[i][j] = dp[i-1][j-1] p[j] == '*': 然后分几种情况 p[j-1] != s[i] : dp[i][j] = dp[i][j-2] 匹配0个的状况 p[j-1] == s[i] or p[i-1] == '.': dp[i][j] = dp[i-1][j] 匹配多个s[i] dp[i][j] = dp[i][j-2] 匹配0个 AC代码，注意一下，因为上表为了表达方便，用的是1-based string系统，实际写代码的时候我们心里还是清楚这个string还是从0开始的，不过也可以尝试往前面添东西来方便。 AC代码 class Solution(object): def isMatch(self, s, p): \"\"\" :type s: str :type p: str :rtype: bool \"\"\" m, n = len(s), len(p) dp = [ [0 for i in range(n+1)] for j in range(m+1)] dp[0][0] = 1 # init the first line for i in range(2,n+1): if p[i-1] == '*': dp[0][i] = dp[0][i-2] for i in range(1,m+1): for j in range(1,n+1): if p[j-1] == '*': if p[j-2] != s[i-1] and p[j-2] != '.': dp[i][j] = dp[i][j-2] elif p[j-2] == s[i-1] or p[j-2] == '.': dp[i][j] = dp[i-1][j] or dp[i][j-2] elif s[i-1] == p[j-1] or p[j-1] == '.': dp[i][j] = dp[i-1][j-1] return dp[m][n] == 1 写个测试案例 import unittest class Solution(object): def isMatch(self, s, p): \"\"\" :type s: str :type p: str :rtype: bool \"\"\" m, n = len(s), len(p) dp = [ [0 for i in range(n+1)] for j in range(m+1)] dp[0][0] = 1 # init the first line for i in range(2,n+1): if p[i-1] == '*': dp[0][i] = dp[0][i-2] for i in range(1,m+1): for j in range(1,n+1): if p[j-1] == '*': if p[j-2] != s[i-1] and p[j-2] != '.': dp[i][j] = dp[i][j-2] elif p[j-2] == s[i-1] or p[j-2] == '.': dp[i][j] = dp[i-1][j] or dp[i][j-2] elif s[i-1] == p[j-1] or p[j-1] == '.': dp[i][j] = dp[i-1][j-1] return dp[m][n] == 1 class TestSolution(unittest.TestCase): def test_none_0(self): s = \"\" p = \"\" self.assertTrue(Solution().isMatch(s, p)) def test_none_1(self): s = \"\" p = \"a\" self.assertFalse(Solution().isMatch(s, p)) def test_no_symbol_equal(self): s = \"abcd\" p = \"abcd\" self.assertTrue(Solution().isMatch(s, p)) def test_no_symbol_not_equal_0(self): s = \"abcd\" p = \"efgh\" self.assertFalse(Solution().isMatch(s, p)) def test_no_symbol_not_equal_1(self): s = \"ab\" p = \"abb\" self.assertFalse(Solution().isMatch(s, p)) def test_symbol_0(self): s = \"\" p = \"a*\" self.assertTrue(Solution().isMatch(s, p)) def test_symbol_1(self): s = \"a\" p = \"ab*\" self.assertTrue(Solution().isMatch(s, p)) def test_symbol_2(self): # E.g. # s a b b # p 1 0 0 0 # a 0 1 0 0 # b 0 0 1 0 # * 0 1 1 1 s = \"abb\" p = \"ab*\" self.assertTrue(Solution().isMatch(s, p)) if __name__ == \"__main__\": unittest.main() 输出： ........ Ran 8 tests in 0.001s OK 参考: 动态规划 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"011._container_with_most_water.html":{"url":"011._container_with_most_water.html","title":"011 container with most water","keywords":"","body":"11. Container With Most Water 题目: https://leetcode.com/problems/container-with-most-water/ 难度: Medium 思路： 首先理解花了我一点时间，因为一开始写出来，给了一个例子： height = [3,2,1,3] 解是 9 | | | | | | | | | 1 2 3 4 一开始我的理解走偏的地方是这个9是如何得到的，因为根据最短板原理，明显不可能得到9啊，后来发现是·Find two lines, which together with x-axis forms a container, such that the container contains the most water. 所以代码写起来就简单了,AC无能，超时，时间复杂度O(N^2) class Solution(object): # 此法超时 def maxArea(self, height): \"\"\" :type height: List[int] :rtype: int \"\"\" n = len(height) most_water = 0 for i in range(n-1): for j in range(i, n): water = (j-i) * min(height[i], height[j]) most_water = max(water, most_water) return most_water 题目给的tag是 two pointer，所以上边的策略肯定可以改进，改进的地方就不能是这个一次走一边，而可能是两边都要走。 参考 http://bangbingsyb.blogspot.com/2014/11/leetcode-container-with-most-water.html 思路： 由于ai和aj (i 所以对于任何S(i'>=i, j'= S(i,j)，由于j'-i' ，必然要有min(ai',aj')>=min(ai,aj)才行。同样可以采用头尾双指针向中间移动： 当a(left) 时，对任何j来说 min(a(left),aj) j-left 所以S(left, right) > S(left, j 这就排除了所有以left为左边界的组合，因此需要右移left。这里证明的非常好。 a[left] 同理，当a(left) > a(right)时，需要左移right。 而当a(left) = a(right)时，需要同时移动left和right。 思路整理： left = 0, right = n-1 a[left] a[left] > a[right], right-- a[left] = a[right], left++, right-- 终止条件：left >= right 这个证明大快人心 这样写也能过: class Solution(object): def maxArea(self, height): \"\"\" :type height: List[int] :rtype: int \"\"\" n = len(height) left, right = 0, n-1 most_water = 0 while left height[right]: right -= 1 else: left += 1 right -= 1 return most_water 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"012._Integer_to_Roman.html":{"url":"012._Integer_to_Roman.html","title":"012 Integer to Roman","keywords":"","body":"12. Integer to Roman 题目: https://leetcode.com/problems/integer-to-roman/ 难度: Medium 思路： 首先我学习了一下罗马字母是如何表示的。然后感慨，这个阿拉伯数字是多么好的发明 上图 基于的是这些个Symbol： 1 5 10 50 100 500 1000 I V X L C D M 罗马数字表示法见Leetcode 013 这里有一个很棒的算法 AC代码 class Solution(object): def intToRoman(self, num): \"\"\" :type num: int :rtype: str \"\"\" lookup = { 'M': 1000, 'CM': 900, 'D': 500, 'CD': 400, 'C': 100, 'XC': 90, 'L': 50, 'XL': 40, 'X': 10, 'IX': 9, 'V': 5, 'IV': 4, 'I': 1 } romanStr = '' for symbol, val in sorted(lookup.items(), key = lambda t: t[1], reverse = True): while num >= val: romanStr += symbol num -= val return romanStr 因为dict本身是无序的，这里做了一个排序的操作，否则可能会出现IIII这种状况。 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"013._Roman_to_Integer.html":{"url":"013._Roman_to_Integer.html","title":"013 Roman to Integer","keywords":"","body":"13.Roman to Integer 题目: https://leetcode.com/problems/roman-to-integer/ 难度: Easy 思路： 罗马数字是最古老的数字表示方式，比阿拉伯数组早2000多年，起源于罗马 罗马数字有如下符号： 基本字符 I V X L C D M 对应阿拉伯数字 1 5 10 50 100 500 1000 计数规则： - 相同的数字连写，所表示的数等于这些数字相加得到的数，例如：III = 3 - 小的数字在大的数字右边，所表示的数等于这些数字相加得到的数，例如：VIII = 8 - 小的数字，限于（I、X和C）在大的数字左边，所表示的数等于大数减去小数所得的数，例如：IV = 4,这条规则好像这题不管 - 正常使用时，连续的数字重复不得超过三次 - 在一个数的上面画横线，表示这个数扩大1000倍（本题只考虑3999以内的数，所以用不到这条规则） - 从前向后遍历罗马数字，如果某个数比前一个数小，则加上该数。反之，减去前一个数的两倍然后加上该数 integer to Roman 是 Medium，这个roman to integer是easy 从前往后扫描，用一个临时变量记录分段数字。 如果当前比前一个大，说明这一段的值应当是这个值减去上一个值。比如IV = 5-1 =4; 否则，将当前值加入到结果中，然后开始下一段记录，比如VI = 5 + 1, II = 1 +1 所以这也就是罗马数字的基础，感觉？这样才不会读串？ AC代码 class Solution(object): def romanToInt(self, s): \"\"\" :type s: str :rtype: int \"\"\" lookup = { 'M': 1000, 'D': 500, 'C': 100, 'L': 50, 'X': 10, 'V': 5, 'I': 1 } res = 0 for i in range(len(s)): if i > 0 and lookup[s[i]] > lookup[s[i-1]]: res = res + lookup[s[i]] - 2 * lookup[s[i-1]] else: res += lookup[s[i]] return res 或者甚至可以建立一个新函数用于取对应数值： def table(x): return { 'I':1, 'V':5, 'X':10, 'L':50, 'C':100, 'D':500, 'M':1000 }.get(x) 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"014._longest_common_prefix.html":{"url":"014._longest_common_prefix.html","title":"014 longest common prefix","keywords":"","body":"14. Longest Common Prefix 题目: https://leetcode.com/problems/longest-common-prefix/ 难度: Easy 思路： 解法1: 以一个小例子来解释，strs=['laa', 'lab', 'lac'], 如果存在LCP的话它肯定就在第一个字符串strs[0]中，并且LCP的长度肯定不会大于strs[0]的长度 依次假设LCP长度为0到len(strs[0]),在每一轮循环中: 只要strs中存在比当前长度i更短的string，立刻返回上一轮LCP，即strs[0][:i] 只要strs中存在当前index字符与LCP该index不相同的字符串，立刻返回上一轮LCP，即strs[0][:i] 如果一直没返回，说明strs[0]本身就是LCP，返回它 class Solution(object): def longestCommonPrefix(self, strs): \"\"\" :type strs: List[str] :rtype: str \"\"\" if not strs: return \"\" for i in range(len(strs[0])): for str in strs: if len(str) 解法2: dp[i]代表前i+1个字符串的最大前缀串， 如果第i+2个字符串不以dp[i]为前缀，就去掉dp[i]的最后一个字符再试一次 都去完了那么dp[i+1]肯定就是空串了，也就等于这时候的dp[i]，因为dp[i]的每个字符已经被去完了class Solution(object): def longestCommonPrefix(self, strs): \"\"\" :type strs: List[str] :rtype: str \"\"\" if not strs: return '' dp = [strs[0]]*len(strs) for i in range(1,len(strs)): while not strs[i].startswith(dp[i-1]): dp[i-1] = dp[i-1][:-1] dp[i] = dp[i-1] return dp[-1] python无敌啊！！！有没有天理啊，手动滑稽😏😏😏😏！一行解法： class Solution(object): def longestCommonPrefix(self, strs): \"\"\" :type strs: List[str] :rtype: str \"\"\" return os.path.commonprefix(strs) 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"015._3sum.html":{"url":"015._3sum.html","title":"015 3sum","keywords":"","body":"15. 3Sum 题目: https://leetcode.com/problems/3sum/ 难度: Medium 第一想法，先把nums排序，用三个loop，无法AC class Solution(object): def threeSum(self, nums): \"\"\" :type nums: List[int] :rtype: List[List[int]] \"\"\" n = len(nums) res = [] nums.sort() for i in range(n): for j in range(i,n): for k in range(j,n): if nums[i] + nums[j] + nums[k] == 0 and j != i and k != j and k != i: curRes = [nums[i],nums[j],nums[k]] if curRes not in res: res.append(curRes) return res 然后查了一下2sum，用2sum的花样，因为要排除重复以及输出是按照从小到大的输出:但是还是超时 class Solution(object): # 此法也超时 def threeSum(self, nums): \"\"\" :type nums: List[int] :rtype: List[List[int]] \"\"\" def twoSum(nums, target): \"\"\" :type nums: List[int] :type target: int :rtype: List[int] \"\"\" lookup = {} for num in nums: if target - num in lookup: if (-target ,target - num, num) not in res: res.append((-target ,target - num, num)) lookup[num] = target - num n = len(nums) nums.sort() res = [] for i in range(n): twoSum(nums[i+1:], 0-nums[i]) return [list(i) for i in res] 谷歌看别人的代码，思路非常清晰的,运行起来比直接调用 Two Sum快. 清晰的思路： 排序 固定左边，如果左边重复，继续 左右弄边界，去重，针对不同的左右边界情况处理 class Solution(object): def threeSum(self, nums): \"\"\" :type nums: List[int] :rtype: List[List[int]] \"\"\" n, res = len(nums), [] nums.sort() for i in range(n): if i > 0 and nums[i] == nums[i-1]: # 因为i=0这个元素会直接往下执行 continue l, r = i+1, n-1 while l 0: r -= 1 else: l += 1 return res 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"016._3sum_closest.html":{"url":"016._3sum_closest.html","title":"016 3sum closest","keywords":"","body":"16. 3Sum Closest 题目: https://leetcode.com/problems/3sum-closest/ 难度: Medium 思路： 跟3 Sum一样，固定一个元素 用两个指针来循环 class Solution(object): def threeSumClosest(self, nums, target): \"\"\" :type nums: List[int] :rtype: List[List[int]] \"\"\" n, res, diff = len(nums), None, float('inf') nums.sort() for i in range(n): if i > 0 and nums[i] == nums[i-1]: continue l, r = i+1, n-1 while l target: r -= 1 if abs(tmp-target) 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"017._letter_combinations_of_a_phone_number.html":{"url":"017._letter_combinations_of_a_phone_number.html","title":"017 letter combinations of a phone number","keywords":"","body":"17. Letter Combinations of a Phone Number 题目: https://leetcode.com/problems/letter-combinations-of-a-phone-number/ 难度: Medium 思路： hash table一个，用来对应digit -> letter s用来记录结果，每次从digits里面去一个，然后寻找其可能的char，加到s中，digits长度减小 digits长度为0时候，把它加入结果 class Solution(object): def letterCombinations(self, digits): \"\"\" :type digits: str :rtype: List[str] \"\"\" if digits == '': return [] self.res = [] self.singleResult('', digits) return self.res def singleResult(self, s, digits): if len(digits) == 0: self.res.append(s) else: mapx = {'2':['a','b','c'], '3':['d','e','f'], '4':['g','h','i'], '5':['j','k','l'], '6':['m','n','o'], '7':['p','q','r','s'], '8':['t','u','v'], '9':['w','x','y','z']} cur_digit = digits[0] for c in mapx[cur_digit]: self.singleResult(s+c, digits[1:]) 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"018._4sum.html":{"url":"018._4sum.html","title":"018 4sum","keywords":"","body":"18. 4Sum 题目: https://leetcode.com/problems/4sum/ 难度: Medium 思路： 用3sum改 固定两个数，活动别的 class Solution(object): def fourSum(self, nums, target): \"\"\" :type nums: List[int] :type target: int :rtype: List[List[int]] \"\"\" n = len(nums) nums.sort() res = [] for i in range(n): for j in range(i+1,n): l, r = j+1, n-1 while l target: r -= 1 else: l+=1 return ans 可以通过加判断条件，前后数字相等可以直接跳过，使得算法更快 class Solution(object): def fourSum(self, nums, target): \"\"\" :type nums: List[int] :type target: int :rtype: List[List[int]] \"\"\" n, res = len(nums), [] nums.sort() for i in range(n): if i > 0 and nums[i] == nums[i-1]: # 因为i=0这个元素会直接往下执行 continue for j in range(i+1, n): if j > i+1 and nums[j] == nums[j-1]: # 因为j=i+1这个元素会直接往下执行 continue l, r = j+1, n-1 while l target: r -= 1 else: l += 1 return res 还可以再用一些判断来加速，比如枚举第一个数的时候 nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] > target: break 这是当前能凑齐的最小的4个数，比target后面都不用做了 nums[i] + nums[n – 3] + nums[n – 2] + nums[n – 1] 参考 https://www.hrwhisper.me/leetcode-2-sum-3-sum-4-sum-3-sum-closest-k-sum/ class Solution(object): def fourSum(self, nums, target): \"\"\" :type nums: List[int] :type target: int :rtype: List[List[int]] \"\"\" n, res = len(nums), [] nums.sort() for i in range(n): if i > 0 and nums[i] == nums[i-1]: # 因为i=0这个元素会直接往下执行 continue if i+3 target: break if i i+1 and nums[j] == nums[j-1]: # 因为j=i+1这个元素会直接往下执行 continue l, r = j+1, n-1 while l target: r -= 1 else: l += 1 return res 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"019._remove_nth_node_from_end_of_list.html":{"url":"019._remove_nth_node_from_end_of_list.html","title":"019 remove nth node from end of list","keywords":"","body":"19. Remove Nth Node From End of List 题目： https://leetcode.com/problems/remove-nth-node-from-end-of-list/ 难度: Medium AC击败了95.80%的Python用户，技巧 dummy head 和双指针。 切记最后要返回dummy.next而不是head，因为有这样一种情况，删掉节点后linked list空了，那返回head的话结果显然不同。如： 输入链表为[1], n = 1, 应该返回None而不是[1] class Solution(object): def removeNthFromEnd(self, head, n): \"\"\" :type head: ListNode :type n: int :rtype: ListNode \"\"\" dummy = ListNode(-1) dummy.next = head p, q = dummy, dummy for i in range(n): q = q.next while q.next: p = p.next q = q.next p.next = p.next.next return dummy.next 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"020._valid_parentheses.html":{"url":"020._valid_parentheses.html","title":"020 valid parentheses","keywords":"","body":"20. Valid Parentheses 有效的括号 难度: Easy 刷题内容 原题连接 https://leetcode.com/problems/valid-parentheses https://leetcode-cn.com/problems/valid-parentheses/description 内容描述 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。 示例 1: 输入: \"()\" 输出: true 示例 2: 输入: \"()[]{}\" 输出: true 示例 3: 输入: \"(]\" 输出: false 示例 4: 输入: \"([)]\" 输出: false 示例 5: 输入: \"{[]}\" 输出: true 解题方案 思路 1 因为一共只有三种状况\"(\" -> \")\", \"[\" -> \"]\", \"{\" -> \"}\". 一遇到左括号就入栈，右括号出栈，这样来寻找对应 需要检查几件事： 出现右括号时stack里还有没有东西 出stack时是否对应 最终stack是否为空 class Solution(object): def isValid(self, s): \"\"\" :type s: str :rtype: bool \"\"\" leftP = '([{' rightP = ')]}' stack = [] for char in s: if char in leftP: stack.append(char) if char in rightP: if not stack: return False tmp = stack.pop() if char == ')' and tmp != '(': return False if char == ']' and tmp != '[': return False if char == '}' and tmp != '{': return False return stack == [] 思路 2 扩展性和可理解性强 class Solution: def isValid(self, s): \"\"\" :type s: str :rtype: bool \"\"\" if len(s) % 2 == 1: return False index = 0 stack = [i for i in s] map1 = {\"(\": \")\", \"[\": \"]\", \"{\": \"}\"} while len(stack) > 0: # 判断索引是否超过边界 if index >= len(stack)-1: return False b = stack[index] e = stack[index+1] if b not in map1.keys(): return False elif e in map1.keys(): index += 1 elif map1[b] == e: stack.pop(index+1) stack.pop(index) index = 0 if index-1 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"021._merge_two_sorted_lists.html":{"url":"021._merge_two_sorted_lists.html","title":"021 merge two sorted lists","keywords":"","body":"21. Merge Two Sorted Lists 题目： https://leetcode.com/problems/merge-two-sorted-lists/ 难度: Easy 同样适用dummy head class Solution(object): def mergeTwoLists(self, l1, l2): \"\"\" :type l1: ListNode :type l2: ListNode :rtype: ListNode \"\"\" if l1 == None: return l2 if l2 == None: return l1 dummy = ListNode(-1) cur = dummy while l1 and l2: if l1.val 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"022._generate_parentheses.html":{"url":"022._generate_parentheses.html","title":"022 generate parentheses","keywords":"","body":"22. Generate Parentheses 题目: https://leetcode.com/problems/generate-parentheses/ 难度: Medium class Solution(object): def generateParenthesis(self,n): \"\"\" :type n: int :rtype: List[str] \"\"\" self.res = [] self.singleStr('', 0, 0, n) return self.res def singleStr(self, s, left, right, n): if left == n and right == n: self.res.append(s) if left 非常牛逼的讲解，需要这样的人来给我们讲算法 以Generate Parentheses为例，backtrack的题到底该怎么去思考？ 所谓Backtracking都是这样的思路：在当前局面下，你有若干种选择。那么尝试每一种选择。如果已经发现某种选择肯定不行（因为违反了某些限定条件），就返回；如果某种选择试到最后发现是正确解，就将其加入解集 所以你思考递归题时，只要明确三点就行：选择 (Options)，限制 (Restraints)，结束条件 (Termination)。即“ORT原则”（这个是我自己编的） 对于这道题，在任何时刻，你都有两种选择： 加左括号。 加右括号。 同时有以下限制： 如果左括号已经用完了，则不能再加左括号了。 如果已经出现的右括号和左括号一样多，则不能再加右括号了。因为那样的话新加入的右括号一定无法匹配。 结束条件是： 左右括号都已经用完。 结束后的正确性： 左右括号用完以后，一定是正确解。因为1. 左右括号一样多，2. 每个右括号都一定有与之配对的左括号。因此一旦结束就可以加入解集（有时也可能出现结束以后不一定是正确解的情况，这时要多一步判断）。 递归函数传入参数： 限制和结束条件中有“用完”和“一样多”字样，因此你需要知道左右括号的数目。 当然你还需要知道当前局面sublist和解集res。 因此，把上面的思路拼起来就是代码： if (左右括号都已用完) { 加入解集，返回 } //否则开始试各种选择 if (还有左括号可以用) { 加一个左括号，继续递归 } if (右括号小于左括号) { 加一个右括号，继续递归 } 你帖的那段代码逻辑中加了一条限制：“3. 是否还有右括号剩余。如有才加右括号”。这是合理的。不过对于这道题，如果满足限制1、2时，3一定自动满足，所以可以不判断3。 这题其实是最好的backtracking初学练习之一，因为ORT三者都非常简单明显。你不妨按上述思路再梳理一遍，还有问题的话再说。 以上文字来自 1point3arces的牛人解答 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"023._merge_k_sorted_lists.html":{"url":"023._merge_k_sorted_lists.html","title":"023 merge k sorted lists","keywords":"","body":"23. Merge k Sorted Lists 题目: https://leetcode.com/problems/merge-k-sorted-lists/ 难度: Hard 思路： 看到思路有heap，similar question有ugly number|| -> 这个是用heapq来解决的 那么就用heap吧？ heapsort 最简单的做法是只要每个list里面还有node，就把他们扔到minheap里面去，然后再把minheap pop，一个一个node连起来，听起来时间复杂度和空间复杂度都蛮高的。 直接merge必然是不好的，因为没有利用有序这个点，应该做的是每次取来一个，然后再把应该的下一个放入 写到这里瞬间明白和ugly number ii像的点了，甚至感觉跟find in sorted matrix ii也像 class Solution(object): def mergeKLists(self, lists): \"\"\" :type lists: List[ListNode] :rtype: ListNode \"\"\" import heapq h = [] for lst_head in lists: if lst_head: heapq.heappush(h, (lst_head.val, lst_head)) cur = ListNode(-1) dummy = cur while h: smallest_node = heapq.heappop(h)[1] cur.next = smallest_node cur = cur.next if smallest_node.next: heapq.heappush(h, (smallest_node.next.val, smallest_node.next)) return dummy.next 当然还像merge two sorted list 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"024._swap_nodes_in_pairs.html":{"url":"024._swap_nodes_in_pairs.html","title":"024 swap nodes in pairs","keywords":"","body":"24. Swap Nodes in Pairs 题目： https://leetcode.com/problems/swap-nodes-in-pairs/ 难度 : Medium 一眼就知道这个用递归做，beats 96.06% class Solution(object): def swapPairs(self, head): \"\"\" :type head: ListNode :rtype: ListNode \"\"\" if not head: return None if not head.next: return head tmp = head.next head.next = self.swapPairs(head.next.next) tmp.next = head return tmp 或者用loop做，每个node关系要弄清楚, 又是巧用dummy，dummy大法对于nodeList的题目简直无敌！！！🐂批, 但是只beats了69.40% class Solution(object): def swapPairs(self, head): \"\"\" :type head: ListNode :rtype: ListNode \"\"\" if head == None or head.next == None: return head dummy = ListNode(-1) dummy.next = head cur = dummy while cur.next and cur.next.next: next_one, next_two, next_three = cur.next, cur.next.next, cur.next.next.next cur.next = next_two next_two.next = next_one next_one.next = next_three cur = next_one return dummy.next 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"026._Remove_Duplicates_from_Sorted_Array.html":{"url":"026._Remove_Duplicates_from_Sorted_Array.html","title":"026 Remove Duplicates from Sorted Array","keywords":"","body":"26. Remove Duplicates from Sorted Array 题目: https://leetcode.com/problems/remove-duplicates-from-sorted-array/ 难度: Easy 思路： 因为题目说了是sorted array，所以只需要不停判断当前位置值和下一位置是否相等，若相等则pop掉当前值，否则move到下一位置做重复判断 class Solution(object): def removeDuplicates(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" i = 0 while i 这里代码用while loop而不用for loop是因为pop操作之后nums的长度会变化 如：for i in range(len(nums)-1)实际上固定了range里面的值了，不会二次判断 n = 10 for i in range(n): n = n - 1 # 尽管n在变化 print(i) 上面这段代码的输出结果为： 0 1 2 3 4 5 6 7 8 9 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"027._Remove_Element.html":{"url":"027._Remove_Element.html","title":"027 Remove Element","keywords":"","body":"27. Remove Element 题目: https://leetcode.com/problems/remove-element/ 难度: Easy 瞬秒 class Solution(object): def removeElement(self, nums, val): \"\"\" :type nums: List[int] :type val: int :rtype: int \"\"\" while val in nums: nums.remove(val) return len(nums) 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"030._Substring_with_Concatenation_of_All_Words.html":{"url":"030._Substring_with_Concatenation_of_All_Words.html","title":"030 Substring with Concatenation of All Words","keywords":"","body":"30. Substring with Concatenation of All Words 题目： https://leetcode.com/problems/substring-with-concatenation-of-all-words/description/ 难度 : Hard class Solution(object): def findSubstring(self, s, words): \"\"\" :type s: str :type words: List[str] :rtype: List[int] \"\"\" res = [] if len(words) == 0 or len(s) maps[string]: tmp = s[start:start+wl] cur_map[tmp] -= 1 start += wl if cur_map[tmp] 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"031._next_permutation.html":{"url":"031._next_permutation.html","title":"031 next permutation","keywords":"","body":"31. Next Permutation 题目: https://leetcode.com/problems/next-permutation/ 难度: Medium 参照wikipedia： https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order 首先，关于什么是全排列不做解释。如果一个排列为A，下一个排列为A_NEXT，那么A_NEXT一定与A有尽可能长的公共前缀。 看具体例子，一个排列为124653，如何找到它的下一个排列，因为下一个排列一定与124653有尽可能长的前缀，所以，脑洞大开一下，从后面往前看这个序列，如果后面的若干个数字有下一个排列，问题就得到了解决。 第一步：找最后面1个数字的下一个全排列。 124653，显然最后1个数字3不具有下一个全排列。 第二步：找最后面2个数字的下一个全排列。 124653，显然最后2个数字53不具有下一个全排列。 第三步：找最后面3个数字的下一个全排列。 124653，显然最后3个数字653不具有下一个全排列。 ------插曲：到这里相信大家已经看出来，如果一个序列是递减的，那么它不具有下一个排列。 第四步：找最后面4个数字的下一个全排列。 124653，我们发现显然最后4个数字4653具有下一个全排列。因为它不是递减的，例如6453，5643这些排列都在4653的后面。 我们总结上面的操作，并总结出重复上面操作的两种终止情况： 1：从后向前比较相邻的两个元素，直到前一个元素小于后一个元素，停止 2：如果已经没有了前一个元素，则说明这个排列是递减的，所以这个排列是没有下一个排列的。 124653这个排列终止情况是上面介绍的第一种，从后向前比较相邻的2个元素，遇到4 并且我们可以知道： 1：124653和它的下一个排列的公共前缀为12(因为4653存在下一个排列，所以前面的数字12保持不变) 2：4后面的元素是递减的(上面介绍的终止条件是前一个元素小于后一个元素，这里是4 现在，我们开始考虑如何找到4653的下个排列，首先明确4后面的几个数字中至少有一个大于4. 4肯定要和653这3个数字中大于4的数字中(6，5)的某一个进行交换。这里就是4要和6，5中的某一个交换，很明显要和5交换，如果找到这样的元素呢，因为我们知道4后面的元素是递减的，所以在653中从后面往前查找，找到第一个大于4的数字，这就是需要和4进行交换的数字。这里我们找到了5，交换之后得到的临时序列为5643.，交换后得到的643也是一个递减序列。 所以得到的4653的下一个临时序列为5643，但是既然前面数字变大了(4653--->5643)，后面的自然要变为升序才行，变换5643得到5346. 所以124653的下一个序列为125346. 看一个permutation，比如 125430 从末尾开始，找到decreasing subsequence，5430，因为来调5330无论怎么调，都不可能有比它更小的，数也被自然的分成两部分(1,2) 和 （5，4，3，0) 下一步是找这个sequence里面第一个比前面部分，比2大的，3，也很容易理解，因为下一个必定是(1,3)打头 交换 3和2 ，变成 (1,3,5,4,2,0),再把后面的部分reverse，得到后面部分可得到的最小的 这个时候，得到下一个sequence 130245 AC 代码 class Solution(object): def nextPermutation(self, nums): \"\"\" :type nums: List[int] :rtype: void Do not return anything, modify nums in-place instead. \"\"\" if len(nums) nums[i-1]: # find first number which is smaller than it's after number idx = i break if idx != 0: # if the number exist,which means that the nums not like{5,4,3,2,1} for i in range(len(nums)-1, idx-1, -1): if nums[i] > nums[idx-1]: nums[i], nums[idx-1] = nums[idx-1], nums[i] break nums[idx:] = nums[idx:][::-1] 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"032._longest_valid_parentheses.html":{"url":"032._longest_valid_parentheses.html","title":"032 longest valid parentheses","keywords":"","body":"32. longest-valid-parentheses 最长有效括号 难度: 困难 刷题内容 原题连接 https://leetcode.com/problems/longest-valid-parentheses https://leetcode-cn.com/problems/longest-valid-parentheses/description 内容描述 给定一个只包含 '(' 和 ')' 的字符串，找出最长的包含有效括号的子串的长度。 示例 1: 输入: \"(()\" 输出: 2 解释: 最长有效括号子串为 \"()\" 示例 2: 输入: \")()())\" 输出: 4 解释: 最长有效括号子串为 \"()()\" 解题方案 思路 1 动态规划，参考banananana 用一个dp数组来存放以每个index为结尾的最长有效括号子串长度，例如：dp[3] = 2代表以index为3结尾的最长有效括号子串长度为2 很明显dp[i]和dp[i-1]之间是有关系的 当s[i] == ‘(’时，dp[i]显然为0, 由于我们初始化dp的时候就全部设为0了，所以这种情况压根不用写 当s[i] == ')'时， 如果在dp[i-1]的所表示的最长有效括号子串之前还有一个'('与s[i]对应，那么dp[i] = dp[i-1] + 2, 并且还可以继续往前追溯（如果前面还能连起来的话) class Solution(object): def longestValidParentheses(self, s): \"\"\" :type s: str :rtype: int \"\"\" if len(s) == 0: return 0 dp = [0 for i in range(len(s))] for i in range(1, len(s)): if s[i] == ')': left = i - 1 - dp[i-1] if left >= 0 and s[left] == '(': dp[i] = dp[i-1] + 2 if left > 0: # 这个是判断 left 前面是否能与后面继续连起来 dp[i] += dp[left-1] return max(dp) 思路 2 每当遇到一个左括号或者是无法成对的右括号，就将它压入栈中，可以成对的括号则从栈中 pop 出。这样栈中剩下的就是无法成对的括号的下标。这时我们可以判断这些下标间的距离来获得最大的成对括号长度。 在这里，我们需要先遍历一遍字符串，再遍历一下非空的堆栈。一定要注意，这里我们遍历的非空的栈存储的是没有匹配上的括号下标，匹配上的我们都已经做了pop 处理。 class Solution(object): def longestValidParentheses(self, s): \"\"\" :type s: str :rtype: int \"\"\" stack = [] for i in range(len(s)): if s[i] == ')': if stack and s[stack[-1]] == '(': ## 这里要注意，不能想当然地用s[i-1]，因为我们有些下标直接continue了没有存到栈中去 stack.pop() continue stack.append(i) max_length = 0 next_index = len(s) while stack: cur_index = stack.pop() cur_length = next_index - cur_index - 1 max_length = max(cur_length, max_length) next_index = cur_index return max(next_index, max_length) 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"033._search_in_rotated_sorted_array.html":{"url":"033._search_in_rotated_sorted_array.html","title":"033 search in rotated sorted array","keywords":"","body":"33. Search in Rotated Sorted Array 题目: https://leetcode.com/problems/search-in-rotated-sorted-array/ 难度: Medium 思路： 下面是rotated-array图解， 所以直接用二分，O(lg(n)) 如果是mid，return mid 如果mid在绿色线上，就对绿色线进行二分 如果mid在红色线上，就对红色线进行二分 都没找到，return -1 class Solution(object): def search(self, nums, target): \"\"\" :type nums: List[int] :type target: int :rtype: int \"\"\" l, r = 0, len(nums) - 1 while l > 2) if nums[mid] == target: return mid if nums[mid] 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"034._Search for a Range.html":{"url":"034._Search for a Range.html","title":"034 Search for a Range","keywords":"","body":"34. Search for a Range 题目： https://leetcode.com/problems/search-for-a-range/ 难度 : Medium 思路： 二分法，先找target出现的左边界，判断是否有target后再判断右边界 找左边界：二分，找到一个index 该index对应的值为target 并且它左边index-1对应的值不是target（如果index为0则不需要判断此条件） 如果存在index就将其append到res中 判断此时res是否为空，如果为空，说明压根不存在target，返回[-1, -1] 找右边界：二分，找到一个index（但是此时用于二分循环的l可以保持不变，r重置为len(nums)-1，这样程序可以更快一些） 该index对应的值为target 并且它右边index+1对应的值不是target（如果index为len(nums)-1则不需要判断此条件） 如果存在index就将其append到res中 AC 代码 class Solution(object): def searchRange(self, nums, target): \"\"\" :type nums: List[int] :type target: int :rtype: List[int] \"\"\" if not nums : return [-1, -1] res = [] l, r = 0, len(nums)-1 # search for left bound while l > 2) if nums[mid] == target and (mid == 0 or nums[mid-1] != target): res.append(mid) break if nums[mid] > 2) if nums[mid] == target and (mid == len(nums)-1 or nums[mid+1] != target): res.append(mid) break if nums[mid] > target: r = mid - 1 else: l = mid + 1 return res 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"035._search_insert_position.html":{"url":"035._search_insert_position.html","title":"035 search insert position","keywords":"","body":"35. Search Insert Position 题目: https://leetcode.com/problems/search-insert-position/ 难度: Medium 找到第一个比target大的值的index，如果没找到则返回len(nums),但是代码中直接返回i值就行了 思路一：暴力 class Solution(object): def searchInsert(self, nums, target): \"\"\" :type nums: List[int] :type target: int :rtype: int \"\"\" i = 0 while nums[i] 思路二：二分 class Solution(object): def searchInsert(self, nums, target): \"\"\" :type nums: List[int] :type target: int :rtype: int \"\"\" left, right = 0, len(nums) - 1 while left > 2) if nums[mid] 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"038._Count_and_Say.html":{"url":"038._Count_and_Say.html","title":"038 Count and Say","keywords":"","body":"38. Count and Say 题目: https://leetcode.com/problems/count-and-say/ 难度: Easy 思路 i代表字符下标，从0开始取值，也就是从第一个字符开始，因为要让i取到最后一个字符，并且后面还要进行i+1的操作，所以将原字符串随意加上一个‘*’字符防止溢出 count代表此时已经连续相同的字符个数 res代表最终输出的字符串 只要i下标对应的字符等于下一个字符，则sum和i都加1，无限循环 如果i下标对应的字符不等于下一个字符了，则res应该加上str(sum)和i下标对应的那个字符，并且i加1，sum复原回0 Examples of nth sequence 1. 1 2. 11 3. 21 4. 1211 5. 111221 6. 312211 7. 13112221 8. 1113213211 9. 31131211131221 10. 13211311123113112211 解法1 class Solution(object): def countAndSay(self, n): \"\"\" :type n: int :rtype: str \"\"\" if n == 1: return '1' s = self.countAndSay(n-1) + '*' res, count = '', 1 for i in range(len(s)-1): if s[i] == s[i+1]: count += 1 else: res += str(count) + str(s[i]) count = 1 return res 解法2 class Solution(object): def countAndSay(self, n): \"\"\" :type n: int :rtype: str \"\"\" res = '1' for i in range(n-1): res = ''.join([str(len(list(group))) + digit for digit, group in itertools.groupby(res)]) return res 详见python进阶-ITERTOOLS模块小结 解法3 class Solution { public String countAndSay(int n) { if(n == 1){ return \"1\"; } //递归调用，然后对字符串处理 String str = countAndSay(n-1) + \"*\";//为了str末尾的标记，方便循环读数 char[] c = str.toCharArray(); int count = 1; String s = \"\"; for(int i = 0; i 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"039._combination_sum.html":{"url":"039._combination_sum.html","title":"039 combination sum","keywords":"","body":"39. Combination Sum 题目: https://leetcode.com/problems/combination-sum/ 难度: Medium 最初的思路： res = [] def combSum(candidates, target, valueList): if target == 0: res.append(valueList) for candidate in candidates: if candidate > target: return combSum(candidates, target - candidate, valueList + [candidate] ) 问题在于，有重复： combSum([2,3,6,7],7,[]) res Out[9]: [[2, 2, 3], [2, 3, 2], [3, 2, 2], [7]] 然后看了hint，除[2, 2, 3] 和 [2, 3, 2]这种重复的方式是， 把candidates先sort，然后用index的方式来处理。 所以最终的除重大法如下，根据hint做出： class Solution(object): def combinationSum(self, candidates, target): \"\"\" :type candidates: List[int] :type target: int :rtype: List[List[int]] \"\"\" def dfs(remain, combo, index): if remain == 0: res.append(combo) return for i in range(index, len(candidates)): if candidates[i] > remain: break dfs(remain - candidates[i], combo + [candidates[i]], i) candidates = list(set(candidates)) candidates.sort() res = [] dfs(target, [], 0) return res 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"040._combination_sum_ii.html":{"url":"040._combination_sum_ii.html","title":"040 combination sum ii","keywords":"","body":"40. Combination Sum II 题目: https://leetcode.com/problems/combination-sum-ii/ 难度: Medium Combination Sum 已经AC，做了minor change. 现在不需要set化candidates了 但是递归的时候index要从i+1开始了 要判断combo not in res才append到res中去 class Solution(object): def combinationSum2(self, candidates, target): \"\"\" :type candidates: List[int] :type target: int :rtype: List[List[int]] \"\"\" def dfs(remain, combo, index): if remain == 0 and combo not in res: res.append(combo) return for i in range(index, len(candidates)): if candidates[i] > remain: break dfs(remain - candidates[i], combo + [candidates[i]], i+1) candidates.sort() res = [] dfs(target, [], 0) return res 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"041._First_Missing_Positive.html":{"url":"041._First_Missing_Positive.html","title":"041 First Missing Positive","keywords":"","body":"41. First Missing Positive 难度: 困难 刷题内容 原题连接 https://leetcode.com/problems/first-missing-positive/description/ 内容描述 Given an unsorted integer array, find the smallest missing positive integer. Example 1: Input: [1,2,0] Output: 3 Example 2: Input: [3,4,-1,1] Output: 2 Example 3: Input: [7,8,9,11,12] Output: 1 Note: Your algorithm should run in O(n) time and uses constant extra space. 解题方案 思路 1 题目要求O(n)时间和O(1)空间，所以我们知道先排序再循环找是不行的 因此我们可以这样，第一轮循环，找1(因为1是最小的正整数)，如果1在，立马原地开始继续找2，以此类推，一轮循环结束后，我们记录下当前正在找的值i， 并开始第二轮循环，但是这次从i开始找了，然后以此类推，直到有一次循环我们要找的值没有变过，则代表它没出现过，返回它即可 可以看一个例子 [3,4,-1,1] 第一轮循环：[1,1,1,2] 第二轮循环：[2,2,2,2] 然后我们发现第二轮循环2没有变过了，所以2就是我们要的结果 class Solution(object): def firstMissingPositive(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" old_missing, missing = 0, 1 while old_missing != missing: old_missing = missing for i in range(len(nums)): if nums[i] == missing: missing += 1 return missing 思路 2 如果不限制空间的话，我们用一个dict就可以解决, 时间是O(N) class Solution(object): def firstMissingPositive(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" if not nums: return 1 lookup = {} for i in nums: lookup[i] = 1 for i in range(1, max(nums)+2): if i not in lookup: return i 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"042._trapping_rain_water.html":{"url":"042._trapping_rain_water.html","title":"042 trapping rain water","keywords":"","body":"42. Trapping Rain Water 题目: https://leetcode.com/problems/trapping-rain-water/ 难度: Hard 思路： 题目有几个特性可用，bar width = 1,然后第一个和最后一个是不能trap water，其次中间的部分能trap多少水是看左右高度差较低的那个 - 本身的高度 The basic idea is that we set two pointers l and r to the left and right end of height. Then we get the minimum height (min_height) of these pointers (similar to Container with Most Water due to the Leaking Bucket Effect) since the level of the water cannot be higher than it. Then we move the two pointers towards the center. If the coming level is less than min_height, then it will hold some water. Fill the water until we meet some “barrier” (with height larger than min_height) and update l and r to repeat this process in a new interval. AC代码： class Solution(object): def trap(self, height): \"\"\" :type height: List[int] :rtype: int \"\"\" l, r, water, min_height = 0, len(height) - 1, 0, 0 while l 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"043._multiply_strings.html":{"url":"043._multiply_strings.html","title":"043 multiply strings","keywords":"","body":"43. Multiply Strings 字符串相乘 题目: \">https://leetcode.com/problems/multiply-strings/> https://leetcode-cn.com/problems/multiply-strings/description/ 难度: Medium 参考了别人的思路： m位的数字乘以n位的数字的结果最大为m+n位： 99999 100 = 100000，最多为3+2 = 5位数。 先将字符串逆序便于从最低位开始计算。 class Solution(object): def multiply(self, num1, num2): \"\"\" :type num1: str :type num2: str :rtype: str \"\"\" lookup = {\"0\":0,\"1\":1,\"2\":2,\"3\":3,\"4\":4,\"5\":5,\"6\":6,\"7\":7,\"8\":8,\"9\":9} # 节省查找时间，避免无休止使用ord函数来得到数字 if num1 == '0' or num2 == '0': return '0' num1, num2 = num1[::-1], num2[::-1] tmp_res = [0 for i in range(len(num1)+len(num2))] for i in range(len(num1)): for j in range(len(num2)): tmp_res[i+j] += lookup[num1[i]] * lookup[num2[j]] res = [0 for i in range(len(num1)+len(num2))] for i in range(len(num1)+len(num2)): res[i] = tmp_res[i] % 10 if i 觉得这样写才是最容易理解的，看一个具体的🌰: input: num1, num2 = '91', '91' tmp_res = [1,18,81,0] res = [1,8,2,8] 最终返回 \"8281\" 要注意最终返回头部可能会有‘0’，所以我们用lstrip去除一下 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"044._wildcard_matching.html":{"url":"044._wildcard_matching.html","title":"044 wildcard matching","keywords":"","body":"44. Wildcard Matching 题目: https://leetcode.com/problems/wildcard-matching/ 难度: Hard 做完Regular Expression Matching来做的这道题，按照DP思路run一下是超时，感觉是开心的，至少暂时没有报错了，有待优化，应该在dp的同时在贪心一下么。 超时代码 class Solution(object): def isMatch(self, s, p): \"\"\" :type s: str :type p: str :rtype: bool \"\"\" m, n = len(s), len(p) dp = [ [0 for i in xrange(n+1)] for j in xrange(m+1)] dp[0][0] = 1 # init the first line for i in xrange(1,n+1): if p[i-1] == '*': dp[0][i] = dp[0][i-1] for i in xrange(1,m+1): for j in xrange(1,n+1): if p[j-1] == s[i-1] or p[j-1] == '?': dp[i][j] = dp[i-1][j-1] elif p[j-1] == '*': dp[i][j] = dp[i][j-1] or dp[i-1][j] return dp[m][n] == 1 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"045._Jump_Game_II.html":{"url":"045._Jump_Game_II.html","title":"045 Jump Game II","keywords":"","body":"45. Jump Game II 题目: https://leetcode.com/problems/jump-game-ii/ 难度: Easy 思路 greedy solution, the current jump is [i, cur_end], and the cur_farthest is the farthest point that all of point in [i, cur_end] can reach, whenever cur_farthest is larger than the last point' index, return current jump+1; whenever i reaches cur_end, update cur_end to current cur_farthest. Time: O(log(n)) Space: O(1) class Solution(object): def jump(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" # Note You can assume that you can always reach the last index. cur_end, cur_farthest, step, n = 0, 0, 0, len(nums) for i in range(n-1): cur_farthest = max(cur_farthest, i + nums[i]) if cur_farthest >= n - 1: step += 1 break if i == cur_end: cur_end = cur_farthest step += 1 return step 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"046._permutations.html":{"url":"046._permutations.html","title":"046 permutations","keywords":"","body":"46. Permutations 题目: https://leetcode.com/problems/permutations/ 难度: Medium 每次取一个作为prefix, 剩下的继续做permutation，然后连接起来加入res中 class Solution(object): def permute(self, nums): \"\"\" :type nums: List[int] :rtype: List[List[int]] \"\"\" if len(nums) == 0: return [] if len(nums) == 1: return [nums] res = [] for i in range(len(nums)): prefix = nums[i] rest = nums[:i] + nums[i+1:] for j in self.permute(rest): res.append([prefix]+j) return res 还有介绍的基本无memory使用的算法： class Solution: def permute(self, num): \"\"\" :type nums: List[int] :rtype: List[List[int]] \"\"\" if len(num) == 0: yield [] if len(num) == 1: yield [num] res = [] for i in range(len(num)): x = num[i] xs = num[:i] + num[i+1:] for j in self.permute(xs): res.append([x] + j) yield res 但是这个yield只是生产generator，要看结果还是要用for in 来查看res的。 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"047._permutations_ii.html":{"url":"047._permutations_ii.html","title":"047 permutations ii","keywords":"","body":"47. Permutations II 题目: https://leetcode.com/problems/permutations-ii/ 难度: Medium 跟第46题一样，就是最后append的时候不一样，只有没有结果里面没有的才加入 class Solution(object): def permuteUnique(self, nums): \"\"\" :type nums: List[int] :rtype: List[List[int]] \"\"\" if len(nums) == 0: return [] if len(nums) == 1: return [nums] res = [] for i in range(len(nums)): prefix = nums[i] rest = nums[:i] + nums[i+1:] for j in self.permuteUnique(rest): if [prefix]+j not in res: res.append([prefix]+j) return res 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"048._rotate_image.html":{"url":"048._rotate_image.html","title":"048 rotate image","keywords":"","body":"48. Rotate Image 题目: https://leetcode.com/problems/rotate-image/ 难度: Medium 思路一： 先将矩阵上下翻转，然后将矩阵中心对称翻转，即可实现顺时针90度旋转。 上下翻转规律 [i][:] --> [n-1-i][:] 对角线变换的规律是 [i][j] --> [j][i] 例如： 1 1 1 3 3 3 3 2 1 2 2 2 -> 2 2 2 -> 3 2 1 3 3 3 1 1 1 3 2 1 class Solution(object): def rotate(self, matrix): \"\"\" :type matrix: List[List[int]] :rtype: void Do not return anything, modify matrix in-place instead. \"\"\" n = len(matrix) # 上下翻转 for i in range(n/2): matrix[i], matrix[n-1-i] = matrix[n-1-i], matrix[i] # 主对角线翻转 for i in range(n): for j in range(i+1,n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] 思路二： 参考这里 http://www.lifeincode.net/programming/leetcode-rotate-image-java/ 找规律，一次完成四个数的该有的变换 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 在思路一的解法下观察得出，每个元素的变换是 [x][y] -> [n-1-x][y] -> [y][n-1-x] -> [n-1-y][x] class Solution(object): def rotate(self, matrix): \"\"\" :type matrix: List[List[int]] :rtype: void Do not return anything, modify matrix in-place instead. \"\"\" n = len(matrix) for i in range(n/2): for j in range(n-n/2): matrix[i][j], matrix[~j][i], matrix[~i][~j], matrix[j][~i] = \\ matrix[~j][i], matrix[~i][~j], matrix[j][~i], matrix[i][j] 这里的[~i] 意思就是 [n-1-i] 思路三： 直接用zip函数，一行, 😂 class Solution: def rotate(self, A): A[:] = zip(*A[::-1]) # A[:] = map(list, zip(*A[::-1])) 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"049._group_anagrams_python.html":{"url":"049._group_anagrams_python.html","title":"049 group anagrams python","keywords":"","body":"49. Group Anagrams python 题目： https://leetcode.com/problems/anagrams/ 难度 : Medium python大法好 class Solution(object): def groupAnagrams(self, strs): \"\"\" :type strs: List[str] :rtype: List[List[str]] \"\"\" mapx = {} for i in strs: x = ''.join(sorted(list(i))) if x in mapx: mapx[x].append(i) else: mapx[x] = [i] return mapx.values() 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"051._n-queens.html":{"url":"051._n-queens.html","title":"051 n-queens","keywords":"","body":"51. N-Queens 题目: https://leetcode.com/problems/n-queens/ 难度: Hard 八皇后问题是一个以国际象棋为背景的问题：如何能够在8×8的国际象棋棋盘上放置八个皇后，使得任何一个皇后都无法直接吃掉其他的皇后？为了达到此目的，任两个皇后都不能处于同一条横行、纵行或斜线上。八皇后问题可以推广为更一般的n皇后摆放问题：这时棋盘的大小变为n×n，而皇后个数也变成n。当且仅当n = 1或n ≥ 4时问题有解[1]。 对于任意(x,y),如果要让新的点和它不能处于同一条横行、纵行或斜线上，则新点(p,q)必须要满足p+q != x+y 和p-q!= x-y, 前者针对左下右上斜线，后者针对左上右下斜线，两者同时都保证了不在同一条横行和纵行上。 代码中变量的含义: col_per_row: 每一行皇后的column位置组成的列表 cur_row：目前正在判断的row的index xy_diff：所有x-y组成的列表 xy_sum：所有x+y组成的列表 class Solution(object): def solveNQueens(self, n): \"\"\" :type n: int :rtype: List[List[str]] \"\"\" def dfs(col_per_row, xy_diff, xy_sum): cur_row = len(col_per_row) if cur_row == n: ress.append(col_per_row) for col in range(n): if col not in col_per_row and cur_row-col not in xy_diff and cur_row+col not in xy_sum: dfs(col_per_row+[col], xy_diff+[cur_row-col], xy_sum+[cur_row+col]) ress = [] dfs([], [], []) return [['.'*i + 'Q' + '.'*(n-i-1) for i in res] for res in ress] 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"052._n-queens_ii.html":{"url":"052._n-queens_ii.html","title":"052 n-queens ii","keywords":"","body":"52. N-Queens II 题目: https://leetcode.com/problems/n-queens-ii/ 难度: Hard 思路参见recursion & backtracking n queens还是属于比较难的，需要花时间吃透的问题 八皇后问题是一个以国际象棋为背景的问题：如何能够在8×8的国际象棋棋盘上放置八个皇后，使得任何一个皇后都无法直接吃掉其他的皇后？为了达到此目的，任两个皇后都不能处于同一条横行、纵行或斜线上。八皇后问题可以推广为更一般的n皇后摆放问题：这时棋盘的大小变为n×n，而皇后个数也变成n。当且仅当n = 1或n ≥ 4时问题有解[1]。 对于任意(x,y),如果要让新的点和它不能处于同一条横行、纵行或斜线上，则新点(p,q)必须要满足p+q != x+y 和p-q!= x-y, 前者针对左下右上斜线，后者针对左上右下斜线，两者同时都保证了不在同一条横行和纵行上。 代码中变量的含义: col_per_row: 每一行皇后的column位置组成的列表 cur_row：目前正在判断的row的index xy_diff：所有x-y组成的列表 xy_sum：所有x+y组成的列表 class Solution(object): def totalNQueens(self, n): \"\"\" :type n: int :rtype: int \"\"\" def dfs(col_per_row, xy_diff, xy_sum): cur_row = len(col_per_row) if cur_row == n: ress.append(col_per_row) for col in range(n): if col not in col_per_row and cur_row-col not in xy_diff and cur_row+col not in xy_sum: dfs(col_per_row+[col], xy_diff+[cur_row-col], xy_sum+[cur_row+col]) ress = [] dfs([], [], []) return len(ress) 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"053._maximum_subarray.html":{"url":"053._maximum_subarray.html","title":"053 maximum subarray","keywords":"","body":"53. Maximum Subarray 最大子序和 难度: Medium 刷题内容 原题连接 https://leetcode.com/problems/maximum-subarray https://leetcode-cn.com/problems/maximum-subarray/description 内容描述 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 输入: [-2,1,-3,4,-1,2,1,-5,4], 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 进阶: 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。 解题方案 思路 1 O(N^2) 从i开始，计算i到n，存比较大的sum，会超时 class Solution(object): def maxSubArray(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" n = len(nums) m = float('-inf') for i in range(n): s = 0 for j in range(i,n): s = s + nums[j] m = max(m,s) return m 思路 2 动态规划（只关注：当然值 和 当前值+过去的状态，是变好还是变坏，一定是回看容易理解） ms(i) = max(ms[i-1]+ a[i],a[i]) 到i处的最大值两个可能，一个是加上a[i], 另一个从a[i]起头，重新开始。可以AC class Solution(object): def maxSubArray(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" n = len(nums) maxSum = [nums[0] for i in range(n)] for i in range(1,n): maxSum[i] = max(maxSum[i-1] + nums[i], nums[i]) return max(maxSum) 思路 3 Kadane’s Algorithm wikipedia可以查到,然后一般的是负的可以还回0，这里需要稍作修改，参考 http://algorithms.tutorialhorizon.com/kadanes-algorithm-maximum-subarray-problem/ start: max_so_far = a[0] max_ending_here = a[0] loop i= 1 to n (i) max_end_here = Max(arrA[i], max_end_here+a[i]); (ii) max_so_far = Max(max_so_far,max_end_here); return max_so_far AC代码： class Solution(object): def maxSubArray(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" n = len(nums) maxSum , maxEnd = nums[0], nums[0] for i in range(1,n): maxEnd = max(nums[i],maxEnd + nums[i]) maxSum = max(maxEnd,maxSum) return maxSum 思路 4 参见clrs 第71页，用divide and conquer，有伪码 最大的subarray sum有三个可能，左半段或者右半段，或者跨越左右半段, 速度比较慢，AC代码，复杂度O(NlogN) class Solution(object): def maxSubArray(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" def find_max_crossing_subarray(nums, low, mid, high): left_sum = float('-inf') sum = 0 for i in xrange(mid,low-1,-1): sum = sum + nums[i] if sum > left_sum: left_sum = sum right_sum = float('-inf') sum = 0 for j in range(mid+1,high+1): sum = sum + nums[j] if sum > right_sum: right_sum = sum return left_sum + right_sum def find_max_subarray(nums,low,high): if low == high: return nums[low] else: mid = (low + high) / 2 left_sum = find_max_subarray(nums, low, mid) right_sum = find_max_subarray(nums,mid+1,high) cross_sum = find_max_crossing_subarray(nums,low,mid,high) # print left_sum, right_sum, cross_sum # print mid, low, high return max(left_sum, right_sum, cross_sum) return find_max_subarray(nums, 0, len(nums)-1) 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"054._spiral_matrix.html":{"url":"054._spiral_matrix.html","title":"054 spiral matrix","keywords":"","body":"54. Spiral Matrix 题目: https://leetcode.com/problems/spiral-matrix/ 难度: Medium 参考别人的代码，一开始觉得很有递归性，根据奇偶不同来写，递归太难写。 然后想到了loop，再想，可能有更优trick，事实证明并没有。 用四个变量来控制边界，然后因为方向总是：→↓←↑ 左右下上 class Solution(object): def spiralOrder(self, matrix): \"\"\" :type matrix: List[List[int]] :rtype: List[int] \"\"\" if matrix == [] : return [] res = [] maxUp = maxLeft = 0 maxDown = len(matrix) - 1 maxRight = len(matrix[0]) - 1 direction = 0 # 0 go right, 1 go down, 2 go left, 3 up while True: if direction == 0: #go right for i in range(maxLeft, maxRight+1): res.append(matrix[maxUp][i]) maxUp += 1 elif direction == 1: # go down for i in range(maxUp, maxDown+1): res.append(matrix[i][maxRight]) maxRight -= 1 elif direction == 2: # go left for i in reversed(range(maxLeft, maxRight+1)): res.append(matrix[maxDown][i]) maxDown -= 1 else: #go up for i in reversed(range(maxUp, maxDown+1)): res.append(matrix[i][maxLeft]) maxLeft +=1 if maxUp > maxDown or maxLeft > maxRight: return res direction = (direction + 1 ) % 4 以上的写法非常精妙，看看我自己用同样的思路写的|||| class Solution(object): def spiralOrder(self, matrix): \"\"\" :type matrix: List[List[int]] :rtype: List[int] \"\"\" if len(matrix) == 0 : return [] left = 0 up = 0 down = len(matrix) - 1 right = len(matrix[0]) -1 # 0 -> right, 1 -> down, 2-> left, 3 -> up direction = 0 # start location x, y = 0,0 res = [] while True: if left > right or up > down: return res if direction == 0 : while y = left: res.append(matrix[down][y]) y -= 1 down -= 1 x = down direction = 3 continue if direction == 3: while x >= up: res.append(matrix[x][left]) x -= 1 left += 1 y = left direction = 0 continue 明显别人的代码写的更精妙，因为这里两个boundary都很明确，所以用for in range就能很好的解决问题了. 最后放一个无敌一行，怕你看完不想看上面的代码了 class Solution(object): def spiralOrder(self, matrix): \"\"\" :type matrix: List[List[int]] :rtype: List[int] \"\"\" return matrix and list(matrix.pop(0)) + self.spiralOrder(zip(*matrix)[::-1]) oh, my god! 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"055._jump_game.html":{"url":"055._jump_game.html","title":"055 jump game","keywords":"","body":"55. Jump Game 题目: https://leetcode.com/problems/jump-game/ 难度: Medium 问题出现在一旦有0，而且这个0是不可跨过的那么无解，无法达到 看了hint，根本不用这个数组，直接用一个数来记录可达最远距离，非常巧妙 class Solution(object): def canJump(self, nums): \"\"\" :type nums: List[int] :rtype: bool \"\"\" if not nums: return True if len(nums) == 1: return True n = len(nums) idx, reach = 0, 0 while idx reach说明已经失败了 reach = max(reach, idx+nums[idx]) idx += 1 return reach >= n-1 idx记录当前loop位置，reach记录当前可到位置 注意这里的while循环的条件是 idx ，之所以加上 idx 是因为如果idx > reach说明idx层不可达，其实也可以直接terminate. 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"056._Merge_Intervals.html":{"url":"056._Merge_Intervals.html","title":"056 Merge Intervals","keywords":"","body":"56. Merge Intervals 题目: https://leetcode.com/problems/merge-intervals/ 难度: Medium Just go through the intervals sorted by start coordinate and either combine the current interval with the previous one if they overlap, or add it to the output by itself if they don’t. class Solution(object): def merge(self, intervals): \"\"\" :type intervals: List[Interval] :rtype: List[Interval] \"\"\" res = [] for i in sorted(intervals, key = lambda i: i.start): if res and i.start 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"058._length_of_last_word.html":{"url":"058._length_of_last_word.html","title":"058 length of last word","keywords":"","body":"58. Length of Last Word 题目： https://leetcode.com/problems/length-of-last-word/ 难度 : Easy 我的解法： class Solution(object): def lengthOfLastWord(self, s): \"\"\" :type s: str :rtype: int \"\"\" s = s[::-1].strip() return s.find(' ') if s.find(' ') != -1 else len(s) 作弊式做法 class Solution(object): def lengthOfLastWord(self, s): \"\"\" :type s: str :rtype: int \"\"\" lst = s.split() if len(lst) >= 1: return len(lst[-1]) return 0 split()方法最低可以分0组，split(' ')最低可以分1组 一行解法： class Solution(object): def lengthOfLastWord(self, s): \"\"\" :type s: str :rtype: int \"\"\" return len(s.strip().split(\" \")[-1]) 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"059._spiral_matrix_ii.html":{"url":"059._spiral_matrix_ii.html","title":"059 spiral matrix ii","keywords":"","body":"59. Spiral Matrix II 题目: https://leetcode.com/problems/spiral-matrix-ii/ 难度: Medium 和Spiral Matrix的思路基本一致 也许还有待挖掘trick class Solution(object): def generateMatrix(self,n): \"\"\" :type n: int :rtype: List[List[int]] \"\"\" curNum = 0 matrix = [[0 for i in range(n)] for j in range(n)] maxUp = maxLeft = 0 maxDown = maxRight = n - 1 direction = 0 while True: if direction == 0: #go right for i in range(maxLeft, maxRight+1): curNum += 1 matrix[maxUp][i] = curNum maxUp += 1 elif direction == 1: # go down for i in range(maxUp, maxDown+1): curNum += 1 matrix[i][maxRight] = curNum maxRight -= 1 elif direction == 2: # go left for i in reversed(range(maxLeft, maxRight+1)): curNum += 1 matrix[maxDown][i] = curNum maxDown -= 1 else: #go up for i in reversed(range(maxUp, maxDown+1)): curNum += 1 matrix[i][maxLeft] = curNum maxLeft +=1 if curNum >= n*n: return matrix direction = (direction + 1 ) % 4 Same idea with spiral matrix I class Solution(object): def generateMatrix(self, n): \"\"\" :type n: int :rtype: List[List[int]] \"\"\" res = [] l = n * n + 1 while l > 1: l, r = l - len(res), l res = [range(l, r)] + zip(*res[::-1]) return res 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"060._permutation_sequence.html":{"url":"060._permutation_sequence.html","title":"060 permutation sequence","keywords":"","body":"60. Permutation Sequence 题目: https://leetcode.com/problems/permutation-sequence/ 难度: Medium 偷懒，用46的方法，会超时 class Solution(object): def getPermutation(self, n, k): \"\"\" :type n: int :type k: int :rtype: str \"\"\" self.result = [] s = \"\" for i in range(1, n+1): s += str(i) self.recPermute(\"\",s,k) return self.result[-1] def recPermute(self, sofar, rest, k): if rest == \"\": if len(self.result) == k: return self.result.append(sofar) else: for i in xrange(len(rest)): nnext = sofar + rest[i] remaining = rest[:i] + rest[i+1:] self.recPermute(nnext, remaining, k) 然后其实有规律的，比如 1 \"123\" 2 \"132\" 3 \"213\" 4 \"231\" 5 \"312\" 6 \"321\" 是第n个数 + 余下的n-1个数的permutation k = 1 就是所有的顺序排列 k = n! 是所有的逆序排列 对于余下的也是递归，比如 k 发现思路对了，但是implement还有点困难. 看了一个最为精妙的解法 class Solution(object): def getPermutation(self, n, k): \"\"\" :type n: int :type k: int :rtype: str \"\"\" seq, k, fact = '', k-1, math.factorial(n-1) perm = [i for i in range(1, n+1)] for i in reversed(xrange(n)): curr = perm[k/fact] seq += str(curr) perm.remove(curr) if i > 0: k %= fact fact /= i return seq 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"061._rotate_list.html":{"url":"061._rotate_list.html","title":"061 rotate list","keywords":"","body":"61. Rotate List 题目: https://leetcode.com/problems/rotate-list/ 难度: Medium k可能比list的size大，需要做一个取余准备 计算list size的同时把tail也记录下来，方便之后把tail的next指向原本的head 利用之前的到末端的kth node AC 代码 class Solution(object): def rotateRight(self, head, k): if head == None or k == 0 : return head cur = head size = 1 while cur.next: size += 1 cur = cur.next tail = cur k = k % size p = self.findKth(head,k) tail.next = head head = p.next p.next = None return head def findKth(self,head, k): dummy = ListNode(-1) dummy.next = head p = dummy q = dummy for i in range(k): q = q.next while q.next: p = p.next q = q.next return p 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"062._unique_paths.html":{"url":"062._unique_paths.html","title":"062 unique paths","keywords":"","body":"62. unique paths 不同路径 难度: 中等 刷题内容 原题连接 https://leetcode.com/problems/unique-paths https://leetcode-cn.com/problems/unique-paths/description 内容描述 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 问总共有多少条不同的路径？ 例如，上图是一个7 x 3 的网格。有多少可能的路径？ 说明：m 和 n 的值均不超过 100。 > 示例 1: 输入: m = 3, n = 2 输出: 3 解释: 从左上角开始，总共有 3 条路径可以到达右下角。 1. 向右 -> 向右 -> 向下 2. 向右 -> 向下 -> 向右 3. 向下 -> 向右 -> 向右 > 示例 2: 输入: m = 7, n = 3 输出: 28 解题方案 思路 1 1 1 1 1 2 3 1 3 6 1 4 10 1 5 15 1 6 21 1 7 28 class Solution: def uniquePaths(self, m, n): \"\"\" :type m: int :type n: int :rtype: int \"\"\" if m 思路 2 这道题我一看到就觉得这不就是排列组合吗，一共走m+n-2步, 其中m-1步是向右边走，所以不就是从m+n-2中选m-1个的问题吗，阶乘问题，so easy! 妈妈 再也不用担心我的学习！！这个方法beats 99.97% class Solution(object): def uniquePaths(self, m, n): \"\"\" :type m: int :type n: int :rtype: int \"\"\" def factorial(num): res = 1 for i in range(1, num+1): res *= i return res return factorial(m+n-2)/factorial(n-1)/factorial(m-1) 另外补充一句，我发现math模块里面自带factorial函数，只要import math之后调用即可， 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"064._minimum_path_sum.html":{"url":"064._minimum_path_sum.html","title":"064 minimum path sum","keywords":"","body":"64. Minimum Path Sum 最小路径和 难度: Medium 刷题内容 原题连接 https://leetcode.com/problems/minimum-path-sum https://leetcode-cn.com/problems/minimum-path-sum/description 内容描述 给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 说明：每次只能向下或者向右移动一步。 示例: 输入: [ [1,3,1], [1,5,1], [4,2,1] ] 输出: 7 解释: 因为路径 1→3→1→1→1 的总和最小。 解题方案 思路 1 经典的动态规划问题，和：72. 编辑距离 类似 class Solution(object): def minPathSum(self, grid): \"\"\" :type grid: List[List[int]] :rtype: int \"\"\" if not grid or len(grid) == 0: return 0 row = len(grid) col = len(grid[0]) if row else 0 dp = [[0 for j in range(col)] for i in range(row)] for i in range(row): for j in range(col): if i > 0 and j > 0: dp[i][j] = min(dp[i-1][j]+grid[i][j], dp[i][j-1]+grid[i][j]) elif i > 0 and j == 0: dp[i][j] = sum([grid[k][0] for k in range(i+1)]) elif i == 0 and j > 0: dp[i][j] = sum([grid[0][k] for k in range(j+1)]) else: dp[i][j] = grid[0][0] return dp[-1][-1] 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"065.unique_paths_ii.html":{"url":"065.unique_paths_ii.html","title":"065 unique paths ii","keywords":"","body":"65.Unique Paths II 题目： https://leetcode.com/problems/unique-paths-ii/ tag : DP 难度 : Medium BASE CASE（ i = 0 , j = 0）: //第一排和第一列，如果没有obstacle， 则走法为1， 一旦有了obstacle，则之后的格子走法都为0 非BASE CASE ： //一旦有obstacle，则dp为0 dp(i, j) = dp（i,j-1) + dp(i-1,j) Python代码 class Solution(object): def uniquePathsWithObstacles(self, obstacleGrid): \"\"\" :type obstacleGrid: List[List[int]] :rtype: int \"\"\" row = len(obstacleGrid) col = len(obstacleGrid[0]) dp = [[0 for i in range(col)] for j in range(row)] dp[0][0] = int(obstacleGrid[0][0] == 0) #first row for j in range(1,col): if obstacleGrid[0][j] == 1: dp[0][j] = 0 else: dp[0][j] = dp[0][j-1] #first col for i in range(1,row): if obstacleGrid[i][0] == 1: dp[i][0] = 0 else: dp[i][0] = dp[i-1][0] for i in range(1,row): for j in range(1,col): if obstacleGrid[i][j] == 1: dp[i][j] = 0 else: dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[row-1][col-1] 犯了一个错，简直觉得不可思议。一开始初始化dp用的代码是 dp = [[0] * col] * row 问题在此： >>> x = [[]] * 3 >>> x[1].append(0) >>> x [[0], [0], [0]] 这样初始化是做了三个一样的object. The problem is that they're all the same exact list in memory. When you use the [x]*n syntax, what you get is a list of n many x objects, but they're all references to the same object. They're not distinct instances, rather, just n references to the same instance. 参见stackoverflow : http://stackoverflow.com/questions/12791501/python-initializing-a-list-of-lists 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"066._plus_one.html":{"url":"066._plus_one.html","title":"066 plus one","keywords":"","body":"66. Plus One 题目： https://leetcode.com/problems/plus-one/ 难度 : Easy 这里是用的递归，很容易理解，如果空列表直接加1，最后一位小于9，那么直接就最后一位加1，否则添加一个0，然后再把余下的递归加1 class Solution(object): def plusOne(self, digits): \"\"\" :type digits: List[int] :rtype: List[int] \"\"\" if digits == []: return [1] if digits[-1] 其实可以考虑循环，效率更高，参考此处 从低位到高位，如果后一位有进位的话，那么该位要加上一，否则退出循环。如果最高位也进位，那么在列表前要插入一个一。 class Solution(object): def plusOne(self, digits): \"\"\" :type digits: List[int] :rtype: List[int] \"\"\" carry = 1 for i in range(len(digits)-1,-1,-1): digits[i] += carry if digits[i] 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"067._add_binary.html":{"url":"067._add_binary.html","title":"067 add binary","keywords":"","body":"67. Add Binary 题目： https://leetcode.com/problems/add-binary/ 难度 : Easy 几种case： a or b 为空，最简单 唯一的问题是如果有进位的处理，进位的处理就是先让其中的一个数和‘1’做addBinary处理 ，然后再用addBinary class Solution(object): def addBinary(self, a, b): \"\"\" :type a: str :type b: str :rtype: str \"\"\" if (a == '' or b == ''): return a + b elif a[-1] == '0' and b[-1] == '0': return self.addBinary(a[:-1], b[:-1]) + '0' elif a[-1] == '1' and b[-1] == '1': return self.addBinary(a[:-1], self.addBinary(b[:-1],'1')) + '0' else: return self.addBinary(a[:-1], b[:-1]) + '1' 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"070. Climbing Stairs.html":{"url":"070. Climbing Stairs.html","title":"070 Climbing Stairs","keywords":"","body":"70. Climbing Stairs 题目: https://leetcode.com/problems/climbing-stairs/ 难度: Easy 思路： Fibonacci 的DP版本 对于DP的不同理解造成不同的写法Memoization will usually add on your time-complexity to your space-complexity (e.g. with tabulation you have more liberty to throw away calculations, like using tabulation with Fib lets you use O(1) space, but memoization with Fib uses O(N) stack space). 详看 Dynamic programming and memoization: bottom-up vs top-down approaches Tabulation vs Memoizatation top-down(memorize) def memorize_fib(n): # n为第几个Fibonacci数 memo = {1:1, 2:1} if n in memo: return memo[n] else: memo[n] = memorize_fib(n-1) + memorize_fib(n-2) return memo[n] print(memorize_fib(4)) 输出3 bottom up(tabulation) def tabulation_fib(n): # n为第几个Fibonacci数 fib = [1, 1, 2] if n 输出3 这里memo用dict，用array也一样。当然用bottom up还有一点，可以只存每次最后两个数，可以save space.，这样就只用到constant space. AC 代码(这里采用bottom up思想) class Solution(object): def climbStairs(self, n): \"\"\" :type n: int :rtype: int \"\"\" fib = [1, 2, 3] if n Complexity Analysis - Time complexity : O(n) - Space complexity : O(1). Constant space is used. 另外还有一个公式法： 由于这里面相当于standard Fibonacci函数向前进了一步，排列为1，2，3，5而非原本的1，1，2，3，所以代码中使用n+1 class Solution(object): def climbStairs(self, n): \"\"\" :type n: int :rtype: int \"\"\" import math sqrt5 = math.sqrt(5) fibn = pow((1 + sqrt5) / 2, n+1) - pow((1 - sqrt5) / 2, n+1) return int(float(fibn/sqrt5)) Complexity Analysis - Time complexity : O(lg(n)). pow method takes log(n) time. - Space complexity : O(1). Constant space is used. 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"072._edit_distance.html":{"url":"072._edit_distance.html","title":"072 edit distance","keywords":"","body":"72. Edit Distance 题目: https://leetcode.com/problems/edit-distance/ 难度: Hard 可以做的操作： insert delete replace 动归典型，原来也是有wikipedia page的算法 https://en.wikipedia.org/wiki/Edit_distance#Common_algorithm https://en.wikipedia.org/wiki/Levenshtein_distance 看wikipedia 这解释 / max(i,j) if min(i,j) = 0 / dp[i-1][j] + 1 word1[i]不在word2[0...j]中,所以删除 dp[i][j] - min -- dp[i][j-1] + 1 insertion \\ dp[i-1][j-1] + 1/0 word[i]与word[j]是否相等 上面的就不用解释了，min分别对应：删除、插入、以及替代（1/0取决 word1[i] == word2[j] ），反正也是tabular类型，画表来解决问题。 简单说，就是这样： 1.delete：dp[i-1][j] + 1 —— 保留了从 word1[0:i-1] 转变到 word2[0:j] 的最优操作次数，因为我们的 word1 的 0~i-1 已经能够转变到 word2 了， 所以我们就直接把 word1 中的最后一个字符删除掉就行了。所以就需要额外进行一个 删除 操作。 2.insert：dp[i][j-1] + 1 —— 保留了从 word1[0:i] 转变到 word2[0:j-1] 的最优操作次数，因为我们的 word1 的 0~i 只能转变到 word2 的倒数第二位，所以我们就直接在 word1 的末尾添加一个与 word2 的最后一个字符相同的字符就可以了。所以就需要额外进行一个 插入 操作。 3.replace：dp[i-1][j-1] + 1 —— 保留了从 word1[0:i-1] 转变到 word2[0:j-1] 的最优操作次数，因为我们的 word1 的 0~i-1 只能转变到 word2 的倒数第二位，而 word1 的最后一位与 word2 的最后一位是不同的，所以现在的情况只需要额外的一个 替换 操作即可。 无论我们选取上面 3 中操作的哪种操作，我们选其中最小的值就可以了。 参考链接：http://www.cnblogs.com/pandora/archive/2009/12/20/levenshtein_distance.html 要始终明确一点，dp[i][j]的含义是使得word1的前i字符子串与word2的前j字符子串相等所需要的操作数，这也是为什么我们需要在初始化dp矩阵时需要行列数均加上1 用wikipedia上的伪码改造 function LevenshteinDistance(char s[1..m], char t[1..n]): // for all i and j, d[i,j] will hold the Levenshtein distance between // the first i characters of s and the first j characters of t // note that d has (m+1)*(n+1) values declare int d[0..m, 0..n] set each element in d to zero // source prefixes can be transformed into empty string by // dropping all characters for i from 1 to m: d[i, 0] := i // target prefixes can be reached from empty source prefix // by inserting every character for j from 1 to n: d[0, j] := j for j from 1 to n: for i from 1 to m: if s[i] = t[j]: substitutionCost := 0 else: substitutionCost := 1 d[i, j] := minimum(d[i-1, j] + 1, // deletion d[i, j-1] + 1, // insertion d[i-1, j-1] + substitutionCost) // substitution return d[m, n] 对应的例子表格图 k i t t e n 0 1 2 3 4 5 6 s 1 1 2 3 4 5 6 i 2 2 1 2 3 4 5 t 3 3 2 1 2 3 4 t 4 4 3 2 1 2 3 i 5 5 4 3 2 2 3 n 6 6 5 4 3 3 2 g 7 7 6 5 4 4 3 AC代码 class Solution(object): def minDistance(self, word1, word2): \"\"\" :type word1: str :type word2: str :rtype: int \"\"\" if len(word1) == 0 or len(word2) == 0: # corner cases return max(len(word1), len(word2)) dp = [[i+j for j in range(len(word2)+1)] for i in range(len(word1)+1)] for i in range(1, len(word1)+1): for j in range(1, len(word2)+1): tmp_dist = 0 if word1[i-1] == word2[j-1] else 1 dp[i][j] = min(dp[i-1][j]+1, dp[i][j-1]+1, dp[i-1][j-1]+tmp_dist) return dp[-1][-1] 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"073._Set_Matrix_Zeroes.html":{"url":"073._Set_Matrix_Zeroes.html","title":"073 Set Matrix Zeroes","keywords":"","body":"73. Set Matrix Zeroes 题目： https://leetcode.com/problems/set-matrix-zeroes/ 难度 : Medium 思路： Naive AC代码，一看类似那个 game of life，不用extra space，不用O(mn)，应该就是用状态转移机了（？），所以还是先naive AC把： class Solution(object): def setZeroes(self, matrix): \"\"\" :type matrix: List[List[int]] :rtype: void Do not return anything, modify matrix in-place instead. \"\"\" def setZero(i,j): for m in range(col): matrix[i][m] = 0 for n in range(row): matrix[n][j] = 0 row = len(matrix) col = len(matrix[0]) if row else 0 new_matrix = [matrix[i][:] for i in range(row)] for i in range(row): for j in range(col): if new_matrix[i][j] == 0: setZero(i,j) 正确思路： 一边遍历，一边将相应的行和列置为0是行不通的，会影响后面元素的遍历判断，所以要记录下哪些行和哪些列是要置为0的。为了节约空间，在原矩阵中借两条边，如果该行或者列要置为0，则把左边或者上边的相应位置置为0。如果左边和上边本来就有0，那么需要额外标记一下，最后把左边或者右边也全部置为0. 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"074._search_a_2d_matrix.html":{"url":"074._search_a_2d_matrix.html","title":"074 search a 2d matrix","keywords":"","body":"74. Search a 2D Matrix 题目: https://leetcode.com/problems/search-a-2d-matrix/ 难度: Medium 思路： 想过将2D matrix看成一个大sorted list，代码如下： class Solution(object): def searchMatrix(self, matrix, target): \"\"\" :type matrix: List[List[int]] :type target: int :rtype: bool \"\"\" row = len(matrix) col = len(matrix[0]) if row else 0 l, r = 0, row * col - 1 while l > 2) if target > matrix[mid/col][mid%col]: l = mid + 1 elif target 但是后面觉得不行, 原因如下： m * n may overflow for large m and n; it will use multiple expensive operations such as / and % 因此二分Search，binary search by row first, then binary search by column. class Solution(object): def searchMatrix(self, matrix, target): \"\"\" :type matrix: List[List[int]] :type target: int :rtype: bool \"\"\" if not matrix or not matrix[0]: return False row = len(matrix) col = len(matrix[0]) if row else 0 l, r = 0, row - 1 while l > 2) if matrix[mid_row][0] > 2) if matrix[mid_row][mid_col] > target: n = mid_col - 1 elif matrix[mid_row][mid_col] 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"075._sort_colors.html":{"url":"075._sort_colors.html","title":"075 sort colors","keywords":"","body":"75. Sort Colors 难度: 中等 刷题内容 原题连接 https://leetcode.com/problems/sort-colors/description/ 内容描述 Given an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue. Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively. Note: You are not suppose to use the library's sort function for this problem. Example: Input: [2,0,2,1,1,0] Output: [0,0,1,1,2,2] Follow up: A rather straight forward solution is a two-pass algorithm using counting sort. First, iterate the array counting number of 0's, 1's, and 2's, then overwrite array with total number of 0's, then 1's and followed by 2's. Could you come up with a one-pass algorithm using only constant space? 解题方案 思路 1 先算一下0, 1, 2分别有多少个，然后in-place改呗，简单, beats 100% class Solution(object): def sortColors(self, nums): \"\"\" :type nums: List[int] :rtype: void Do not return anything, modify nums in-place instead. \"\"\" red, white, blue = 0, 0, 0 for i in nums: if i == 0: red += 1 elif i == 1: white += 1 for i in range(red): nums[i] = 0 for i in range(red, red+white): nums[i] = 1 for i in range(red+white, len(nums)): nums[i] = 2 思路 2 这个问题是 Dutch National Flag Problem， 荷兰旗问题 https://en.wikipedia.org/wiki/Dutch_national_flag_problem 思路其实是类似partition的，比x小的放左边，比x大的放右边。 这里是用三个指针，begin, cur, end，cur需要遍历整个数组 cur 指向0，交换begin与cur， begin++,cur++ cur 指向1，不做任何交换，cur++ cur 指向2，交换end与cur，end-- 之所以cur指向2，交换之后不前进是因为我们end交换过来的是0或者1，如果是0那么明显我们需要做进一步的处理，所以最终判断条件是end 这样的three-way-partition也只是3-way好用吧？如果有4个数，那么这样则是无效的，或者如果是4-way，那么可以转换成3-way+2-way class Solution(object): def sortColors(self, nums): \"\"\" :type nums: List[int] :rtype: void Do not return anything, modify nums in-place instead. \"\"\" begin, cur, end = 0, 0, len(nums) - 1 while cur 思路 3 两个指针也可以 class Solution(object): def sortColors(self, nums): \"\"\" :type nums: List[int] :rtype: void Do not return anything, modify nums in-place instead. \"\"\" i, l, r = 0, 0, len(nums) - 1 while i l: nums[i], nums[l] = nums[l], 0 l += 1 else: i += 1 思路 4 这个方法就很巧妙了，我们遍历整个数组，只要碰到了什么数字我们就把这个数字往右边推一下 大家可以用例子[2,0,2,1,1,0]自己推导一下过程，看看是不是有一种向右推的感觉 class Solution(object): def sortColors(self, nums): \"\"\" :type nums: List[int] :rtype: void Do not return anything, modify nums in-place instead. \"\"\" n0, n1, n2 = -1, -1, -1 for i in range(len(nums)): if nums[i] == 0: n0, n1, n2 = n0+1, n1+1, n2+1 nums[n2] = 2 nums[n1] = 1 nums[n0] = 0 elif nums[i] == 1: n1, n2 = n1+1, n2+1 nums[n2] = 2 nums[n1] = 1 else: n2 += 1 nums[n2] = 2 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"076._Minimum_Window_Substring.html":{"url":"076._Minimum_Window_Substring.html","title":"076 Minimum Window Substring","keywords":"","body":"76. Minimum Window Substring 题目： https://leetcode.com/problems/minimum-window-substring/ 难度 : Hard 模板大法 class Solution(object): def minWindow(self, s, t): \"\"\" :type s: str :type t: str :rtype: str \"\"\" if len(t) > len(s): return '' maps = collections.Counter(t) counter = len(maps.keys()) begin, end, head, length = 0, 0, 0, float('inf') while end 0: counter += 1 if end - begin 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"077._combinations.html":{"url":"077._combinations.html","title":"077 combinations","keywords":"","body":"77. Combinations 题目： https://leetcode.com/problems/combinations/ 难度 : Medium 思路一： python作弊法 import itertools p = [4, 8, 15, 16, 23, 42] c = itertools.combinations(p, 4) for i in c: print i 结果： (4, 8, 15, 16) (4, 8, 15, 23) (4, 8, 15, 42) (4, 8, 16, 23) (4, 8, 16, 42) (4, 8, 23, 42) (4, 15, 16, 23) (4, 15, 16, 42) (4, 15, 23, 42) (4, 16, 23, 42) (8, 15, 16, 23) (8, 15, 16, 42) (8, 15, 23, 42) (8, 16, 23, 42) (15, 16, 23, 42) 作弊AC代码: class Solution(object): def combine(self, n, k): \"\"\" :type n: int :type k: int :rtype: List[List[int]] \"\"\" import itertools return [list(i) for i in itertools.combinations(range(1,n+1), k)] 思路二： 标准的recursion 但是会超时 class Solution(object): def combine(self, n, k): \"\"\" :type n: int :type k: int :rtype: List[List[int]] \"\"\" ans = [] self.dfs(n, k, 1, [], ans) return ans def dfs(self, n, k ,start, lst, ans): if k == 0 : ans.append(lst) return for i in range(start, n+1): self.dfs(n, k - 1, i + 1,lst +[i], ans) 理解方式 1 2 3 12 13 14 23 24 34 可以参照这里 http://www.geeksforgeeks.org/print-all-possible-combinations-of-r-elements-in-a-given-array-of-size-n/ 解法三： 采用递归的方式，在n个数中选k个，如果n大于k，那么可以分类讨论，如果选了n，那么就是在1到(n-1)中选(k-1)个，否则就是在1到(n-1)中选k个。递归终止的条件是k为1，这时候1到n都符合要求。 注意一开始这里的else part花了我一点时间来理解，因为n必定大于k，所以这样递归当 n == k的时候选法就是code原作者的写法，也就是直接[range(1,k+1)] 参考这里： https://shenjie1993.gitbooks.io/leetcode-python/content/077%20Combinations.html class Solution(object): def combine(self, n, k): \"\"\" :type n: int :type k: int :rtype: List[List[int]] \"\"\" if k == 1: return [[i + 1] for i in range(n)] result = [] if n > k: result = [r + [n] for r in self.combine(n - 1, k - 1)] + self.combine(n - 1, k) else: #n == k # result = [r + [n] for r in self.combine(n - 1, k - 1)] result = [range(1,k+1)] return result 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"078._Subsets.html":{"url":"078._Subsets.html","title":"078 Subsets","keywords":"","body":"78. Subsets 难度: Medium 刷题内容 原题连接 https://leetcode.com/problems/subsets/description/ 内容描述 Given a set of distinct integers, nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets. Example: Input: nums = [1,2,3] Output: [ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], [] ] 解题方案 思路 1 每次拿一个，跟res里面的每一个已有列表取并集再次插入res中 class Solution(object): def subsets(self, nums): \"\"\" :type nums: List[int] :rtype: List[List[int]] \"\"\" res = [[]] for num in nums: res.extend([tmp+[num] for tmp in res]) return res 思路 2 BackTrack 标准解法版 对每个元素，有两种可能，加入 cur_lst 和不加入 cur_lst，写起来思路还是很清爽的 class Solution(object): def subsets(self, nums): \"\"\" :type nums: List[int] :rtype: List[List[int]] \"\"\" nums.sort() res = [] def search(cur_lst, idx): if idx == len(nums): res.append(cur_lst) return search(cur_lst + [nums[idx]], idx + 1) search(cur_lst, idx + 1) search([], 0) return res 思路 3 DFS class Solution(object): def subsets(self, nums): \"\"\" :type nums: List[int] :rtype: List[List[int]] \"\"\" nums.sort() res = [] def dfs(depth, start, lst): res.append(lst) if depth == len(nums): return for i in range(start, len(nums)): dfs(depth+1, i+1, lst+[nums[i]]) dfs(0, 0, []) return res 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"079._word_search.html":{"url":"079._word_search.html","title":"079 word search","keywords":"","body":"79. Word Search 题目: https://leetcode.com/problems/word-search/ 难度: Medium 思路： 其实这个题和number of islands类似，是backtracking基本功的考查,但是基本功非常有待提高||| 比较核心的是dfs函数，然后这个函数有取巧的写法：如果outside of boundary就return False loop， 如果碰到跟word开头的字母一样，把这个扔进去loop，可以考查这个char在这个board的上下左右是否可以选择，补课使用则重置used， 然后return 也还是之前摘录的，backtrack写法关键： 选择 (Options)，限制 (Restraints)，结束条件 (Termination)。 class Solution(object): def exist(self, board, word): \"\"\" :type board: List[List[str]] :type word: str :rtype: bool \"\"\" def dfs(board, used, row, col, x, y, word, idx): if idx == len(word) : return True if x row -1 or y col -1 : return False if board[x][y] == word[idx] and not used[x][y]: used[x][y] = 1 left = dfs(board,used,row,col,x-1,y,word,idx+1) right = dfs(board,used,row,col,x+1,y,word,idx+1) up = dfs(board,used,row,col,x,y-1,word,idx+1) down = dfs(board,used,row,col,x,y+1,word,idx+1) used[x][y] = left or right or up or down return left or right or up or down return False row = len(board) col = len(board[0]) if row else 0 used = [ [0 for i in range(col)] for j in range(row)] for i in range(row): for j in range(col): if dfs(board,used,row,col,i,j,word,0): return True return False 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"082._remove_duplicates_from_sorted_list_ii.html":{"url":"082._remove_duplicates_from_sorted_list_ii.html","title":"082 remove duplicates from sorted list ii","keywords":"","body":"82. Remove Duplicates from Sorted List II 题目: https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/ 难度: Medium 木有space 和 time的限制，第一想法，用dictionary存一下每个nodes的个数，这样只要看到它是大于1的，就删删删。 虽然是笨办法。但是也可以AC class Solution(object): def deleteDuplicates(self, head): \"\"\" :type head: ListNode :rtype: ListNode \"\"\" dummy = ListNode(-1) dummy.next = head cur = dummy.next nodeNumber = {} while cur: if cur.val in nodeNumber: nodeNumber[cur.val] += 1 else: nodeNumber[cur.val] = 1 cur = cur.next cur = dummy while cur.next: if nodeNumber[cur.next.val] > 1: cur.next = cur.next.next else: cur = cur.next return dummy.next 谷歌一下，更省时间的方法是用一个prev 和 cur 指针，然后用一个bool来记录是否duplicate，这样loop一次即可解决问题。 to be 写出来 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"083._remove_duplicates_from_sorted_list.html":{"url":"083._remove_duplicates_from_sorted_list.html","title":"083 remove duplicates from sorted list","keywords":"","body":"83. Remove Duplicates from Sorted List 题目: https://leetcode.com/problems/remove-duplicates-from-sorted-list/ 难度: Easy dummy 大法 class Solution(object): def deleteDuplicates(self, head): \"\"\" :type head: ListNode :rtype: ListNode \"\"\" dummy = head while head: while head.next and head.next.val == head.val: head.next = head.next.next # skip duplicated node head = head.next # not duplicate of current node, move to next node return dummy 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"086._partition_list.html":{"url":"086._partition_list.html","title":"086 partition list","keywords":"","body":"86. Partition List 题目： https://leetcode.com/problems/partition-list/ 难度 : Medium 思路一： 最简单的思路就是两个dummy head，然后一个指向 小于的node，一个指向大于的node 思路二： 不走寻常路了，使用两个指针，一个指向小于的尾巴，一个一直往后走，指向大于，然后交换node 完成比完美更重要啊，其实可以先试试用简单方法，因为我用我的不走寻常路画了比较久的图，写起来也稍显没那么美观，还在交换node的部分卡了一会 class Solution(object): def partition(self, head, x): \"\"\" :type head: ListNode :type x: int :rtype: ListNode \"\"\" dummy = ListNode(-1) dummy.next = head p1 = p2 = dummy while p1.next and p1.next.val = x: p2 = p2.next if p2.next == None: break node = p2.next p2.next = node.next node.next = p1.next p1.next = node p1 = p1.next return dummy.next 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"088._merge_sorted_array.html":{"url":"088._merge_sorted_array.html","title":"088 merge sorted array","keywords":"","body":"88. Merge Sorted Array 难度: Easy 刷题内容 原题连接 https://leetcode.com/problems/merge-sorted-array/description/ 内容描述 Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array. Note: The number of elements initialized in nums1 and nums2 are m and n respectively. You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. Example: Input: nums1 = [1,2,3,0,0,0], m = 3 nums2 = [2,5,6], n = 3 Output: [1,2,2,3,5,6] 解题方案 思路 1 给的数组可能是这样的 nums1 : [0] m : 0 nums2 : [1] n : 1 所以要判断m和n是不是仍然大于0, 但是m不需要了，因为我们本来就是要在nums1的基础上改，m如果还大于0的话我们不需要改nums1了，保留不变即可 AC代码 class Solution: def merge(self, nums1, m, nums2, n): \"\"\" :type nums1: List[int] :type m: int :type nums2: List[int] :type n: int :rtype: void Do not return anything, modify nums1 in-place instead. \"\"\" while m > 0 and n > 0: if nums1[m-1] > nums2[n-1]: nums1[m+n-1] = nums1[m-1] m -= 1 else: nums1[m+n-1] = nums2[n-1] n -= 1 if n > 0: nums1[:n] = nums2[:n] 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"089._gray_code.html":{"url":"089._gray_code.html","title":"089 gray code","keywords":"","body":"89. Gray Code 题目: https://leetcode.com/problems/gray-code/ 难度: Medium 思路： 首先不是从任何一个数开始都是有效的，所以naive的想法是从任何一个开始，然后如果能到2^n位，那么说明是有效的，问题解决. A gray code sequence must begin with 0. ->简化了一点 先写了一段代码： def nextCode(curCode, res, n): if curCode not in res: res.append(curCode) else: return if len(res) == pow(2,n): return res for i in range(n): nCode = curCode[:] nCode[i] = 1 if curCode[i] == 0 else 0 nextCode(nCode,res,n) res = [] nextCode([0,0,0],res,3) print res #[[0, 0, 0], [1, 0, 0], [1, 1, 0], [0, 1, 0], [0, 1, 1], [1, 1, 1], [1, 0, 1], [0, 0, 1]] 实际上问题是这段代码的时间复杂度感觉很高，但是试试 不失所望，到11就超时 class Solution(object): def grayCode(self, n): \"\"\" :type n: int :rtype: List[int] \"\"\" def nextCode(curCode, res, n): if curCode not in res: res.append(curCode) else: return if len(res) == pow(2,n): return res for i in xrange(n): nCode = curCode[:] nCode[i] = 1 if curCode[i] == 0 else 0 nextCode(nCode, res, n) def listoVal(curCode,n): val = 0 for i in range(n-1,-1,-1): val += pow(2,i) * curCode[i] return val res = [] nextCode([0]*n, res, n) # print res val = [] for i in res: val.append(listoVal(i,n)) return val 然后居然有这个东西： Gray code，要用位运算！瞑目 https://en.wikipedia.org/wiki/Gray_code 服气，这个待研究 class Solution(object): def grayCode(self, n): \"\"\" :type n: int :rtype: List[int] \"\"\" result = [(i>>1)^i for i in range(pow(2,n))] return results 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"090._subsets_ii.html":{"url":"090._subsets_ii.html","title":"090 subsets ii","keywords":"","body":"90. Subsets II 难度: Medium 刷题内容 原题连接 https://leetcode.com/problems/subsets-ii/description/ 内容描述 Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets. Example: Input: [1,2,2] Output: [ [2], [1], [1,2,2], [2,2], [1,2], [] ] 解题方案 思路 1 [[],[1]] 是 [1] 的子集合 [[],[1],[2],[1,2]] 是 [1,2] 的子集合，实际上就是1的子集合们加了一个2 新来的2不能再从头开始加了，它需要从[ .., [2],[1,2] ]加 才是合理的 ****当出现多个重复数字时，应该从 已经拥有了新数字所出现全部次数的list开始加才是合理的**** [[],[1]] 是 [1] 的子集合 [[],[1],[2],[1,2]] 是 [1,2] 的子集合，实际上就是1的子集合们加了一个2 [ [2], [1], [1,2,2], [2,2], [1,2], [] ] 是 [1,2,2] 的子集和，实际上也就是[1,2]的子集合加了一个2 新来的2不能再从头开始加了，它需要从[ .., [2,2],[1,2,2] ]加 才是合理的 例如： 自己的解法，这里最关键的就是先对nums进行了排序，保证了我们插入相同的数字时都是相邻的 class Solution(object): def subsetsWithDup(self, nums): \"\"\" :type nums: List[int] :rtype: List[List[int]] \"\"\" nums.sort() res = [[]] for i in range(len(nums)): if any(nums[i] in tmp for tmp in res): res.extend([tmp+[nums[i]] for tmp in res if tmp.count(nums[i]) == i - nums.index(nums[i])]) else: res.extend([tmp+[nums[i]] for tmp in res]) return res 思路 2 参考别人的 现在来观察规律，与之前有不同之处是我们需要一个位置来mark，因为不再需要往之前出现过的地方再加了，看这个: 这里这个start是来记录了之前一次数组的长度，temp_size记住目前数组的长度，然后用这个来达到去重的目的，非常聪明 别人的解法，但是一个思路 class Solution(object): def subsetsWithDup(self, nums): \"\"\" :type nums: List[int] :rtype: List[List[int]] \"\"\" nums.sort() res = [[]] tmp_size = 0 for i in range(len(nums)): start = tmp_size if i >= 1 and nums[i] == nums[i-1] else 0 tmp_size = len(res) for j in range(start, tmp_size): res.append([nums[i]]+res[j]) return res 思路 3 跟leetcode第78题一样，DFS, 只不过需要在dfs函数里加一个剪枝的条件，排除掉同样的子集。 class Solution(object): def subsetsWithDup(self, nums): \"\"\" :type nums: List[int] :rtype: List[List[int]] \"\"\" nums.sort() res = [] def dfs(depth, start, lst): if lst not in res: res.append(lst) if depth == len(nums): return for i in range(start, len(nums)): dfs(depth+1, i+1, lst+[nums[i]]) dfs(0, 0, []) return res 思路 4 跟leetcode第78题一样，backtrack class Solution(object): def subsetsWithDup(self, nums): \"\"\" :type nums: List[int] :rtype: List[List[int]] \"\"\" nums.sort() res = [] def search(cur_lst, idx): if idx == len(nums): if cur_lst not in res: res.append(cur_lst) return search(cur_lst + [nums[idx]], idx + 1) search(cur_lst, idx + 1) search([], 0) return res References 南郭子綦 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"091._decode_ways.html":{"url":"091._decode_ways.html","title":"091 decode ways","keywords":"","body":"91. Decode Ways 题目： https://leetcode.com/problems/decode-ways/ tag : DP 难度 : Medium BASE CASE（len(s) = 1 和 len(s) = 2 ）: 直接check 非BASE CASE ： 先令 dp[i] = 0 如果s[i]是可以map的话 -> dp[i] += dp[i-1] 原本的s[0..i]decode方式加上s[i] 如果s[i-1,i]可以map的话 -> dp[i] += dp[i-2] 原本的s[0...i-1]decode方式加上s[i-1,i] Python代码（可美化） class Solution(object): def numDecodings(self, s): \"\"\" :type s: str :rtype: int \"\"\" keys = ['1', '2', '3', '4', '5', '6', '7', '8', '9' ,'10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '23', '24', '25', '26'] values = ['A', 'B','C', 'D', 'E', 'F', 'G','H', 'I', 'J', 'K', 'L', 'M' , 'N', 'O', 'P','Q', 'S', 'R', 'T', 'U','V', 'W', 'X','Y','Z'] numbersToLetters = dict(zip(keys, values)) ways = {} n = len(s) for i in range(n): ways[i] = 0 if n == 0: return 0 elif n == 1 : ways[0] = int(s in numbersToLetters) elif n == 2: if (s[0] in numbersToLetters) and (s[1] in numbersToLetters): ways[1] += 1 if (s in numbersToLetters): ways[1] += 1 else: #s[0] ways[0] = int(s[0] in numbersToLetters) #s[01] if (s[0] in numbersToLetters) and (s[1] in numbersToLetters): ways[1] += 1 if (s[:2] in numbersToLetters): ways[1] += 1 for i in range(2,n): if s[i] in numbersToLetters: ways[i] += ways[i-1] if (s[i-1:i+1] in numbersToLetters): ways[i] += ways[i-2] #print(ways[n-1]) return ways[n-1] 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"092._reverse_linked_list_ii.html":{"url":"092._reverse_linked_list_ii.html","title":"092 reverse linked list ii","keywords":"","body":"92. Reverse Linked List II 题目: https://leetcode.com/problems/reverse-linked-list-ii/ 难度: Medium 跟 reverse linked list一样 思路： 找到 第 m 个node，然后开始reverse到第n个node，然后再把它们和原本的list连接起来 AC 代码 class Solution(object): def reverseBetween(self, head, m, n): \"\"\" :type head: ListNode :type m: int :type n: int :rtype: ListNode \"\"\" # m == n, not reverse if m == n : return head dummy = ListNode(-1) dummy.next = head mbefore = dummy cnt = 1 while mbefore and cnt 看了一下别人的代码，又比我写的好嘛，因为是保证m和n有效，用的是for循环先找到 m node: for _ in range(m-1): .... for _ in range(n-m): reverse 操作 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"093._restore_ip_addresses.html":{"url":"093._restore_ip_addresses.html","title":"093 restore ip addresses","keywords":"","body":"93. Restore IP Addresses 题目: https://leetcode.com/problems/restore-ip-addresses/ 难度: Medium 基本思路已达到，等待AC之路 结果AC之路还是比较漫长的，因为不允许前缀为0困扰了一下 class Solution(object): def restoreIpAddresses(self, s): \"\"\" :type s: str :rtype: List[str] \"\"\" self.res = [] self.singgleAddresses([],s,4) for i in range(len(self.res)): self.res[i] = '.'.join(str(j) for j in self.res[i]) return self.res def singgleAddresses(self, curRes, s, k): \"\"\" :type s: str :rtype: List[str] \"\"\" if len(s) == 0 and k == 0: if curRes not in self.res: self.res.append(curRes) if len(s) == 0 or k 0 and s[0] == '0': return False if int(s) > 0 and int(s) 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"094._binary_tree_inorder_traversal.html":{"url":"094._binary_tree_inorder_traversal.html","title":"094 binary tree inorder traversal","keywords":"","body":"94. Binary Tree Inorder Traversal 难度: 中等 刷题内容 原题连接 https://leetcode.com/problems/binary-tree-inorder-traversal/description/ 内容描述 Given a binary tree, return the inorder traversal of its nodes' values. Example: Input: [1,null,2,3] 1 \\ 2 / 3 Output: [1,3,2] Follow up: Recursive solution is trivial, could you do it iteratively? 解题方案 思路 1 递归，瞬秒 class Solution(object): def inorderTraversal(self, root): \"\"\" :type root: TreeNode :rtype: List[int] \"\"\" res = [] if not root: return res if root.left: res.extend(self.inorderTraversal(root.left)) res.append(root.val) if root.right: res.extend(self.inorderTraversal(root.right)) return res 思路 2 或者我们可以先写一下中序遍历的函数，然后一个一个贴上去 class Solution(object): def inorderTraversal(self, root): \"\"\" :type root: TreeNode :rtype: List[int] \"\"\" if root == None: return [] res = [] self.inorder(root,res) return res def inorder(self,root,res): if root == None: return self.inorder(root.left,res) res.append(root.val) self.inorder(root.right,res) 思路 3 迭代 先一股脑把左边一条线全部push到底（即走到最左边），然后node最终为None了就开始pop stack了，然后因为pop出来的每一个node都是自己这棵树的root，所以看看它有没有右孩子，没有那肯定继续pop，有的话自然而然右孩子是下一个要被访问的节点。 class Solution(object): def inorderTraversal(self, root): \"\"\" :type root: TreeNode :rtype: List[int] \"\"\" res = [] if not root: return res stack = [] node = root while node or (len(stack) > 0): if node: stack.append(node) node = node.left else: node = stack.pop() res.append(node.val) node = node.right return res 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"096._unique_binary_search_trees.html":{"url":"096._unique_binary_search_trees.html","title":"096 unique binary search trees","keywords":"","body":"96. Unique Binary Search Trees 难度: 中等 刷题内容 原题连接 https://leetcode.com/problems/unique-binary-search-trees/description/ 内容描述 Given n, how many structurally unique BST's (binary search trees) that store values 1 ... n? Example: Input: 3 Output: 5 Explanation: Given n = 3, there are a total of 5 unique BST's: 1 3 3 2 1 \\ / / / \\ \\ 3 2 1 1 3 2 / / \\ \\ 2 1 2 3 解题方案 思路 1 参照此处hint: https://shenjie1993.gitbooks.io/leetcode-python/096%20Unique%20Binary%20Search%20Trees.html 首先明确n个不等的数它们能构成的二叉搜索树的种类都是相等的。而且1到n都可以作为二叉搜索树的根节点，当k是根节点时，它的左边有k-1个不等的数，它的右边有n-k个不等的数。以k为根节点的二叉搜索树的种类就是左右可能的种类的乘积。用递推式表示就是 h(n) = h(0)h(n-1) + h(1)h(n-2) + ... + h(n-1)h(0) (其中n>=2) ，其中h(0)=h(1)=1，因为0个或者1个数能组成的形状都只有一个。从1到n依次算出h(x)的值即可。此外这其实就是一个卡特兰数，可以直接用数学公式计算，不过上面的方法更加直观一些。 class Solution(object): def numTrees(self, n): \"\"\" :type n: int :rtype: int \"\"\" dp = [1 for i in range(n+1)] for i in range(2, n+1): s = 0 for k in range(i): s += dp[k]*dp[i-k-1] dp[i] = s return dp[-1] 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"098._validate_binary_search_tree.html":{"url":"098._validate_binary_search_tree.html","title":"098 validate binary search tree","keywords":"","body":"98. Validate Binary Search Tree 题目: https://leetcode.com/problems/validate-binary-search-tree/ 难度: Easy 以前做过这道题，valid binary tree，需要check两件事： 10 / \\ 7 20 / \\ 5 40 node.left.val right subtree of left child, value node.right.val > node.val left subtree of the right child, value > node.val wikipedia上有伪码： truct TreeNode { int key; int value; struct TreeNode *left; struct TreeNode *right; }; bool isBST(struct TreeNode *node, int minKey, int maxKey) { if(node == NULL) return true; if(node->key key > maxKey) return false; return isBST(node->left, minKey, node->key) && isBST(node->right, node->key, maxKey); } if(isBST(root, INT_MIN, INT_MAX)) { puts(\"This is a BST.\"); } else { puts(\"This is NOT a BST!\"); } 实际上就是每次往下看，node都确保被夹在一个范围。 翻译了一下伪码，AC class Solution(object): def isValidBST(self, root): \"\"\" :type root: TreeNode :rtype: bool \"\"\" return self.isBST(root, float('-inf'),float('inf')) def isBST(self, root, minKey, maxKey): if root == None: return True if root.val = maxKey : return False return self.isBST(root.left,minKey,root.val) and self.isBST(root.right, root.val, maxKey) 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"100._same_tree.html":{"url":"100._same_tree.html","title":"100 same tree","keywords":"","body":"100. Same Tree 题目: https://leetcode.com/problems/same-tree/ 难度: Easy 太简单了，递归一行！ # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution(object): def isSameTree(self, p, q): \"\"\" :type p: TreeNode :type q: TreeNode :rtype: bool \"\"\" return p.val == q.val and all(map(self.isSameTree, (p.left, p.right), (q.left, q.right))) if p and q else p is q class Solution(object): def isSameTree(self, p, q): \"\"\" :type p: TreeNode :type q: TreeNode :rtype: bool \"\"\" if (not p and q) or (p and not q): return False if not p and not q: return True if p.val == q.val: return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right) return False 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"101._symmetric_tree.html":{"url":"101._symmetric_tree.html","title":"101 symmetric tree","keywords":"","body":"101. Symmetric Tree 题目: https://leetcode.com/problems/symmetric-tree/ 难度: Easy 两棵树symmetric， 有几种可能： 均为none ，symmetric 左孩子，右孩子都不存在，并且值相等， symmetric 右子树 和 另一棵树的左子树相等，左子树 和另一颗树的右子树相等 🌲 class Solution(object): def isSymmetric(self, root): \"\"\" :type root: TreeNode :rtype: bool \"\"\" if not root: return True return self.symmetric(root.left, root.right) def symmetric(self, l1, l2): if not l1 or not l2: if not l1 and not l2: return True else: return False if l1.val == l2.val: return self.symmetric(l1.left, l2.right) and self.symmetric(l1.right, l2.left) else: return False 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"102._binary_tree_level_order_traversal.html":{"url":"102._binary_tree_level_order_traversal.html","title":"102 binary tree level order traversal","keywords":"","body":"102. Binary Tree Level Order Traversal 难度: 中等 刷题内容 原题连接 https://leetcode.com/problems/binary-tree-level-order-traversal/description/ 内容描述 Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level). For example: Given binary tree [3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7 return its level order traversal as: [ [3], [9,20], [15,7] ] 解题方案 思路 1 递归 class Solution(object): def levelOrder(self, root): \"\"\" :type root: TreeNode :rtype: List[List[int]] \"\"\" res = [] self.recurHelper(root, 0, res) return res def recurHelper(self, root, level, res): if not root: return if len(res) 思路 2 迭代，利用curLevel和nextLevel来记录，然后按层append. class Solution(object): def levelOrder(self, root): \"\"\" :type root: TreeNode :rtype: List[List[int]] \"\"\" if not root: return [] res, cur_level = [], [root] while cur_level: next_level, tmp_res = [], [] for node in cur_level: tmp_res.append(node.val) if node.left: next_level.append(node.left) if node.right: next_level.append(node.right) res.append(tmp_res) cur_level = next_level return res 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"103._binary_tree_zigzag_level_order_traversal.html":{"url":"103._binary_tree_zigzag_level_order_traversal.html","title":"103 binary tree zigzag level order traversal","keywords":"","body":"103. Binary Tree Zigzag Level Order Traversal 题目: https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/ 难度: Medium class Solution(object): def zigzagLevelOrder(self, root): \"\"\" :type root: TreeNode :rtype: List[List[int]] \"\"\" if not root: return [] res, cur_level, level_count = [], [root], 0 while cur_level: next_level, tmp_res = [], [] for node in cur_level: tmp_res.append(node.val) if node.left: next_level.append(node.left) if node.right: next_level.append(node.right) if level_count % 2 == 0: res.append(tmp_res) else: tmp_res.reverse() res.append(tmp_res) level_count += 1 cur_level = next_level return res 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"104._maximum_depth_of_binary_tree.html":{"url":"104._maximum_depth_of_binary_tree.html","title":"104 maximum depth of binary tree","keywords":"","body":"104. Maximum Depth of Binary Tree 题目: https://leetcode.com/problems/maximum-depth-of-binary-tree/ 难度: Easy 简单题,但是这道题跟leetcode111不一样，这道题没有特殊情况，所以一行就够了 class Solution(object): def maxDepth(self, root): \"\"\" :type root: TreeNode :rtype: int \"\"\" return 1 + max(map(self.maxDepth, (root.left, root.right))) if root else 0 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"105._construct_binary_tree_from_preorder_and_inorder_traversal.html":{"url":"105._construct_binary_tree_from_preorder_and_inorder_traversal.html","title":"105 construct binary tree from preorder and inorder traversal","keywords":"","body":"105. Construct Binary Tree from Preorder and Inorder Traversal 从前序与中序遍历序列构造二叉树 难度: 中等 刷题内容 原题连接 https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/ https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/ 内容描述 根据一棵树的前序遍历与中序遍历构造二叉树。 注意: 你可以假设树中没有重复的元素。 例如，给出 前序遍历 preorder = [3,9,20,15,7] 中序遍历 inorder = [9,3,15,20,7] 返回如下的二叉树： 3 / \\ 9 20 / \\ 15 7 解题方案 思路 1 一句话，看到树🌲就要想到递归 preorder 是 根 -> 左 -> 右 inorder 是 左 -> 根 -> 右 首先pre的第一个就是整个树的root, 假设 preorder[0] = inorder[k],那么inorder的前k-1个就是树的左子树，后面部分就是树的右子树 class Solution(object): def buildTree(self, preorder, inorder): \"\"\" :type preorder: List[int] :type inorder: List[int] :rtype: TreeNode \"\"\" if not preorder or len(preorder) == 0: return None root = TreeNode(preorder[0]) k = inorder.index(preorder[0]) root.left = self.buildTree(preorder[1:k+1], inorder[0:k]) root.right = self.buildTree(preorder[k+1:], inorder[k+1:]) return root 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"106._construct_binary_tree_from_inorder_and_postorder_traversal.html":{"url":"106._construct_binary_tree_from_inorder_and_postorder_traversal.html","title":"106 construct binary tree from inorder and postorder traversal","keywords":"","body":"106. Construct Binary Tree from Inorder and Postorder Traversal 题目： https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/ 难度 : Medium inorder 是 左 -> 根 -> 右 postorder 是 左 -> 右 -> 根 跟105基本一样 还是先弄了一个递归可用版本 def buildTree(inorder, postorder): \"\"\" :type preorder: List[int] :type inorder: List[int] :rtype: TreeNode \"\"\" if postorder == inorder == []: return None else: rootVal = postorder[-1] root = TreeNode(rootVal) k = inorder.index(rootVal) root.left = buildTree(inorder[:k],postorder[:k]) root.right = buildTree(inorder[k+1:],postorder[k:-1]) return root 照抄105 class Solution(object): def buildTree(self, inorder, postorder): \"\"\" :type inorder: List[int] :type postorder: List[int] :rtype: TreeNode \"\"\" def buildTree(inorder, postorder, li, ri ,lp, rp ): if lp > rp or li > ri: return None root = TreeNode(postorder[rp]) k = inorder.index(postorder[rp]) # left node left = buildTree(inorder, postorder, li, k-1, lp, lp + k - li - 1) right = buildTree(inorder, postorder, k+1, ri, lp+k-li, rp-1) root.left = left root.right = right return root return buildTree(inorder, postorder, 0, len(inorder) - 1, 0, len(postorder) - 1) 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"107._binary_tree_level_order_traversal_ii.html":{"url":"107._binary_tree_level_order_traversal_ii.html","title":"107 binary tree level order traversal ii","keywords":"","body":"107. Binary Tree Level Order Traversal II 题目: https://leetcode.com/problems/binary-tree-level-order-traversal-ii/ 难度: Easy 用102 的算法作弊 # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution(object): def levelOrderBottom(self, root): \"\"\" :type root: TreeNode :rtype: List[List[int]] \"\"\" res = [] if root == None: return [] curLevel = [root] while curLevel: nextLevel = [] tmpRes = [] for node in curLevel: tmpRes.append(node.val) if node.left: nextLevel.append(node.left) if node.right: nextLevel.append(node.right) res.append(tmpRes) curLevel = nextLevel res.reverse() return res 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"108._convert_sorted_array_to_binary_search_tree.html":{"url":"108._convert_sorted_array_to_binary_search_tree.html","title":"108 convert sorted array to binary search tree","keywords":"","body":"108. Convert Sorted Array to Binary Search Tree 题目: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/ 难度: Medium 思路： 递归 nums为空，return None nums非空，nums[n/2]为中间元素，根结点，nums[:mid]为左子树， nums[mid+1:]为右子树 class Solution(object): def sortedArrayToBST(self, nums): \"\"\" :type nums: List[int] :rtype: TreeNode \"\"\" if not nums: return None if nums: mid = len(nums) / 2 root = TreeNode(nums[mid]) root.left = self.sortedArrayToBST(nums[:mid]) root.right = self.sortedArrayToBST(nums[mid+1:]) return root 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"109._convert_sorted_list_to_binary_search_tree.html":{"url":"109._convert_sorted_list_to_binary_search_tree.html","title":"109 convert sorted list to binary search tree","keywords":"","body":"109. Convert Sorted List to Binary Search Tree 题目: https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/ 难度: Medium 思路： 跟第 108 题一样 class Solution(object): def sortedListToBST(self, head): \"\"\" :type head: ListNode :rtype: TreeNode \"\"\" def sortedArrayToBST(nums): if not nums: return None if nums: mid = len(nums) / 2 root = TreeNode(nums[mid]) root.left = sortedArrayToBST(nums[:mid]) root.right = sortedArrayToBST(nums[mid+1:]) return root if not head: return None else: lst = [] while head: lst.append(head.val) head = head.next return sortedArrayToBST(lst) 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"110._balanced_binary_tree.html":{"url":"110._balanced_binary_tree.html","title":"110 balanced binary tree","keywords":"","body":"110. Balanced Binary Tree 难度: 简单 刷题内容 原题连接 https://leetcode.com/problems/balanced-binary-tree/description/ 内容描述 Given a binary tree, determine if it is height-balanced. For this problem, a height-balanced binary tree is defined as: a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Example 1: Given the following tree [3,9,20,null,null,15,7]: 3 / \\ 9 20 / \\ 15 7 Return true. Example 2: Given the following tree [1,2,2,3,3,null,null,4,4]: 1 / \\ 2 2 / \\ 3 3 / \\ 4 4 Return false. 解题方案 思路 1 递归,判断左右子树最大高度差不超过1且左右子树均为平衡树 class Solution(object): def isBalanced(self, root): \"\"\" :type root: TreeNode :rtype: bool \"\"\" def height(node): if not node: return 0 return 1 + max(height(node.left), height(node.right)) if not root: return True return abs(height(root.left) - height(root.right)) 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"111._minimum_depth_of_binary_tree.html":{"url":"111._minimum_depth_of_binary_tree.html","title":"111 minimum depth of binary tree","keywords":"","body":"111. Minimum Depth of Binary Tree 题目: https://leetcode.com/problems/minimum-depth-of-binary-tree/ 难度: Easy 思路，看完题目我想当然的认为就是直接递归取最小的值，代码如下： class Solution(object): def minDepth(self, root): \"\"\" :type root: TreeNode :rtype: int \"\"\" if not root: return 0 return 1 + min(map(self.minDepth, (root.left, root.right))) 但是没过，有一种特殊情况就是 注意leaf node反正就是没有left和right的 比如下图 1 \\ 2 这种情况应该输出```2```而不是```1 唯一的特殊情况就是上面这种了，因为root下只有一个左节点或者是右节点，这样另外一边的空节点并不算是leaf node leaf node: itself is not null but it has both children null 因此要避免这种情况，代码改成下面： # Definition for a binary tree node. # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution(object): def minDepth(self, root): \"\"\" :type root: TreeNode :rtype: int \"\"\" if not root: return 0 depth_under_root = map(self.minDepth, (root.left, root.right)) return 1 + (min(depth_under_root) or max(depth_under_root)) 所以还是要养成多写edge case的好习惯，也许就帮你避免了general写法的特例,代码如下 class Solution(object): def minDepth(self, root): \"\"\" :type root: TreeNode :rtype: int \"\"\" if root == None: return 0 elif root.left == None and root.right == None: return 1 else : if root.left == None: return 1 + self.minDepth(root.right) elif root.right == None: return 1 + self.minDepth(root.left) else: return min(1+ self.minDepth(root.left), 1+ self.minDepth(root.right)) 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"112._path_sum.html":{"url":"112._path_sum.html","title":"112 path sum","keywords":"","body":"112. Path Sum 题目: https://leetcode.com/problems/path-sum/ 难度: Easy 递归 class Solution(object): def hasPathSum(self, root, sum): \"\"\" :type root: TreeNode :type sum: int :rtype: bool \"\"\" if not root: return False if root.left or root.right: return self.hasPathSum(root.left, sum-root.val) or self.hasPathSum(root.right, sum-root.val) else: return root.val == sum 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"113._path_sum_ii.html":{"url":"113._path_sum_ii.html","title":"113 path sum ii","keywords":"","body":"113. Path Sum II 题目： https://leetcode.com/problems/path-sum-ii/ tag : DFS 难度 : Medium 注意宁愿写几次curList + [root.val] 也不要直接传一个list进去，因为list pass by reference的亏已经吃过了 class Solution(object): def pathSum(self, root, sum): \"\"\" :type root: TreeNode :type sum: int :rtype: List[List[int]] \"\"\" res = [] self.auxPathSum(root, sum, [], res) return res def auxPathSum(self, root, sum, cur_list, cur_lists): if not root: return sum -= root.val if sum == 0 and not root.left and not root.right: cur_lists.append(cur_list + [root.val]) return if root.left: self.auxPathSum(root.left, sum, cur_list + [root.val], cur_lists) if root.right: self.auxPathSum(root.right, sum, cur_list + [root.val], cur_lists) 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"114._flatten_binary_tree_to_linked_list.html":{"url":"114._flatten_binary_tree_to_linked_list.html","title":"114 flatten binary tree to linked list","keywords":"","body":"114. Flatten Binary Tree to Linked List 题目: https://leetcode.com/problems/flatten-binary-tree-to-linked-list/ 难度: Medium 这道题看了hint，说每个node的右节点都是相应先序遍历中它的下一个节点。 所以我的思路是先把先序遍历的node顺序搞出来，然后对于这里面的每一个节点，只需要做两个操作： node.left = None node.right = 相应先序遍历中node的下一个节点 class Solution(object): def flatten(self, root): \"\"\" :type root: TreeNode :rtype: void Do not return anything, modify root in-place instead. \"\"\" def preorder(root): res = [] if not root: return res res.append(root) if root.left: res.extend(preorder(root.left)) if root.right: res.extend(preorder(root.right)) return res if not root: return node_order = preorder(root) for i in range(len(node_order)-1): node_order[i].left = None node_order[i].right = node_order[i+1] node_order[-1].left = None node_order[-1].right = None beat 40.67% 另外一种解法： copy the left and right subtree then cut root’s left subtree do DFS left and right has been flattened and connect them left and right back to the root class Solution(object): def flatten(self, root): \"\"\" :type root: TreeNode :rtype: void Do not return anything, modify root in-place instead. \"\"\" if not root: return left_node = root.left right_node = root.right root.left = None self.flatten(left_node) self.flatten(right_node) if left_node: root.right = left_node while left_node.right: left_node = left_node.right left_node.right = right_node beat 32.18% 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"116._populating_next_right_pointers_in_each_node.html":{"url":"116._populating_next_right_pointers_in_each_node.html","title":"116 populating next right pointers in each node","keywords":"","body":"116. Populating Next Right Pointers in Each Node 难度: 中等 刷题内容 原题连接 https://leetcode.com/problems/populating-next-right-pointers-in-each-node/description/ 内容描述 Given a binary tree struct TreeLinkNode { TreeLinkNode *left; TreeLinkNode *right; TreeLinkNode *next; } Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL. Note: You may only use constant extra space. Recursive approach is fine, implicit stack space does not count as extra space for this problem. You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children). Example: Given the following perfect binary tree, 1 / \\ 2 3 / \\ / \\ 4 5 6 7 After calling your function, the tree should look like: 1 -> NULL / \\ 2 -> 3 -> NULL / \\ / \\ 4->5->6->7 -> NULL 解题方案 思路 1 递归 class Solution: # @param root, a tree link node # @return nothing def connect(self, root): res = [] self.recurHelper(root, 0, res) for level in res: for i in range(len(level)-1): level[i].next = level[i+1] def recurHelper(self, root, level, res): if not root: return if len(res) 思路 2 迭代，利用curLevel和nextLevel来记录，然后按层append. class Solution: # @param root, a tree link node # @return nothing def connect(self, root): if not root: return res, cur_level = [], [root] while cur_level: next_level = [] for node in cur_level: if node.left: next_level.append(node.left) if node.right: next_level.append(node.right) res.append(cur_level) cur_level = next_level for cur_level in res: for i in range(len(cur_level)-1): cur_level[i].next = cur_level[i+1] 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"117._Populating_Next_Right_Pointers_in_Each_Node_II.html":{"url":"117._Populating_Next_Right_Pointers_in_Each_Node_II.html","title":"117 Populating Next Right Pointers in Each Node II","keywords":"","body":"117. Populating Next Right Pointers in Each Node II 难度: 中等 刷题内容 原题连接 https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/description/ 内容描述 Given a binary tree struct TreeLinkNode { TreeLinkNode *left; TreeLinkNode *right; TreeLinkNode *next; } Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL. Note: You may only use constant extra space. Recursive approach is fine, implicit stack space does not count as extra space for this problem. Example: Given the following binary tree, 1 / \\ 2 3 / \\ \\ 4 5 7 After calling your function, the tree should look like: 1 -> NULL / \\ 2 -> 3 -> NULL / \\ \\ 4-> 5 -> 7 -> NULL 解题方案 思路 1 递归 class Solution: # @param root, a tree link node # @return nothing def connect(self, root): res = [] self.recurHelper(root, 0, res) for cur_level in res: for i in range(len(cur_level)-1): cur_level[i].next = cur_level[i+1] def recurHelper(self, root, level, res): if not root: return if len(res) 思路 2 迭代版本, beats 100% class Solution: # @param root, a tree link node # @return nothing def connect(self, root): if not root: return res, cur_level = [], [root] while cur_level: next_level = [] for node in cur_level: if node.left: next_level.append(node.left) if node.right: next_level.append(node.right) res.append(next_level) cur_level = next_level for cur_level in res: for i in range(len(cur_level)-1): cur_level[i].next = cur_level[i+1] 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"118._pascal's_triangle.html":{"url":"118._pascal's_triangle.html","title":"118 pascal's triangle","keywords":"","body":"118. Pascal's Triangle 难度: 简单 刷题内容 原题连接 https://leetcode.com/problems/pascals-triangle/description/ 内容描述 Given a non-negative integer numRows, generate the first numRows of Pascal's triangle. In Pascal's triangle, each number is the sum of the two numbers directly above it. Example: Input: 5 Output: [ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1] ] 解题方案 思路 1 高中数学知识，把行数理理清楚就ok class Solution(object): def generate(self, numRows): \"\"\" :type numRows: int :rtype: List[List[int]] \"\"\" if numRows == 0: return [] res = [[1]] for i in range(1, numRows): tmp = [1] for j in range(1, i): tmp.append(res[-1][j-1]+res[-1][j]) tmp.append(1) res.append(tmp) return res 或者可以写得更简单一些，这里谢谢荼靡大佬的想法，棒！ class Solution(object): def generate(self, numRows): \"\"\" :type numRows: int :rtype: List[List[int]] \"\"\" res = [[1]] for i in range(1, numRows): res.append(map(lambda x,y:x+y, [0]+res[-1], res[-1]+[0])) return res[:numRows] 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"119._Pascal's_Triangle_II.html":{"url":"119._Pascal's_Triangle_II.html","title":"119 Pascal's Triangle II","keywords":"","body":"119. Pascal's Triangle II 题目： https://leetcode.com/problems/pascals-triangle-ii/ 难度 : Easy 思路： 太简单了，注意一点算数就好 class Solution(object): def getRow(self, rowIndex): \"\"\" :type rowIndex: int :rtype: List[int] \"\"\" if rowIndex == 0: return [1] res = [1] for i in range(1, rowIndex+1): tmp = [1] for j in range(1, i): tmp.append(res[j-1]+res[j]) tmp.append(1) res = tmp return res 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"120._Triangle.html":{"url":"120._Triangle.html","title":"120 Triangle","keywords":"","body":"120. Triangle 题目: https://leetcode.com/problems/triangle/ 难度: Medium 思路： 先是要注意下这句话：Each step you may move to adjacent numbers on the row below 在考虑adjacent number的定义，并不是角标的adjacent，而是真的形态上的adjacent 比如 -1 -1 2 1 最小 1 0 -2 2 0 -1 2 0 最小是-1， 而并不能从第二排的0跳到第三排的第一个造成-2. so AC代码 感觉关于dp，我可能还需要补一些东西，因为我不能做到O(n) space class Solution(object): def minimumTotal(self, triangle): \"\"\" :type triangle: List[List[int]] :rtype: int \"\"\" # n total rows of triangle n = len(triangle) if n == 1: return triangle[0][0] elif n == 2 : return min(triangle[0][0] + triangle[1][0], triangle[0][0] + triangle[1][1]) else: res = [] for i in range(n): res.append(triangle[i]) res[0] = [triangle[0][0]] res[1] = [triangle[0][0] + triangle[1][0], triangle[0][0] + triangle[1][1]] for i in range(2,n): for j in range(i+1): if j == 0: res[i][j] = res[i-1][j] + triangle[i][j] elif j == i: res[i][j] = res[i-1][-1] + triangle[i][j] else: res[i][j] = min(res[i-1][j-1],res[i-1][j]) + triangle[i][j] return min(res[-1]) 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"121._Best_Time_to_Buy_and_Sell_Stock.html":{"url":"121._Best_Time_to_Buy_and_Sell_Stock.html","title":"121 Best Time to Buy and Sell Stock","keywords":"","body":"121. Best Time to Buy and Sell Stock 难度: 简单 刷题内容 原题连接 https://leetcode.com/problems/best-time-to-buy-and-sell-stock/ 内容描述 Say you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit. Note that you cannot sell a stock before you buy one. Example 1: Input: [7,1,5,3,6,4] Output: 5 Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5. Not 7-1 = 6, as selling price needs to be larger than buying price. Example 2: Input: [7,6,4,3,1] Output: 0 Explanation: In this case, no transaction is done, i.e. max profit = 0. 解题方案 思路1 对于从第一天后的每一天，我们都假设昨天就已经卖掉了，那么现在我们可以看看如果昨天卖可以赚的钱加上今天与昨天股票的价格差价是否大于0，如果大于0就说明今天卖赚的更多，那么我们就还是先存下今天卖可以多赚的max_cur，继续往后看，如果小于0就还是坚持昨天可以赚的钱（即之前的max_cur） All the straight forward solution should work, but if the interviewer twists the question slightly by giving the difference array of prices, Ex: for {1, 7, 4, 11}, if he gives {0, 6, -3, 7}, you might end up being confused. Here, the logic is to calculate the difference (maxCur += prices[i] - prices[i-1]) of the original array, and find a contiguous subarray giving maximum profit. If the difference falls below 0, reset it to zero. 参考Maximum subarray problem, Kadane's Algorithm Why maxCur = Math.max(0, maxCur += prices[i] - prices[i-1]); ? Well, we can assume opt(i) as the max Profit you will get if you sell the stock at day i; We now face two situations: We hold a stock at day i, which means opt(i) = opt(i - 1) - prices[i - 1] + prices[i] (max Profit you can get if you sell stock at day(i-1) - money you lose if you buy the stock at day (i-1) + money you gain if you sell the stock at day i. We do not hold a stock at day i, which means we cannot sell any stock at day i. In this case, money we can get at day i is 0; opt(i) is the best case of 1 and 2. So, opt(i) = Max{opt(i - 1) - prices[i - 1] + prices[i], 0} class Solution(object): def maxProfit(self, prices): \"\"\" :type prices: List[int] :rtype: int \"\"\" if not prices or len(prices) == 0: return 0 res, max_cur = 0, 0 for i in range(1, len(prices)): max_cur = max(0, max_cur+prices[i]-prices[i-1]) # 如果今天卖相比于昨天卖能多赚，则今天卖，否则之前就卖了 res = max(res, max_cur) return res 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"124._Binary_Tree_Maximum_Path_Sum.html":{"url":"124._Binary_Tree_Maximum_Path_Sum.html","title":"124 Binary Tree Maximum Path Sum","keywords":"","body":"124. Binary Tree Maximum Path Sum 题目: https://leetcode.com/problems/binary-tree-maximum-path-sum/ 难度: Hard 思路 class Solution(object): def maxPathSum(self, root): \"\"\" :type root: TreeNode :rtype: int \"\"\" self.global_max = root.val if root else 0 self.findmax(root) return self.global_max def findmax(self, node): if not node: return 0 left = self.findmax(node.left) left = left if left > 0 else 0 right = self.findmax(node.right) right = right if right > 0 else 0 # 这句是精髓，只要判断出当前这个点作为root的path更长，就更新一下 self.global_max = max(left + right + node.val, self.global_max) # 这里是因为sub_path只能为一条边，不然跟上面的root组合起来就不是path了 return max(left, right) + node.val 其实开始的时候我想当然的用了很傻的方法，并且是错误的，因为这样当[-10,9,20,null,null,15,7]的时候我们会取所有的点，返回41，然而我们可以取到42的， 即15+7+20 class Solution(object): def maxPathSum(self, root): \"\"\" :type root: TreeNode :rtype: int \"\"\" if not root: return 0 if not root.left and not root.right: return root.val if not root.left: return max(root.val, root.val+self.maxPathSum(root.right)) if not root.right: return max(root.val, root.val+self.maxPathSum(root.left)) return max(root.val, root.val+self.maxPathSum(root.right), root.val+self.maxPathSum(root.left), root.val+self.maxPathSum(root.left)+self.maxPathSum(root.right)) 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"125._valid_palindrome.html":{"url":"125._valid_palindrome.html","title":"125 valid palindrome","keywords":"","body":"125. Valid Palindrome 题目: https://leetcode.com/problems/valid-palindrome/ 难度: Easy 就是比较reversed string 和原本的是否相等. class Solution(object): def isPalindrome(self,s): \"\"\" :type s: str :rtype: bool \"\"\" new=[] s = s.lower() for i in s: if '0' 或者用正则,详见re.sub()用法 瞬间beats 97.71% class Solution(object): def isPalindrome(self, s): \"\"\" :type s: str :rtype: bool \"\"\" newString = re.sub(\"[^0-9a-zA-Z]+\", \"\", s) return newString.lower() == newString.lower()[::-1] 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"126._Word_Ladder_II.html":{"url":"126._Word_Ladder_II.html","title":"126 Word Ladder II","keywords":"","body":"126. Word Ladder II 题目: https://leetcode.com/problems/word-ladder-ii/ 难度: Hard 其实关键在于怎么优化和表示图 思路来自1p3a： 这题目实在是太适合python了 如此简洁 就是基本的bfs，典型的level order traverse 有两个坑： 不要判断字典里的某两个word是否只相差一个字母，而是要判断某个word的邻居（和他只相差一个字母的所有word）是否在字典里，这样的改进会使这一步的复杂度下降很多，否则超时妥妥 每一轮访问过的word一定要从字典中删除掉，否则一定会超时 最后见到end word就收 完成 拿题目的例子来看： hit | hot / \\ dot lot | | dog log \\ / cog routine 字典，然后再根据这个来寻找路径 {'cog': ['log', 'dog'], 'hit': [], 'log': ['lot'], 'dog': ['dot'], 'hot': ['hit'], 'lot': ['hot'], 'dot': ['hot']} 'cog': ['log', 'dog']这里的意思就是说在走到'cog'之前尝试过了'log'和'dog'，即previous tried node 而生成字典的过程就是BFS的，此处保证寻找的路径就是最短的。 AC代码： class Solution(object): def findLadders(self, beginWord, endWord, wordList): \"\"\" :type beginWord: str :type endWord: str :type wordList: List[str] :rtype: List[List[str]] \"\"\" def backtrack(result, trace, path, word): if len(trace[word]) == 0: result.append([word] + path) else: for prev in trace[word]: backtrack(result, trace, [word] + path, prev) lookup = set(wordList) | set([beginWord]) res, cur, routine = [], set([beginWord]), {word: [] for word in lookup} while cur and endWord not in cur: next_queue = set() for word in cur: lookup.remove(word) for word in cur: for i in range(len(word)): for j in 'abcdefghijklmnopqrstuvwxyz': candidate = word[:i] + j + word[i + 1:] if candidate in lookup: next_queue.add(candidate) routine[candidate].append(word) cur = next_queue if cur: backtrack(res, routine, [], endWord) return res 这样可以beat 69.09% 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"127._word_ladder.html":{"url":"127._word_ladder.html","title":"127 word ladder","keywords":"","body":"127. Word Ladder 题目: https://leetcode.com/problems/word-ladder/ 难度: Medium tag可以算BFS，其实就是求shortest path的变体 Reference from kamyu104 class Solution(object): def ladderLength(self, beginWord, endWord, wordList): \"\"\" :type beginWord: str :type endWord: str :type wordList: List[str] :rtype: int \"\"\" distance, cur, visited, lookup = 0, [beginWord], set([beginWord]), set(wordList) while cur: next_queue = [] for word in cur: if word == endWord: return distance + 1 for i in xrange(len(word)): for j in 'abcdefghijklmnopqrstuvwxyz': candidate = word[:i] + j + word[i + 1:] if candidate not in visited and candidate in lookup: next_queue.append(candidate) visited.add(candidate) distance += 1 cur = next_queue return 0 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"128._Longest_Consecutive_Sequence.html":{"url":"128._Longest_Consecutive_Sequence.html","title":"128 Longest Consecutive Sequence","keywords":"","body":"128. Longest Consecutive Sequence 题目: https://leetcode.com/problems/longest-consecutive-sequence/ 难度: Hard 思路 首先去重复，时间O(N),然后将所有元素都放到一个字典中，这样判断一个数字的后续在不在这个字典中，如果存在就一直判断下去，每次判断只要O(1)。 对于每个数，如果他的前续已经判断过了，他就没有必要判断了，继续判断下一个数，即： if num - 1 in nums: continue AC代码： class Solution(object): def longestConsecutive(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" nums = set(nums) tmp = {} for num in nums: tmp[num] = 1 res = 0 for num in nums: if num - 1 not in nums: y = num + 1 while y in nums: y += 1 res = max(res, y - num) return res 但其实set和字典的in判断都是O(1) dict与set实现原理是一样的，都是将实际的值放到list中。唯一不同的在于hash函数操作的对象，对于dict，hash函数操作的是其key，而对于set是直接操作的它的元素，假设操作内容为x，其作为因变量，放入hash函数，通过运算后取list的余数，转化为一个list的下标，此下标位置对于set而言用来放其本身，而对于dict则是创建了两个list，一个list该下表放此key，另一个list中该下标方对应的value。参考python dict与set 的实现 　　其中，我们把实现set的方式叫做Hash Set，实现dict的方式叫做Hash Map/Table(注：map指的就是通过key来寻找value的过程) 因此，代码也可以写成这样 ```python class Solution(object): def longestConsecutive(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" nums = set(nums) res = 0 for num in nums: if num - 1 not in nums: y = num + 1 while y in nums: y += 1 res = max(res, y - num) return res 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"129._sum_root_to_leaf_numbers.html":{"url":"129._sum_root_to_leaf_numbers.html","title":"129 sum root to leaf numbers","keywords":"","body":"129. Sum Root to Leaf Numbers 题目: https://leetcode.com/problems/sum-root-to-leaf-numbers/ 难度: Medium 其实递归不难想到，不过我自己做错在细节方面 如果只有单支，每朝下走一层，代表的数字都增加10， 10* 原本的 + 新节点的数字，最终也是用这个来解 class Solution(object): def sumNumbers(self, root): \"\"\" :type root: TreeNode :rtype: int \"\"\" return self.calSum(root,0) def calSum(self,root,curSum): if root == None: return 0 else: curSum = curSum * 10 + root.val if root.left == None and root.right == None: return curSum else: return self.calSum(root.left, curSum) + self.calSum(root.right, curSum) 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"130._surrounded_regions.html":{"url":"130._surrounded_regions.html","title":"130 surrounded regions","keywords":"","body":"130. Surrounded Regions 题目: https://leetcode.com/problems/surrounded-regions 难度: Medium 思路: loop，然后碰到O做DFS/BFS找出O所在区域: 貌似只要O没有碰壁，O就总是被X包围着？ 所以找出O的范围，然后看它是否碰壁，没有碰壁则mark不需要修改 但是这道题折磨我了很久，因为它有毛病。。。。 它给的input例子是 [\"XXX\",\"XOX\",\"XXX\"] 也怪我 input写着List[List[str]] 但实际上的输入是： [[u'X', u'X', u'X'], [u'X', u'X', u'X'], [u'X', u'X', u'X']] 还要mark unicode 还有就是学会了新的可以函数之下定义函数，这样就不用什么self了，用起来真方便，但是这样的思路做起来会超时。 class Solution(object): def solve(self, board): \"\"\" :type board: List[List[str]] :rtype: void Do not return anything, modify board in-place instead. \"\"\" def shouldOChange(i, j): \"\"\" return x,y area and whether they shouldChange \"\"\" shouldChange = True Oarea = [] s = [] s.append((i,j)) while s: (x,y) = s.pop() if x == 0 or x == row - 1 or y == 0 or y == col -1 : shouldChange = False visited[x][y] = 1 Oarea.append((x,y)) if legal(x-1,y): s.append((x-1,y)) if legal(x+1,y): s.append((x+1,y)) if legal(x,y-1): s.append((x,y-1)) if legal(x,y-1): s.append((x,y+1)) return Oarea,shouldChange def legal(x,y): return x>=0 and x =0 and y 另一个思路就是对周围碰壁的O做BFS/DFS，碰壁的和碰壁相连的是不需要修改的。这样就时间复杂度降低很多了。 原本是O(n^2)可能做DFS/BFS。现在是O(4n)做DFS/BFS,但是发现依旧超时，最后查看了别人的解法，因为我的解法里面多了一个存储工具，相当于，把需要更换location的位置存储起来，最后做loop的时候去查，然后这样还是很耗时。 而一个简便的变法是把这些特别的碰壁的'O' mark出来，这样最后loop的时候不改变这些'O'，只改变不碰壁的'O',又可以减少工作量。同时依旧可以使用collection里面的queue AC代码 class Solution(object): def solve(self, board): \"\"\" :type board: List[List[str]] :rtype: void Do not return anything, modify board in-place instead. \"\"\" def legal(x,y): return x>=0 and x =0 and y 同时发现，用这种方式，无论是否使用collection里面的queue，都能AC 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"131._palindrome_partitioning.html":{"url":"131._palindrome_partitioning.html","title":"131 palindrome partitioning","keywords":"","body":"131. Palindrome Partitioning 题目: https://leetcode.com/problems/palindrome-partitioning/ 难度: Medium 知道一定是用递归做，但是在怎么拆的部分疑惑了，然后看了hint key部分长这样，拆法是类似于combination，然后这个len(s) == 0是确保能被拆为palindrome，因为这样剩下的string才是空的 这个recursion tree是这样的，感觉时间复杂度是O(n!)，因为每次树都branch n个分支 class Solution(object): def partition(self, s): \"\"\" :type s: str :rtype: List[List[str]] \"\"\" self.res = [] self.dfs(s,[]) return self.res def dfs(self, s, stringList): if len(s) == 0: self.res.append(stringList) for i in range(1,len(s)+1): if self.isPalindrome(s[:i]): self.dfs(s[i:],stringList + [s[:i]]) def isPalindrome(self, s): if len(s) 输出是每次必定从单个char的list开始，然后单个char 配 palindrome word，然后palindrome word再来配char... 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"133._clone_graph.html":{"url":"133._clone_graph.html","title":"133 clone graph","keywords":"","body":"133. Clone Graph 题目: https://leetcode.com/problems/clone-graph/ 难度: Medium 思路： DFS或者BFS把graph traverse一遍，边traverse边复制。因为nodes are labeled uniquely，这就是方便的地方，但是注意node可能重复和有self-loop. 所以先建立新的root node，然后有一个dict把node label和node一一对应。 用stack来存储原本的graph root node，对原本的graph做DFS，这个时候，如果这个node的neighbor是已经出现过，那么我们就是去修改原本的existNode，让它指向存在的neighbor，否则创建新的，再把它们联系起来，谷歌了一下，别人写的比我更简单。anyway，先AC。 if cur.label in createdNodes:多余。 class Solution(object): def cloneGraph(self, node): \"\"\" :type node: UndirectedGraphNode :rtype: UndirectedGraphNode \"\"\" if node == None: return None root = UndirectedGraphNode(node.label) # must 1 to 1 createdNodes = {} createdNodes[root.label] = root stack = [] stack.append(node) while stack: cur = stack.pop() if cur.label in createdNodes: existNode = createdNodes[cur.label] for neighbor in cur.neighbors: if neighbor.label in createdNodes: existNeighbor = createdNodes[neighbor.label] existNode.neighbors.append(existNeighbor) else: newNode = UndirectedGraphNode(neighbor.label) existNode.neighbors.append(newNode) createdNodes[neighbor.label] = newNode stack.append(neighbor) return root 看了别人的代码，貌似比我又写的简洁。 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"136._single_number.html":{"url":"136._single_number.html","title":"136 single number","keywords":"","body":"136. Single Number 题目: https://leetcode.com/problems/single-number/ 难度: Easy 思路： 位运算，终于要take it了 非常常见的一道算法题，将所有数字进行异或操作即可。对于异或操作明确以下三点： 一个整数与自己异或的结果是0 一个整数与0异或的结果是自己 异或操作满足交换律，即a^b=b^a Python的位操作： https://wiki.python.org/moin/BitwiseOperators 神奇的解法： class Solution(object): def singleNumber(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" res = nums[0] for i in nums[1:]: res ^= i return res 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"139._word_break.html":{"url":"139._word_break.html","title":"139 word break","keywords":"","body":"139. Word Break 题目: https://leetcode.com/problems/word-break/ 难度: Medium ok[i] tells whether s[:i] can be built. class Solution(object): def wordBreak(self, s, wordDict): \"\"\" :type s: str :type wordDict: List[str] :rtype: bool \"\"\" ok = [True] for i in range(1, len(s)+1): ok += [any(ok[j] and s[j:i] in wordDict for j in range(i))] return ok[-1] 但是往list里面加数据的方法有快有慢，下面是对比： >>> from timeit import timeit >>> timeit('x.append(1)', 'x = []', number=10000000) 1.9880003412529277 >>> timeit('x += 1,', 'x = []', number=10000000) 1.2676891852971721 >>> timeit('x += [1]', 'x = []', number=10000000) 3.361207239950204 因此我们可以将代码直接换成下面的格式 ok += any(ok[j] and s[j:i] in wordDict for j in range(i)) # 会报错 但是这样会报错，TypeError: 'bool' object is not iterable，因此bool类型数据不能这样加，别的可以（list类型本身当然要注意哈） 因此在这个例子中我们这样： class Solution(object): def wordBreak(self, s, wordDict): \"\"\" :type s: str :type wordDict: List[str] :rtype: bool \"\"\" ok = [True] for i in range(1, len(s)+1): ok += any(ok[j] and s[j:i] in wordDict for j in range(i)), return ok[-1] 代码里面的那个逗号构建了一个tuple，也会快一点 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"140._word_break_ii.html":{"url":"140._word_break_ii.html","title":"140 word break ii","keywords":"","body":"140. Word Break II 题目: https://leetcode.com/problems/word-break-ii/ 难度: Medium 还是backtracking，会超时 class Solution(object): # 此法超时 def wordBreak(self, s, wordDict): \"\"\" :type s: str :type wordDict: Set[str] :rtype: bool \"\"\" self.res = [] self.wordBreakLst(\"\",s,wordDict) return self.res def wordBreakLst(self, lst, rest, wordDict): if rest == '': self.res.append(lst.rstrip()) # print lst for i in range(1+len(rest)): if rest[:i] in wordDict: self.wordBreakLst(lst + rest[:i] + \" \",rest[i:],wordDict) 然后看到有把word break i 结合起来减少时间复杂度的作法。 做法如下，聪明： 就是对于每一个s，我们来check它是否可以break，如果不可以，就不用做相应的操作了 class Solution(object): def wordBreak(self, s, wordDict): \"\"\" :type s: str :type wordDict: List[str] :rtype: List[str] \"\"\" self.res = [] self.wordBreakLst(s, wordDict, '') return self.res def check(self, s, wordDict): ok = [True] for i in range(1, len(s) + 1): ok += any(ok[j] and s[j:i] in wordDict for j in range(i)), return ok[-1] def wordBreakLst(self, s, wordDict, stringLst): if self.check(s, wordDict): if len(s) == 0 : self.res.append(stringLst[1:]) # 因为最开始也加了一个空格 for i in range(1,len(s)+1): if s[:i] in wordDict: self.wordBreakLst(s[i:], wordDict, stringLst + ' ' + s[:i]) 但是其实 s = \"aaaaaa\" wordDict = [\"a\",\"aa\",\"aaa\"] print a.wordBreak(s,wordDict)还是会loop很多次 不过像 s = \"aabbb\" wordDict = [\"a\",\"abbb\"] 就会极其的减少loop次数 看看stefan大神的做法： sentences(i) returns a list of all sentences that can be built from the suffix s[i:]. class Solution(object): def wordBreak(self, s, wordDict): \"\"\" :type s: str :type wordDict: List[str] :rtype: List[str] \"\"\" memo = {len(s): ['']} def sentences(i): if i not in memo: memo[i] = [s[i:j] + (tail and ' ' + tail) for j in range(i+1, len(s)+1) if s[i:j] in wordDict for tail in sentences(j)] return memo[i] return sentences(0) 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"141._linked_list_cycle.html":{"url":"141._linked_list_cycle.html","title":"141 linked list cycle","keywords":"","body":"141. Linked List Cycle 题目: https://leetcode.com/problems/linked-list-cycle/ 难度: Easy 想法一： 直接超时 class Solution(object): def hasCycle(self, head): \"\"\" :type head: ListNode :rtype: bool \"\"\" if head == None: return False lst = [] cur = head while cur: if cur in lst: return True lst.append(cur) cur = cur.next return False 想法二：相当用boolean array记录某个点是否被访问过，时间，空间复杂度都是O（n） class Solution(object): def hasCycle(self, head): \"\"\" :type head: ListNode :rtype: bool \"\"\" if head == None: return False dictx = {} cur = head while cur: if cur in dictx: return True dictx[cur] = 1 cur = cur.next return False 结果这种方法的run time还比较快 查了一下，有解答说可以有空间复杂度O（1），时间复杂度O（n）。两个指针，一个快一个慢，快的每次走两步，慢的每次走一步，如果有环，最终会在某处相遇。这也是一个算法。这种快慢指针配合已经不是第一次遇到了，比如找linklist中间的node。 但是并没有觉得这样的算法是O(n)， worst case time complexity is O(N+K), which is O(n). python class Solution(object): def hasCycle(self, head): \"\"\" :type head: ListNode :rtype: bool \"\"\" slow = head fast = head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False java public class Solution { public boolean hasCycle(ListNode head) { if (head == null){ return false; } ListNode fast = head; ListNode slow = head; while (fast != null && slow != null && fast.next != null){ fast = fast.next.next; slow = slow.next; if (slow == fast){ return true; } } return false; } } 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"142_Linked_List_Cycle_II.html":{"url":"142_Linked_List_Cycle_II.html","title":"142_Linked_List_Cycle_II md","keywords":"","body":"142. Linked List Cycle II 题目: https://leetcode.com/problems/linked-list-cycle-ii/ 难度: Medium 思路： 稍微改了一下141，这里稍微注意一下while-else clause就行 Let’s say, the first node is node 0, the cycle starts at node L, and the length of the cycle is C; Moreover, after t steps, fast catches slow. Now we know that fast totally traveled 2t nodes, and slow traveled t nodes Then we have: 2t - t = nC (where n is an positive integer.) i.e. t=nC Now, think about that, at step t, if we travels L more steps, where are we? i.e. if we travel L+t = L + nC steps in total, where are we? Absolutely, at the start of the cycle, because we have covered the first L nodes once and the entire cycle n times. So, if we travel L more steps at time t, then we get the start of the cycle. However, how can we travel exactly L step? The answer is to use an other pointer to travel from node 0, and when they meet together, it is exactly L steps and both of them are at the start of the cycle. 参考LostSummer233的解答 class Solution(object): def detectCycle(self, head): \"\"\" :type head: ListNode :rtype: bool \"\"\" slow = fast = head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: break else: return None while head != slow: slow = slow.next head = head.next return head 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"143._reorder_list.html":{"url":"143._reorder_list.html","title":"143 reorder list","keywords":"","body":"143. Reorder List 题目: https://leetcode.com/problems/reorder-list/ 难度: Medium 超时 class Solution(object): def reorderList(self, head): \"\"\" :type head: ListNode :rtype: void Do not return anything, modify head in-place instead. \"\"\" head = self.reorder(head) def reorder(self, head): if head == None or head.next == None or head.next.next == None: return head l0 = head l1 = head.next ln_1 = self.oneNodeTail(head) ln =ln_1.next l0.next = ln ln_1.next = None ln.next = self.reorder(l1) return l0 def oneNodeTail(self, head): if head == None or head.next == None or head.next.next == None: return head cur = head while cur.next: if cur.next.next: cur = cur.next else: break return cur 取巧的办法是： 找到中间节点，断开，把后半截linked list reverse，然后合并 √ 看了AC指南 class Solution(object): def reorderList(self, head): \"\"\" :type head: ListNode :rtype: void Do not return anything, modify head in-place instead. \"\"\" if head == None or head.next == None or head.next.next == None: return slow = head fast = head prev = None while fast and fast.next: prev = slow slow = slow.next fast = fast.next.next prev.next = None slow = self.reverseList(slow) cur = head while cur.next: tmp = cur.next cur.next = slow slow = slow.next cur.next.next = tmp cur = tmp cur.next = slow def reverseList(self,head): \"\"\" :type head: ListNode :rtype: ListNode \"\"\" prev = None cur = head while(cur): nxt = cur.next cur.next = prev prev = cur cur = nxt return prev 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"144._binary_tree_preorder_traversal.html":{"url":"144._binary_tree_preorder_traversal.html","title":"144 binary tree preorder traversal","keywords":"","body":"144. Binary Tree Preorder Traversal 难度: 中等 刷题内容 原题连接 https://leetcode.com/problems/binary-tree-preorder-traversal/description/ 内容描述 Given a binary tree, return the preorder traversal of its nodes' values. Example: Input: [1,null,2,3] 1 \\ 2 / 3 Output: [1,2,3] Follow up: Recursive solution is trivial, could you do it iteratively? 解题方案 思路 1 Recursive递归,瞬秒 class Solution(object): def preorderTraversal(self, root): \"\"\" :type root: TreeNode :rtype: List[int] \"\"\" res = [] if not root: return res res.append(root.val) if root.left: res.extend(self.preorderTraversal(root.left)) if root.right: res.extend(self.preorderTraversal(root.right)) return res 思路 2 或者我们可以先写一下先序遍历的函数，然后一个一个贴上去 class Solution(object): def preorderTraversal(self, root): \"\"\" :type root: TreeNode :rtype: List[int] \"\"\" if root == None: return [] res = [] self.preorder(root,res) return res def preorder(self,root,res): if root == None: return res.append(root.val) self.preorder(root.left,res) self.preorder(root.right,res) Iterative, 迭代 class Solution(object): def preorderTraversal(self, root): \"\"\" :type root: TreeNode :rtype: List[int] \"\"\" res = [] if not root: return res stack = [] stack.append(root) while(len(stack) > 0): node = stack.pop() res.append(node.val) if node.right: stack.append(node.right) if node.left: stack.append(node.left) return res 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"145._binary_tree_postorder_traversal.html":{"url":"145._binary_tree_postorder_traversal.html","title":"145 binary tree postorder traversal","keywords":"","body":"145. Binary Tree Postorder Traversal 二叉树的后序遍历 难度: 困难 刷题内容 原题连接 https://leetcode.com/problems/binary-tree-postorder-traversal/description/ 内容描述 给定一个二叉树，返回它的 后序 遍历。 示例: 输入: [1,null,2,3] 1 \\ 2 / 3 输出: [3,2,1] 进阶: 递归算法很简单，你可以通过迭代算法完成吗？ 解题方案 思路 1 递归，so easy class Solution(object): def postorderTraversal(self, root): \"\"\" :type root: TreeNode :rtype: List[int] \"\"\" res = [] if not root: return res left = self.postorderTraversal(root.left) right = self.postorderTraversal(root.right) if left: res.extend(left) if right: res.extend(right) res.append(root.val) return res 思路 2 也可以先写一下后序遍历的函数，然后一个一个贴上去 class Solution(object): def postorderTraversal(self, root): \"\"\" :type root: TreeNode :rtype: List[int] \"\"\" def postOrder(root): if not root : return postOrder(root.left) postOrder(root.right) res.append(root.val) res = [] postOrder(root) return res 思路 3 迭代, 其实思路就一句话，后序遍历是左右中，因为我们第一个放进去的肯定是中（即root），所以我们逆向思维考虑一下，我们按照中右左的顺序放进去，然后返回res[::-1]就行了。这其实跟leetcode第144题是一样的思路 class Solution(object): def postorderTraversal(self, root): \"\"\" :type root: TreeNode :rtype: List[int] \"\"\" res = [] if not root: return res stack1 = [] stack1.append(root) while len(stack1) > 0: node = stack1.pop() res.append(node.val) if node.left: stack1.append(node.left) if node.right: stack1.append(node.right) return res[::-1] 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"147._insertion_sort_list.html":{"url":"147._insertion_sort_list.html","title":"147 insertion sort list","keywords":"","body":"147. Insertion Sort List 题目: https://leetcode.com/problems/insertion-sort-list/ 难度: Medium insertion sort 也是入门必备，一个元素本身被认为是sort的，一个简单的理解是打牌，然后进入第二个元素的时候，看它是比第一个元素大还是小，做排序，进入下一个元素的时候再看再移。 伪码 for i ← 1 to length(A)-1 j ← i while j > 0 and A[j-1] > A[j] swap A[j] and A[j-1] j ← j - 1 end while end for 这个伪码对于list可能适用性没有那么强，则考虑，从第二个node开始，那么从开始开始看，找到这个node应该插入的位置，插入。 就是这样，就是会超时|||| class Solution(object): def insertionSortList(self, head): \"\"\" :type head: ListNode :rtype: ListNode \"\"\" if head == None or head.next == None: return head dummy = ListNode(-1) dummy.next = head prev = head cur = head.next while cur: p = dummy while p.next.val 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"148._sort_list.html":{"url":"148._sort_list.html","title":"148 sort list","keywords":"","body":"148. Sort List 题目: https://leetcode.com/problems/sort-list/ 难度: Medium MergeSort merge sort是必备，divide & conquer的入门之物。 merge sort做两件事， sort 和 merge。 看一看标准伪码： function mergesort(m) var list left, right, result if length(m) ≤ 1 return m else var middle = length(m) / 2 for each x in m up to middle - 1 add x to left for each x in m at and after middle add x to right left = mergesort(left) right = mergesort(right) if last(left) ≤ first(right) append right to left return left result = merge(left, right) return result function merge(left,right) var list result while length(left) > 0 and length(right) > 0 if first(left) ≤ first(right) append first(left) to result left = rest(left) else append first(right) to result right = rest(right) if length(left) > 0 append rest(left) to result if length(right) > 0 append rest(right) to result return result 另一处获得伪码 MergeSort(arr[], l, r) If r > l 1. Find the middle point to divide the array into two halves: middle m = (l+r)/2 2. Call mergeSort for first half: Call mergeSort(arr, l, m) 3. Call mergeSort for second half: Call mergeSort(arr, m+1, r) 4. Merge the two halves sorted in step 2 and 3: Call merge(arr, l, m, r) merge sort用在linked list上的好处是不用开辟空间，然后就处理node 用旧的代码拼装出来的结果 然后需要注意的一点是拆分链表，所以有设置left node 的tail为None的操作. class Solution(object): def sortList(self, head): \"\"\" :type head: ListNode :rtype: ListNode \"\"\" if head == None or head.next == None: return head mid = self.findMid(head) # split the l1 = head l2 = mid.next mid.next = None l1 = self.sortList(l1) l2 = self.sortList(l2) return self.mergeTwoLists(l1, l2) def mergeTwoLists(self, l1, l2): \"\"\" :type l1: ListNode :type l2: ListNode :rtype: ListNode \"\"\" if l1 == None: return l2 if l2 == None: return l1 dummy = ListNode(-1) cur = dummy while l1 and l2: if l1.val 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"150._evaluate_reverse_polish_notation.html":{"url":"150._evaluate_reverse_polish_notation.html","title":"150 evaluate reverse polish notation","keywords":"","body":"150. Evaluate Reverse Polish Notation 题目: https://leetcode.com/problems/evaluate-reverse-polish-notation/ 难度: Medium AC代码 class Solution(object): def evalRPN(self, tokens): \"\"\" :type tokens: List[str] :rtype: int \"\"\" def cal(op, op1, op2): if op == '*': return op1 * op2 elif op == '/': return op1 / float(op2) elif op == '+': return op1 + op2 else: return op1 - op2 operandStack = [] for token in tokens: if token in '+-*/': op2 = operandStack.pop() op1 = operandStack.pop() res = cal(token, op1, op2) operandStack.append(int(res)) else: operandStack.append(int(token)) return operandStack.pop() 实际上这里有一个很奇（sha）怪（bi）的地方，看到了么，除法➗处，如果我不这么做，就是错的，这是python 2 和 python 3 的除法不一致导致的，所以最终我这样做了才能得到正确答案。 思路： 已经给了我们wikipedia的链接了https://en.wikipedia.org/wiki/Reverse_Polish_notation While there are input tokens left Read the next token from input. If the token is a value Push it onto the stack. -Otherwise, the token is an operator (operator here includes both operators and functions). It is already known that the operator takes n arguments. If there are fewer than n values on the stack (Error) The user has not input sufficient values in the expression. Else, Pop the top n values from the stack. Evaluate the operator, with the values as arguments. Push the returned results, if any, back onto the stack. If there is only one value in the stack That value is the result of the calculation. Otherwise, there are more values in the stack (Error) The user input has too many values. 再参考这里 http://interactivepython.org/runestone/static/pythonds/BasicDS/InfixPrefixandPostfixExpressions.html Create an empty stack called operandStack. Convert the string to a list by using the string method split. Scan the token list from left to right. If the token is an operand, convert it from a string to an integer and push the value onto the operandStack. If the token is an operator, *, /, +, or -, it will need two operands. Pop the operandStack twice. The first pop is the second operand and the second pop is the first operand. Perform the arithmetic operation. Push the result back on the operandStack. When the input expression has been completely processed, the result is on the stack. Pop the operandStack and return the value. 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"151._reverse_words_in_a_string.html":{"url":"151._reverse_words_in_a_string.html","title":"151 reverse words in a string","keywords":"","body":"151. Reverse Words in a String 题目: https://leetcode.com/problems/reverse-words-in-a-string/ 难度: Medium 太简单了 class Solution(object): def reverseWords(self, s): \"\"\" :type s: str :rtype: str \"\"\" tmp = s.split() res = \" \".join(tmp[::-1]) return res class Solution(object): def reverseWords(self, s): \"\"\" :type s: str :rtype: str \"\"\" tmp = s.split() tmp.reverse() res = \" \".join(tmp) return res 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"152._maximum_product_subarray.html":{"url":"152._maximum_product_subarray.html","title":"152 maximum product subarray","keywords":"","body":"152. Maximum Product Subarray 题目: https://leetcode.com/problems/maximum-product-subarray/ 难度: Medium 思路： 粗一看， 一股浓烈的DP气息飘来，想要套用53题的思路和方程。但是这个跟sum是不一样的，因为乘积可以正负正负的跳，这样的动归方程肯定是不对的 dp[i] = max(dp[i-1] * a[i],a[i]) 举个例子 ： [-2,3,-4] 用O(N^2)超时,厉害啊！ 想，可不可以记录+的和-的，记录两个dp数组，我哭了，真的是这样做的 最大值可能来源于最小值 -> 哲学般的句子 class Solution(object): def maxProduct(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" n = len(nums) maxdp = [ nums[0] for i in range(n)] mindp = [ nums[0] for i in range(n)] for i in range(1,n): maxdp[i] = max(mindp[i-1]*nums[i], maxdp[i-1]*nums[i],nums[i]) mindp[i] = min(maxdp[i-1]*nums[i], mindp[i-1]*nums[i],nums[i]) return max(maxdp) 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"153._find_minimum_in_rotated_sorted_array.html":{"url":"153._find_minimum_in_rotated_sorted_array.html","title":"153 find minimum in rotated sorted array","keywords":"","body":"153. Find Minimum in Rotated Sorted Array 题目: https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/ 难度: Medium 思路一： O(N) 就不说了 思路二： 想的是分治，两段分别找出最小值，然后取最小值,但是依旧没有利用题目特性，并且也是O(N). We can do it in O(logn) using Binary Search. If we take a closer look at above examples, we can easily figure out following pattern: The minimum element is the only element whose previous element is greater than it. If there is no such element, then there is no rotation and first element is the minimum element. 上面提到了一个特性，就是minimum element唯一一个它之前的element比它大的，如果不存在这个element，那么就没有rotation. 思路其实是判断前半部分或者后半部分是否有序，然后来剔除，这里需要注意有比较多的边界case，因为如果就两个，那么会有特殊case 0 ,1 mid = 0,所以可以看一下，它这个处理，最后一个elif 是来比较mid 和 end class Solution(object): def findMin(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" def findRotatedMin(nums, start, end): if end start and nums[mid] 非递归 class Solution(object): def findMin(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" l,r = 0, len(nums) - 1 while l l and nums[mid] nums[mid+1]: return nums[mid+1] elif nums[mid] 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"155._min_stack.html":{"url":"155._min_stack.html","title":"155 min stack","keywords":"","body":"155. Min Stack 题目: https://leetcode.com/problems/min-stack/ 难度: Easy 思路一： 懒，直接用系统的数据结构 用lst和系统的heapq，提升一下，用deque和heapq,这样也没太大提升 from heapq import * class MinStack(object): def __init__(self): \"\"\" initialize your data structure here. \"\"\" self.lst = [] self.h = [] def push(self, x): \"\"\" :type x: int :rtype: void \"\"\" self.lst.append(x) heappush(self.h,x) def pop(self): \"\"\" :rtype: void \"\"\" val = self.lst.pop() self.h.remove(val) heapify(self.h) def top(self): \"\"\" :rtype: int \"\"\" return self.lst[-1] def getMin(self): \"\"\" :rtype: int \"\"\" return self.h[0] 思路二： 参考http://www.geeksforgeeks.org/design-and-implement-special-stack-data-structure/ 用两个stack，其中一个始终来记录到当前位置的最小值 When we insert 18, both stacks change to following. Actual Stack 18 这样无论是用deque还是本身的lst都有一些提升 from collections import deque class MinStack(object): def __init__(self): \"\"\" initialize your data structure here. \"\"\" self.lst = deque() self.aux = deque() def push(self, x): \"\"\" :type x: int :rtype: void \"\"\" self.lst.append(x) if not self.aux or self.aux[-1] > x: self.aux.append(x) else: self.aux.append(self.aux[-1]) def pop(self): \"\"\" :rtype: void \"\"\" self.lst.pop() self.aux.pop() def top(self): \"\"\" :rtype: int \"\"\" return self.lst[-1] def getMin(self): \"\"\" :rtype: int \"\"\" return self.aux[-1] 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"157._Read_N_Characters_Given_Read4.html":{"url":"157._Read_N_Characters_Given_Read4.html","title":"157 Read N Characters Given Read4","keywords":"","body":"157. Read N Characters Given Read4 最长有效括号 难度: Easy 刷题内容 原题连接 https://leetcode.com/problems/read-n-characters-given-read4/description/ 内容描述 The API: int read4(char *buf) reads 4 characters at a time from a file. The return value is the actual number of characters read. For example, it returns 3 if there is only 3 characters left in the file. By using the read4 API, implement the function int read(char *buf, int n) that reads n characters from the file. Example 1: Input: buf = \"abc\", n = 4 Output: \"abc\" Explanation: The actual number of characters read is 3, which is \"abc\". Example 2: Input: buf = \"abcde\", n = 5 Output: \"abcde\" Note: The read function will only be called once for each test case. 解题方案 思路 1 讨论区有很多人说这道题很sb，给的例子和代码里面的input数据类型不一样，其实我也很懵逼 然后我看到了这个解释，顿悟 It took me several hours to understand what the problem is talking about. Let's look at the very first sentence of the description, \"The API: int read4(char *buf) reads 4 characters at a time from a file.\" I though this function read a file, which is represented by *buf. But I was wrong. The correct understanding should be like this: this function reads a file, and writes the first 4 characters to *buf, and if there are less than 4 characters to be read, then only the valid number of characters will be read and written to *buf. Similarly, the function to be implemented, int read(char buf, int n) that reads n characters from the file, means n characters should be written to *buf. Also the examples are very misleading. Let's say example 1, Input: buf = \"abc\", n = 4 Output: \"abc\" Explanation: The actual number of characters read is 3, which is \"abc\". The input *buf is not \"abc\". The file to be read is \"abc\". The input, *buf , should be where the characters are written to. The output, is not the return value of read(buf, 4), but should be the actual characters in *buf after the function is called. And the return value should be an int, which is 3. Hope this clarification helps :) 总结一下，就是read4(*read4_buf)这个函数的意思就是从文件当中读4个字符并将其写入到read4_buf中去，返回值是实际读取到的字符个数，即如果文件中只剩3个（不到4个字符了） ，那么就只写3个字符到read4_buf中去，返回值是3 所以我们要实现的read(*buf)函数也是这样，我们要读取n个字符并写入到buf中去并且返回实际读取到的字符个数，如果不够我们就有多少写多少，然后返回实际写入的个数 那么现在我们有两种情况： n大于文件中的字符数，我们检测文件结束并停止读取并返回文件中的字符数。 n小于或等于文件中的字符数，当读取足够的字符时返回（即n） 代码中用eof代表'end of file' class Solution(object): def read(self, buf, n): \"\"\" :type buf: Destination buffer (List[str]) :type n: Maximum number of characters to read (int) :rtype: The number of characters read (int) \"\"\" if n == 0 : return 0 total_read, eof = 0, False while not eof: read4_buf = [''] * 4 cur_read = read4(read4_buf) if (cur_read 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"158._Read_N_Characters_Given_Read4_II_-_Call_multiple_times.html":{"url":"158._Read_N_Characters_Given_Read4_II_-_Call_multiple_times.html","title":"158 Read N Characters Given Read4 II - Call multiple times","keywords":"","body":"158. Read N Characters Given Read4 II - Call multiple times 难度: 困难 刷题内容 原题连接 https://leetcode.com/problems/read-n-characters-given-read4-ii-call-multiple-times/description/ 内容描述 The API: int read4(char *buf) reads 4 characters at a time from a file. The return value is the actual number of characters read. For example, it returns 3 if there is only 3 characters left in the file. By using the read4 API, implement the function int read(char *buf, int n) that reads n characters from the file. Note: The read function may be called multiple times. Example 1: Given buf = \"abc\" read(\"abc\", 1) // returns \"a\" read(\"abc\", 2); // returns \"bc\" read(\"abc\", 1); // returns \"\" Example 2: Given buf = \"abc\" read(\"abc\", 4) // returns \"abc\" read(\"abc\", 1); // returns \"\" 解题方案 思路 1 这个题目的描述就是一坨屎💩，真的，sb。 我来总结一下，跟第157题不一样的地方就是，157是就读一次，158是可以读好几次 例如： 文件是‘abcdefg’ 157题就读一次，给一个n就行了。n给1那buf就是‘a’, n给2那buf就是‘ab’ 但是158不一样，可以多次read，比如第一次n给1，那buf是‘a’，再read一次，n给2，那'a'已经读过了，所以现在buf是'bc'了， 如果再来个n=3的话，buf就是‘def’, 总之就是一个test case 中read函数可以调用一次和调用多次的区别 class Solution(object): head, tail, buffer = 0, 0, [''] * 4 ## 定义全局变量 def read(self, buf, n): \"\"\" :type buf: Destination buffer (List[str]) :type n: Maximum number of characters to read (int) :rtype: The number of characters read (int) \"\"\" i = 0 while i 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"159._Longest_Substring_with_At_Most_Two_Distinct_Characters.html":{"url":"159._Longest_Substring_with_At_Most_Two_Distinct_Characters.html","title":"159 Longest Substring with At Most Two Distinct Characters","keywords":"","body":"159. Longest Substring with At Most Two Distinct Characters 题目： https://leetcode.com/problems/longest-substring-with-at-most-two-distinct-characters/ 难度 : Hard class Solution(object): def lengthOfLongestSubstringTwoDistinct(self, s): \"\"\" :type s: str :rtype: int \"\"\" maps = {} begin, end, counter, length = 0, 0, 0, 0 while end 2: maps[s[begin]] -= 1 if maps[s[begin]] == 0: counter -= 1 begin += 1 length = max(length, end - begin) # 因此这里是```end - begin```而不是```end - begin + 1 return length ``` 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"160._intersection_of_two_linked_lists.html":{"url":"160._intersection_of_two_linked_lists.html","title":"160 intersection of two linked lists","keywords":"","body":"160. Intersection of Two Linked Lists 题目: https://leetcode.com/problems/intersection-of-two-linked-lists/ 难度: Easy 如果两个linkedlist有intersection的话，可以看到，其实如果一开始我们就走到b2的话，那么我们就可以两个pointer一个一个的对比，到哪一个地址一样，接下来就是intersection部分。 A: a1 → a2 ↘ c1 → c2 → c3 ↗ B: b1 → b2 → b3 比较巧妙的数学解法，看下面的解释和代码 AC代码如下: class Solution(object): def getIntersectionNode(self, headA, headB): \"\"\" :type head1, head1: ListNode :rtype: ListNode \"\"\" pA, pB = headA, headB while pA is not pB: pA = pA.next if pA else headB pB = pB.next if pB else headA return pA Just count the number of moves by each pointer before they meet. One pointer will traverse entire list1 for N moves and then jump to the head of list1 to move (M-K) steps to intersection, where K represents the length of common part. Now the other pointer must also moved the same number of steps since they are both moved at the same time. The second pointer traverses the entire list2 for M steps and jumped to the head of list1 to move (N-K) steps. So the loop finished with M+N-K times. 详见zzg_zzm的评论 This algorithm is sooooo perfect! I was wonder if the running time is O(n+m), but later I figured out that the actually running time is just: m+n for non-intersection case With intersection: Suppose for LL-A, it’s a+b=n, a is the # of nodes before intersection Suppose for LL-B, it’s c+b=m, c is the # of nodes before intersection Thus the actual running time is a+b+c = n+c = m+a. Actually, when b=0, this just stands for the case with no intersection with a+b+c=n+m 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"162._find_peak_element.html":{"url":"162._find_peak_element.html","title":"162 find peak element","keywords":"","body":"162. Find Peak Element 题目: https://leetcode.com/problems/find-peak-element/ 难度: Medium 思路： 最直观的是O(N)解法 class Solution(object): def findPeakElement(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" for i in range(1, len(nums)): if nums[i] O(lgN) 解法 这是一个经典题目 a[mid] a[mid] else peak found 证明就是用反证法，或者看peak，因为这里已经限制了num[i] ≠ num[i+1]，所以peak element 一定存在。然后a[mid] 写到这里，我非常相信就是binary search能写对其实不容易。 AC代码 class Solution(object): def findPeakElement(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" l, r = 0, len(nums) - 1 while l > 2) if nums[mid] 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"165._compare_version_numbers.html":{"url":"165._compare_version_numbers.html","title":"165 compare version numbers","keywords":"","body":"165. Compare Version Numbers 题目: https://leetcode.com/problems/compare-version-numbers/ 难度: Easy 其实我并不觉得这个很简单 因为可能两个的位数不一样，首端或者尾端需要补0，同时我还考虑过可能有出现多个'.'的状况 class Solution(object): def compareVersion(self, version1, version2): \"\"\" :type version1: str :type version2: str :rtype: int \"\"\" v1 = version1.split('.') v2 = version2.split('.') v1 = [int(x) for x in v1] v2 = [int(x) for x in v2] len1 = len(v1) len2 = len(v2) lenMax = max(len1, len2) for x in range(lenMax): v1Token = 0 if x v2Token: return 1 elif v1Token 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"166._Fraction_to_Recurring_Decimal.html":{"url":"166._Fraction_to_Recurring_Decimal.html","title":"166 Fraction to Recurring Decimal","keywords":"","body":"166. Fraction to Recurring Decimal 题目: https://leetcode.com/problems/fraction-to-recurring-decima/ 难度: Medium class Solution: # @return a string def fractionToDecimal(self, n, d): res = '' if n == 0: # zero numerator return str(n) if (n 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"167._two_sum_ii_-_input_array_is_sorted.html":{"url":"167._two_sum_ii_-_input_array_is_sorted.html","title":"167 two sum ii - input array is sorted","keywords":"","body":"167. Two Sum II - Input array is sorted 题目: https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/ 难度: Medium 思路： 双指针 class Solution(object): def twoSum(self, numbers, target): \"\"\" :type numbers: List[int] :type target: int :rtype: List[int] \"\"\" l, r = 0, len(numbers) - 1 while l target: r -= 1 else: l += 1 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"168._excel_sheet_column_title.html":{"url":"168._excel_sheet_column_title.html","title":"168 excel sheet column title","keywords":"","body":"168. Excel Sheet Column Title 题目: https://leetcode.com/problems/excel-sheet-column-title/ 难度: Easy 依旧26进制的反击，不过这个反击我做的没之前那个好，看了hint class Solution(object): def convertToTitle(self, n): \"\"\" :type n: int :rtype: str \"\"\" ans = '' while n : ans = chr(ord('A') + (n - 1) % 26) + ans n = (n - 1) // 26 return ans 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"169._majority_element.html":{"url":"169._majority_element.html","title":"169 majority element","keywords":"","body":"169. Majority Element 题目: https://leetcode.com/problems/majority-element/ 难度: Easy 思路： 其实这个我有点有想到过 给定一个长度为 n的数组,其中有一个数，它出现的次数大于⎣n/2⎦，称为主要元素，找到它. 这个很像之前做过的一道CLRS的题目，想法可以用divide & conquer. 如果数组长度 如果长度 > 2，那么可以两两配对，对于配对一样的结果，删去 如果最后余一个，这一个留下 shuffle之后再尝试两两配对，直到最后结果不再改变 这样肯定是能解决问题的，因为为了满足次数大于⎣n/2⎦这个条件。 1 2 1 2 1 2 1 2 2 3 2 3 2 3 2 3 2 4 2 2 2 2 3 2 4 2 3 3 3 2 2 2 2 2 思路容易implement非常难啊. 这个问题有一个很出名的算法 Boyer-Moore众数(majority number) 问题 在数组中找到两个不相同的元素并删除它们，不断重复此过程，直到数组中元素都相同，那么剩下的元素就是主要元素。 这个算法的妙处在于不直接删除数组中的元素，而是利用一个计数变量. 伪码 def majorityElement(self, nums): count,major=0,0 for n in nums: if count==0: major=n if major==n: count+=1 else: count-=1 return major 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"171._excel_sheet_column_number.html":{"url":"171._excel_sheet_column_number.html","title":"171 excel sheet column number","keywords":"","body":"171. Excel Sheet Column Number 题目: https://leetcode.com/problems/excel-sheet-column-number/ 难度: Easy 26进制的反击 class Solution(object): def titleToNumber(self, s): \"\"\" :type s: str :rtype: int \"\"\" maps = {} for i in range(65,91): maps[chr(i)] = i - 64 lst = list(s) lst.reverse() num = 0 for idx,item in enumerate(lst): num += maps[item] * (26 ** idx) return num 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"173._binary_search_tree_iterator.html":{"url":"173._binary_search_tree_iterator.html","title":"173 binary search tree iterator","keywords":"","body":"173. Binary Search Tree Iterator 题目: https://leetcode.com/problems/binary-search-tree-iterator/ 难度: Medium 同样没有听题目要求，一开始就取巧，用InOrder，这样得到BSF有序排列，然后使用 class BSTIterator(object): def __init__(self, root): \"\"\" :type root: TreeNode \"\"\" self.root = root self.lst = [] self.inOrder(root) self.lst.reverse() def hasNext(self): \"\"\" :rtype: bool \"\"\" return self.lst != [] def next(self): \"\"\" :rtype: int \"\"\" return self.lst.pop() def inOrder(self, root): if root == None: return self.inOrder(root.left) self.lst.append(root.val) self.inOrder(root.right) 谷歌了一下，得到如何满足题目要求的hint，从root开始，往左走，把左孩子压入stack，直到左边为空。 然后开始取node，如果node有右孩子，则同样要把node的右孩子的所有左孩子全部append入stack，画了一个图，可行。 class BSTIterator(object): def __init__(self, root): \"\"\" :type root: TreeNode \"\"\" self.root = root self.stack = [] self.pushAllLeft(root) def hasNext(self): \"\"\" :rtype: bool \"\"\" return self.stack != [] def next(self): \"\"\" :rtype: int \"\"\" if self.hasNext(): cur = self.stack.pop() if cur.right: self.pushAllLeft(cur.right) return cur.val def pushAllLeft(self, node): \"\"\" :type node: TreeNode \"\"\" cur = node while cur: self.stack.append(cur) cur = cur.left 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"179._Largest_Number.html":{"url":"179._Largest_Number.html","title":"179 Largest Number","keywords":"","body":"179. Largest Number 题目: https://leetcode.com/problems/largest-number/ 难度: Medium 思路 先排序，再合并，若最后为空字符串，则返回'0' 其中排序思想为字符串的经典比较： \"\"\" Replacement for built-in funciton cmp that was removed in Python 3 Compare the two objects x and y and return an integer according to the outcome. The return value is negative if x y. \"\"\" class Solution(object): def largestNumber(self, nums): \"\"\" :type nums: List[int] :rtype: str \"\"\" nums = [str(num) for num in nums] nums.sort(cmp=lambda x, y: cmp(y+x, x+y)) return ''.join(nums).lstrip('0') if ''.join(num).lstrip('0') else '0' 或者更简单一点 class Solution(object): def largestNumber(self, nums): \"\"\" :type nums: List[int] :rtype: str \"\"\" nums = [str(num) for num in nums] nums.sort(cmp=lambda x, y: cmp(y+x, x+y)) return ''.join(nums).lstrip('0') or '0' 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"182._duplicate_emails.html":{"url":"182._duplicate_emails.html","title":"182 duplicate emails","keywords":"","body":"182. duplicate-emails 查找重复的电子邮箱 难度: Easy 刷题内容 原题连接 https://leetcode.com/problems/duplicate-emails https://leetcode-cn.com/problems/duplicate-emails/description 内容描述 编写一个 SQL 查询，查找 Person 表中所有重复的电子邮箱。 示例： +----+---------+ | Id | Email | +----+---------+ | 1 | a@b.com | | 2 | c@d.com | | 3 | a@b.com | +----+---------+ 根据以上输入，你的查询应返回以下结果： +---------+ | Email | +---------+ | a@b.com | +---------+ 说明：所有电子邮箱都是小写字母。 解题方案 思路 1 select Email from Person group by Email having count(1)>1 或者 select Email from Person group by Email having count(Email) > 1 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"189._rotate_array.html":{"url":"189._rotate_array.html","title":"189 rotate array","keywords":"","body":"189. Rotate Array 题目： https://leetcode.com/problems/rotate-array/ 难度 : Easy 首先，要知道一点，k如果大于nums的长度了，那么其实进行 k % len(nums) 次就行了 其次，要注意k 为0的情况 class Solution(object): def rotate(self, nums, k): \"\"\" :type nums: List[int] :type k: int :rtype: void Do not return anything, modify nums in-place instead. \"\"\" k = k % len(nums) if k != 0: tmp = nums[-k:] for j in range(len(nums)-1, k-1, -1): nums[j] = nums[j-k] nums[:k] = tmp 还有作弊大法，贼🐂批 class Solution(object): def rotate(self, nums, k): \"\"\" :type nums: List[int] :type k: int :rtype: void Do not return anything, modify nums in-place instead. \"\"\" k %= len(nums) nums[:] = nums[-k:] + nums[:-k] 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"191._number_of_1_bits.html":{"url":"191._number_of_1_bits.html","title":"191 number of 1 bits","keywords":"","body":"191. Number of 1 Bits 题目: https://leetcode.com/problems/number-of-1-bits/ 难度: Easy 转成二进制，数1的个数 class Solution(object): def hammingWeight(self, n): \"\"\" :type n: int :rtype: int \"\"\" return bin(n).count('1') 有wikipedia的题目 Hamming Weight) 用wikipedia的解法： 原理是在于每次使用x & x-1 总会把低位的数字给置0 比如 3 = 011 2 = 010 3 & 2 = 010 cnt =1 ​ 2 = 010 1 = 001 2 & 1 = 000 cnt = 2 比如 9 = 1001 8 = 1000 9&8 = 1000 cnt =1 ​ 8 = 1000 7 = 0111 8&7 = 0000 cnt = 2 减1操作将最右边的符号从0变到1，从1变到0，与操作将会移除最右端的1。如果最初X有N个1，那么经过N次这样的迭代运算，X将减到0。下面的算法就是根据这个原理实现的。 所以关键点是每次都会把最右边的1变成0. AC代码 class Solution(object): def hammingWeight(self, n): \"\"\" :type n: int :rtype: int \"\"\" cnt = 0 while n != 0: n &= n - 1 cnt += 1 return cnt 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"198._house_robber.html":{"url":"198._house_robber.html","title":"198 house robber","keywords":"","body":"198. House Robber 题目: https://leetcode.com/problems/house-robber/ 难度: Easy 状态转移方程: dp[i] = max(dp[i-1], dp[i-2] + nums[i]) AC 代码 class Solution(object): def rob(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" n = len(nums) if n == 0 : return 0 elif n == 1 : return nums[0] elif n == 2 : return max(nums[0], nums[1]) else: dp = [0 for i in range(n)] dp[0] = nums[0] dp[1] = max(nums[0],nums[1]) for i in range(2,n): dp[i] = max( dp[i-1], dp[i-2] + nums[i]) return dp[n-1] class Solution(object): def rob(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" last, now = 0, 0 for i in nums: last, now = now, max(last + i, now) return now 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"199._binary_tree_right_side_view.html":{"url":"199._binary_tree_right_side_view.html","title":"199 binary tree right side view","keywords":"","body":"199. Binary Tree Right Side View 题目: https://leetcode.com/problems/binary-tree-right-side-view/ 难度: Medium 还是在玩第102题，level order traversal. class Solution(object): def rightSideView(self, root): \"\"\" :type root: TreeNode :rtype: List[int] \"\"\" if root == None: return [] res = [] curLevel = [root] while curLevel: nextLevel = [] tmpRes = [] for node in curLevel: tmpRes.append(node.val) if node.left: nextLevel.append(node.left) if node.right: nextLevel.append(node.right) res.append(tmpRes[-1]) curLevel = nextLevel return res 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"200._number_of_islands.html":{"url":"200._number_of_islands.html","title":"200 number of islands","keywords":"","body":"200. Number of Islands 题目: https://leetcode.com/problems/number-of-islands/ 难度: Medium 思路： 一开始： numberOfIslands = 0 islandArea = [] 然后遇到（x,y） = 1的状况，更新numberOfIslands，并且把（x,y）放入islandArea，然后用BFS或者DFS查找岛屿范围，全部更如islandArea，做loop 以上就是基本思路 然后超时|||, 小改之后AC class Solution(object): def numIslands(self, grid): \"\"\" :type grid: List[List[str]] :rtype: int \"\"\" self.grid = grid[:] self.row = len(self.grid) self.col = len(self.grid[0]) if self.row else 0 self.visited = [[0 for i in range(self.col)]for j in range(self.row)] self.numberOfIslands = 0 for i in range(self.row): for j in range(self.col): if self.grid[i][j] == '1' and self.visited[i][j] == 0: self.findArea(i,j) self.numberOfIslands += 1 return self.numberOfIslands def findArea(self, i, j): s = [] s.append((i,j)) while s: (x,y) = s.pop() self.visited[x][y] = 1 if self.legal(x-1,y): s.append((x-1,y)) if self.legal(x+1,y): s.append((x+1,y)) if self.legal(x,y-1): s.append((x,y-1)) if self.legal(x,y+1): s.append((x,y+1)) def legal(self,x,y): return x>= 0 and x = 0 and y 看了别人的代码，写的真美 ╮(╯_╰)╭ 啊 class Solution(object): def numIslands(self, grid): \"\"\" :type grid: List[List[str]] :rtype: int \"\"\" def dfs(gird, used, row, col, x, y): if gird[x][y] == '0' or used[x][y]: return used[x][y] = True if x!= 0: dfs(grid, used, row,col, x-1,y) if x!= row -1 : dfs(grid, used, row,col, x+1, y) if y!= 0: dfs(grid, used, row,col, x, y-1) if y!= col - 1: dfs(grid, used, row,col, x, y+1) row = len(grid) col = len(grid[0]) if row else 0 used = [[0 for i in xrange(col)] for i in xrange(row)] count = 0 for i in xrange(row): for j in xrange(col): if grid[i][j] == '1' and not used[i][j]: dfs(grid,used,row,col,i,j) count += 1 return count 厉害的解法：Sink and count the islands. class Solution(object): def numIslands(self, grid): \"\"\" :type grid: List[List[str]] :rtype: int \"\"\" def sink(i, j): if 0 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"203._remove_linked_list_elements.html":{"url":"203._remove_linked_list_elements.html","title":"203 remove linked list elements","keywords":"","body":"203. Remove Linked List Elements 题目: https://leetcode.com/problems/remove-linked-list-elements/ 难度: Easy AC代码如下: class Solution(object): def removeElements(self, head, val): \"\"\" :type head: ListNode :type val: int :rtype: ListNode \"\"\" dummy = ListNode(-1) dummy.next = head cur = dummy while cur.next: if cur.next.val == val: cur.next = cur.next.next else: cur = cur.next return dummy.next 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"204._count_primes.html":{"url":"204._count_primes.html","title":"204 count primes","keywords":"","body":"204. Count Primes 题目: https://leetcode.com/problems/count-primes/ 难度: Easy 这个题的hint是已经把算法喂到嘴边了 https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes Input: an integer n > 1 Let A be an array of Boolean values, indexed by integers 2 to n, initially all set to true. for i = 2, 3, 4, ..., not exceeding √n: if A[i] is true: for j = i^2, i^2+i, i^2+2*i, i^2+3i, ..., not exceeding n : A[j] := false Output: all i such that A[i] is true. python算法 class Solution(object): def countPrimes(self, n): \"\"\" :type n: int :rtype: int \"\"\" isPrime = [1 for i in range(n)] i = 2 while i * i 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"205._isomorphic_strings.html":{"url":"205._isomorphic_strings.html","title":"205 isomorphic strings","keywords":"","body":"205. Isomorphic Strings 题目： https://leetcode.com/problems/isomorphic-strings/ 难度 : Easy AC之法，用dictionary，因为限制，所以确保s 和 t 是isomorphic 同时 t 和 s 是 class Solution(object): def isIsomorphic(self, s, t): \"\"\" :type s: str :type t: str :rtype: bool \"\"\" return self.iso(s,t) and self.iso(t,s) def iso(self,s, t): \"\"\" :type s: str :type t: str :rtype: bool \"\"\" mapx = {} for i in range(len(s)): if s[i] not in mapx: mapx[s[i]] = t[i] elif s[i] in mapx: if t[i] != mapx[s[i]]: return False return True 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"206._reverse_linked_list.html":{"url":"206._reverse_linked_list.html","title":"206 reverse linked list","keywords":"","body":"206. Reverse Linked List 题目: https://leetcode.com/problems/reverse-linked-list/ 难度: Easy 用三个指针，分别指向prev，cur 和 nxt，然后loop一圈还算比较简单. class Solution(object): def reverseList(self, head): \"\"\" :type head: ListNode :rtype: ListNode \"\"\" prev = None cur = head while(cur): nxt = cur.next cur.next = prev prev = cur cur = nxt return prev 其实一个指针就够了 class Solution(object): def reverseList(self, head): \"\"\" :type head: ListNode :rtype: ListNode \"\"\" if not head: return head prev = None while head.next: tmp = head.next head.next = prev prev = head head = tmp head.next = prev return head 递归版本，可以再消化一下. class Solution(object): def reverseList(self, head): \"\"\" :type head: ListNode :rtype: ListNode \"\"\" return self.reverseHelper(head, None) def reverseHelper(self, head, new_head): if not head: return new_head nxt = head.next head.next = new_head return self.reverseHelper(nxt, head) 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"207._course_schedule.html":{"url":"207._course_schedule.html","title":"207 course schedule","keywords":"","body":"207. Course Schedule 题目: https://leetcode.com/problems/course-schedule/ 难度: Medium 思路： 就是考topological sort，用来判断directed graph是否有cycle DFS 和 BFS都可以用来拓扑排序。 最简单的想法是每次取出indegree是0的node，然后把它和与之相关的edge都删了。一开始觉得这样的时间复杂度会很高，然后看到了这样写，参照： http://bookshadow.com/weblog/2015/05/07/leetcode-course-schedule/ 很聪明的写法 这里做了转成set以及添加removeList这样的操作是因为边list边做iterator这样的操作很危险 class Solution(object): def canFinish(self, numCourses, prerequisites): \"\"\" :type numCourses: int :type prerequisites: List[List[int]] :rtype: bool \"\"\" degrees = [ 0 for i in range(numCourses)] childs = [[] for i in range(numCourses)] for front, tail in prerequisites: degrees[front] += 1 childs[tail].append(front) courses = set(range(numCourses)) flag = True while flag and len(courses): flag = False removeList = [] for x in courses: if degrees[x] == 0: for child in childs[x]: degrees[child] -= 1 removeList.append(x) flag = True for x in removeList: courses.remove(x) return len(courses) == 0 因为CLRS里面明确提到涂色法来处理DFS 搞了半天，写了一个涂色法，在超时的边缘。之所以超时边缘是因为每次都要去prerequisites里看，没有删减，不高效. class Solution(object): def canFinish(self, numCourses, prerequisites): \"\"\" :type numCourses: int :type prerequisites: List[List[int]] :rtype: bool \"\"\" def dfs(i, colors, prerequisites): colors[i] = 'G' #print i, colors for front, tail in prerequisites: if tail == i: if colors[front] == 'G': return False elif colors[front] == 'B': continue elif dfs(front, colors, prerequisites) == False: return False colors[i] = 'B' return True colors = ['W' for i in range(numCourses)] for i in range(numCourses): if colors[i] == 'W': if dfs(i, colors, prerequisites) == False: return False return True 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"210._course_schedule_ii.html":{"url":"210._course_schedule_ii.html","title":"210 course schedule ii","keywords":"","body":"210. Course Schedule II 题目: https://leetcode.com/problems/course-schedule-ii/ 难度: Medium 思路： 在207的基础上加了order，进击 class Solution(object): def findOrder(self, numCourses, prerequisites): \"\"\" :type numCourses: int :type prerequisites: List[List[int]] :rtype: List[int] \"\"\" degrees = [ 0 for i in range(numCourses)] childs = [[] for i in range(numCourses)] for front, tail in prerequisites: degrees[front] += 1 childs[tail].append(front) courses = set(range(numCourses)) flag = True order = [] while flag and len(courses): flag = False removeList = [] for x in courses: if degrees[x] == 0: print x for child in childs[x]: degrees[child] -= 1 removeList.append(x) order.append(x) flag = True for x in removeList: courses.remove(x) if len(courses) == 0: return order else: return [] 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"211._Add_and_Search_Word_-_Data_structure_design.html":{"url":"211._Add_and_Search_Word_-_Data_structure_design.html","title":"211 Add and Search Word - Data structure design","keywords":"","body":"211. Add and Search Word - Data structure design 题目: https://leetcode.com/problems/add-and-search-word-data-structure-design/ 难度： Medium 思路： trie也是树，那么dfs/bfs同样适用。 实际上是照抄208trie的题目再加上dfs AC代码 class TrieNode(object): \"\"\"docstring for TrieNode\"\"\" def __init__(self): self.childs = dict() self.isWord = False class WordDictionary(object): def __init__(self): \"\"\" initialize your data structure here. \"\"\" self.root = TrieNode() def addWord(self, word): \"\"\" Adds a word into the data structure. :type word: str :rtype: void \"\"\" node = self.root for letter in word: child = node.childs.get(letter) if child is None: child = TrieNode() node.childs[letter] = child node = child node.isWord = True def search(self, word): \"\"\" Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter. :type word: str :rtype: bool \"\"\" def dfs(root, word): if len(word) == 0: return root.isWord elif word[0] == '.': for node in root.childs: if dfs(root.childs[node], word[1:]): return True return False else: node = root.childs.get(word[0]) if node is None: return False return dfs(node, word[1:]) return dfs(self.root, word) 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"213._house_robber_ii.html":{"url":"213._house_robber_ii.html","title":"213 house robber ii","keywords":"","body":"213. House Robber II 题目: https://leetcode.com/problems/house-robber-ii/ 难度: Medium 思路： 跟house robber 1 类似，但是加了一些限制，抢到第 n-1 家最大两种可能，抢第 n-1 家和不抢第 n-1 家。 0， 1， 2， 3， 4， 5， 6 ... n-1 所以状态转移方程写成二维的更好来求，从第i家抢到第j家的状态转移方程 nums[j] ,j = i dp[i][j] = max(nums[i], nums[i+1]) , j = i +1 max(dp[i][j-2] + nums[j], dp[i][j-1]), j > i+1 Show me the code AC代码 class Solution(object): def rob(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" n = len(nums) if n == 0 : return 0 if n == 1 : return nums[0] if n == 2 : return max(nums[0],nums[1]) dp = [[0 for i in range(n)] for j in range(n)] for i in range(n): for j in range(i,n): if j == i: dp[i][j] = nums[j] elif j == i + 1: dp[i][j] = max(nums[i],nums[i+1]) else: dp[i][j] = max(dp[i][j-2] + nums[j], dp[i][j-1]) # print dp # rob without n-1, or rob with n-1 val = max(dp[0][n-2], dp[1][n-3] + nums[n-1]) return val 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"216._combination_sum_iii.html":{"url":"216._combination_sum_iii.html","title":"216 combination sum iii","keywords":"","body":"216. Combination Sum III 题目: https://leetcode.com/problems/combination-sum-iii/ 难度: Medium 继续Combination Sum 系列 class Solution(object): def combinationSum3(self, k, n): \"\"\" :type k: int :type n: int :rtype: List[List[int]] \"\"\" candidates = [1,2,3,4,5,6,7,8,9] self.res = [] self.combSum(candidates, n, [], k) return self.res def combSum(self,candidates, target, valueList, k): if target == 0 and k == 0: self.res.append(valueList) length = len(candidates) if length == 0 or k target: return self.combSum(candidates[i+1:], target - candidates[i], valueList + [candidates[i]], k-1) 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"217._contains_duplicate.html":{"url":"217._contains_duplicate.html","title":"217 contains duplicate","keywords":"","body":"217. Contains Duplicate 难度: 简单 刷题内容 原题连接 https://leetcode.com/problems/contains-duplicate/ 内容描述 Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct. Example 1: Input: [1,2,3,1] Output: true Example 2: Input: [1,2,3,4] Output: false Example 3: Input: [1,1,1,3,3,4,3,2,4,2] Output: true 解题方案 思路 1 利用set怎么可以这么简单。。。。 class Solution(object): def containsDuplicate(self, nums): \"\"\" :type nums: List[int] :rtype: bool \"\"\" return len(nums) != len(set(nums)) 思路 2 或者先 sort 也可以 class Solution(object): def containsDuplicate(self, nums): \"\"\" :type nums: List[int] :rtype: bool \"\"\" nums.sort() for i in range(len(nums)-1): if nums[i] == nums[i+1]: return True return False 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"218._The_Skyline_Problem.html":{"url":"218._The_Skyline_Problem.html","title":"218 The Skyline Problem","keywords":"","body":"218. The Skyline Problem 题目: https://leetcode.com/problems/The-Skyline-Problem/ 难度: Hard 思路 观察发现，skyline的points的横坐标一定是某个building的左边界或者右边界。 开始，假设只有2个建筑物，拿出第一个buiding B1，我们先把它的左上顶点加进我们的output结果skyline中，然后继续拿下一个building B2，我们现在需要将B2的左上顶点对应的x coordinate与B1的右上顶点所对应的x coordinate做比较： 如果前者小且B2的高度大于B1的高度，则我们将B2的左上顶点也加入skyline中去。 如果前者小且B2的高度小于等于B1的高度，则忽略B2的左上顶点 接下来考虑更多建筑物的情况，从左到右扫描，当我们遇到第一个楼的左边界时，把它push到一个heap中。如果后面扫描的楼的高度比heap中最高的楼还高，那么它的左上顶点一定会被加入到skyline中。当我们遇到一个building的右边界时,我们需要将其从heap中pop掉，如果heap中max height有变化，则push到结果中。 参考Brian Gordon的blog 和 Stefan大神的题解 程序代码解释 liveBuildings代表（左上顶点已经被加入output中但右上顶点还没有做判断的building）的右上顶点的集合，形式为[(height, x-coordinate)…..] skyline是output 程序里面的这句代码while idx 是为了防止有左右坐标完全相同但是height不同的building的存在，it's not useless!!! python里面的heapq模块如果有不懂的同学可以看看这个文章：heapq class Solution(object): def getSkyline(self, buildings): \"\"\" :type buildings: List[List[int]] :rtype: List[List[int]] \"\"\" idx, n = 0, len(buildings) liveBuildings, skyline = [], [] while idx 0: # 只要所有的点没处理完就一直循环 if len(liveBuildings) == 0 or (idx 0 and -liveBuildings[0][1] 另外还有一个超级6的大神的代码，但是今天我要赶报告，就只先贴代码了 class Solution(object): def getSkyline(self, buildings): \"\"\" :type buildings: List[List[int]] :rtype: List[List[int]] \"\"\" events = sorted([(L, -H, R) for L, R, H in buildings] + list(set((R, 0, None) for L, R, H in buildings))) #events = sorted(event for L, R, H in buildings for event in ((L, -H, R), (R, 0, None))) res, hp = [[0, 0]], [(0, float(\"inf\"))] for x, negH, R in events: while x >= hp[0][1]: heapq.heappop(hp) if negH: heapq.heappush(hp, (negH, R)) if res[-1][1] + hp[0][0]: res += [x, -hp[0][0]], return res[1:] public class Solution { public List getSkyline(int[][] buildings) { List result = new ArrayList(); if (buildings == null || buildings.length == 0 || buildings[0].length == 0) { return result; } List heights = new ArrayList(); for (int[] building : buildings) { heights.add(new Height(building[0], -building[2])); heights.add(new Height(building[1], building[2])); } Collections.sort(heights, new Comparator() { @Override public int compare(Height h1, Height h2) { return h1.index != h2.index ? h1.index - h2.index : h1.height - h2.height; } }); PriorityQueue pq = new PriorityQueue(1000, Collections.reverseOrder()); pq.offer(0); int prev = 0; for (Height h : heights) { if (h.height Author: Keqi Huang If you like it, please spread your support 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"219._contains_duplicate_ii.html":{"url":"219._contains_duplicate_ii.html","title":"219 contains duplicate ii","keywords":"","body":"219. Contains Duplicate II 难度: 简单 刷题内容 原题连接 https://leetcode.com/problems/contains-duplicate-ii/ 内容描述 Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k. Example 1: Input: nums = [1,2,3,1], k = 3 Output: true Example 2: Input: nums = [1,0,1,1], k = 1 Output: true Example 3: Input: nums = [1,2,3,1,2,3], k = 2 Output: false 解题方案 思路 1 这道题虽然看似简单，但是我还是经历几次失败 第一次我打算用最粗暴的方法来做，直接 Time Limit Exceeded，代码如下： class Solution(object): def containsNearbyDuplicate(self, nums, k): \"\"\" :type nums: List[int] :type k: int :rtype: bool \"\"\" if k == 0: return False if k >= len(nums): return len(nums) != len(set(nums)) for i in range(len(nums)-k): for j in range(1, k+1): if nums[i] == nums[i+j]: return True for i in range(len(nums)-k, len(nums)): for j in range(i+1, len(nums)): if nums[i] == nums[j]: return True return False 然后我打算用第 217 题的方法来一遍，还是报 Time Limit Exceeded 这个错，代码如下L： class Solution(object): def containsNearbyDuplicate(self, nums, k): \"\"\" :type nums: List[int] :type k: int :rtype: bool \"\"\" if k == 0: return False if k >= len(nums): return len(nums) != len(set(nums)) for i in range(len(nums)-k): if len(nums[i:i+k+1]) != len(set(nums[i:i+k+1])): return True return len(nums[-k:]) != len(set(nums[-k:])) 终于我想到了用字典来存，这个元素还没出现过，就以 的形式存进字典里，如果 num 再次出现了，计算相邻距离，小于等于 k 则 return true，否则更新字典中元素的位置， class Solution(object): def containsNearbyDuplicate(self, nums, k): \"\"\" :type nums: List[int] :type k: int :rtype: bool \"\"\" lookup = {} for i in range(len(nums)): if nums[i] not in lookup: lookup[nums[i]] = i else: if i - lookup[nums[i]] 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"221._maximal_square.html":{"url":"221._maximal_square.html","title":"221 maximal square","keywords":"","body":"221. Maximal Square 题目: https://leetcode.com/problems/maximal-square/ 难度: Medium tag： DP 递推公式，一开始想的很简单： dp[i][j] = dp[i-1][j-1] + 1 #如果dp[i-1][j-1]为1，dp[i-1][j]为1，dp[i][j-1]为1 很明显的错误，一旦遇到更大的方块就会有问题 然后看了hint，其实递推方程式是很有技巧的，左上角，左边，上面，相邻的三个部分最小的+1,当然，前提也是要这里dp[i][j] 为1，然后我们再会去看其他的部分。 看个例子 原本的matrix DP 1 0 1 0 0 1 0 1 0 0 1 0 1 1 1 → 1 0 1 1 1 1 1 1 1 1 1 1 1 2 2 1 0 0 1 0 1 0 0 1 0 是非常make sense的，因为最小的必定包括了周边的1，然后再加1，否则如果是0的话那么就为0. 而naïve的错误的递推公式是因为一个square考虑的部分是k k的部分， k k 部分都必定为1. 而正确的递推公式 dp[i][j] = min(dp[i-1][j-1],dp[i-1][j],dp[i][j-1]) + 1 则完美的考虑了这一情况 class Solution(object): def maximalSquare(self, matrix): \"\"\" :type matrix: List[List[str]] :rtype: int \"\"\" dp = [] for i in matrix: tmp = [] for j in i: tmp.append(int(j)) dp.append(tmp) row = len(dp) col = len(dp[0]) if row else 0 for i in range(1,row): for j in range(1,col): if dp[i][j] == 1: dp[i][j] = min(dp[i-1][j-1],dp[i-1][j],dp[i][j-1]) + 1 maxv = 0 for i in range(row): for j in range(col): if dp[i][j] > maxv: maxv = dp[i][j] return maxv * maxv 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"222._count_complete_tree_nodes.html":{"url":"222._count_complete_tree_nodes.html","title":"222 count complete tree nodes","keywords":"","body":"222. Count Complete Tree Nodes 题目: https://leetcode.com/problems/count-complete-tree-nodes/ 难度: Medium 思路： 思路一： 超时，跟一般的树一样，递归的来数nodes数 class Solution(object): def countNodes(self, root): \"\"\" :type root: TreeNode :rtype: int \"\"\" if root == None: return 0 if root.left == None and root.right == None: return 1 return 1 + self.countNodes(root.left) + self.countNodes(root.right) 思路二：既然说了是 complete binary tree，那么必然有特性可用，complete binary tree的特性是除了最后一层，之前的就是perfect tree. 所以寻找左子树的最左边的高度和右子树的最右边的node高度，如果相同就是perfect tree，高度2^h - 1， 否则递归的来看左子树和右子树 class Solution(object): def countNodes(self, root): \"\"\" :type root: TreeNode :rtype: int \"\"\" if root == None: return 0 p, q = root,root leftHeight = 0 rightHeight = 0 while p: p = p.left leftHeight += 1 while q: q = q.right rightHeight += 1 if leftHeight == rightHeight: return (int)(math.pow(2,leftHeight) - 1) else: return 1 + self.countNodes(root.left) + self.countNodes(root.right) 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"223._rectangle_area.html":{"url":"223._rectangle_area.html","title":"223 rectangle area","keywords":"","body":"223. Rectangle Area 难度: 中等 刷题内容 原题连接 https://leetcode.com/problems/rectangle-area/description/ 内容描述 Find the total area covered by two rectilinear rectangles in a 2D plane. Each rectangle is defined by its bottom left corner and top right corner as shown in the figure. Rectangle Area Example: Input: A = -3, B = 0, C = 3, D = 4, E = 0, F = -1, G = 9, H = 2 Output: 45 Note: Assume that the total area is never beyond the maximum possible value of int. 解题方案 思路 1 sb题没什么好说的 class Solution(object): def computeArea(self, A, B, C, D, E, F, G, H): \"\"\" :type A: int :type B: int :type C: int :type D: int :type E: int :type F: int :type G: int :type H: int :rtype: int \"\"\" return (C - A) * (D - B) + (H - F) * (G - E) - max(min(C, G) - max(A, E), 0) * max(min(D, H) - max(B, F), 0) 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"224._Basic_Calculator.html":{"url":"224._Basic_Calculator.html","title":"224 Basic Calculator","keywords":"","body":"224. Basic Calculator 题目: https://leetcode.com/problems/basic-calculator/ 难度: Medium 思路： 基本跟227一样，只是这里加了括号 瞄了一眼，基本上infix(中缀表达式)都是表达成postfix(后缀表达式)再来求值的。 比如 A + B C 写成 A B C + Infix Expression Prefix Expression Postfix Expression A + B + A B A B + A + B * C + A * B C A B C * + infix 中缀转postfix 后缀还有专门的算法：https://en.wikipedia.org/wiki/Shunting-yard_algorithm Create an empty stack called opstack for keeping operators. Create an empty list for output. Convert the input infix string to a list by using the string method split. Scan the token list from left to right. If the token is an operand, append it to the end of the output list. If the token is a left parenthesis, push it on the opstack. If the token is a right parenthesis, pop the opstack until the corresponding left parenthesis is removed. Append each operator to the end of the output list. If the token is an operator, *, /, +, or -, push it on the opstack. However, first remove any operators already on the opstack that have higher or equal precedence and append them to the output list. When the input expression has been completely processed, check the opstack. Any operators still on the stack can be removed and appended to the end of the output list. 可以看到中缀转后缀一个重要的点是： 当我们把operator +-*/ 放到opstack上时候，我们需要考虑/看是否有之前的operator有更高或者相等的precedence，这个时候我们需要优先（计算）把它放到output list. 参考 http://interactivepython.org/runestone/static/pythonds/BasicDS/InfixPrefixandPostfixExpressions.html AC代码 class Solution(object): def calculate(self, s): \"\"\" :type s: str :rtype: int \"\"\" def precedence(op): if op == '*' or op == '/': return 2 else: return 1 def cal(op, op1, op2): if op == '*': return op1 * op2 elif op == '/': return op1 / float(op2) elif op == '+': return op1 + op2 else: return op1 - op2 opstack = [] operands = [] # remove empty space and put operands and idx = 0 for i in range(idx, len(s)): if s[i] in '+-*/': operands.append(s[idx:i]) while len(opstack) > 0 and precedence(s[i]) = 2: op = opstack.pop() op2 = int(operands.pop()) op1 = int(operands.pop()) res = cal(op, op1, op2) operands.append(res) opstack.append(s[i]) idx = i + 1 operands.append(s[idx:]) while opstack: op = opstack.pop() op2 = int(operands.pop()) op1 = int(operands.pop()) res = cal(op, op1, op2) operands.append(res) return int(operands[0]) 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"225._implement_stack_using_queues.html":{"url":"225._implement_stack_using_queues.html","title":"225 implement stack using queues","keywords":"","body":"225. Implement Stack using Queues 题目: https://leetcode.com/problems/implement-stack-using-queues/ 难度: Easy 又到了作弊神预言Python的强项 class Stack(object): def __init__(self): \"\"\" initialize your data structure here. \"\"\" self.lst = [] def push(self, x): \"\"\" :type x: int :rtype: nothing \"\"\" self.lst.append(x) def pop(self): \"\"\" :rtype: nothing \"\"\" self.lst.remove(self.lst[-1]) def top(self): \"\"\" :rtype: int \"\"\" return self.lst[-1] def empty(self): \"\"\" :rtype: bool \"\"\" return self.lst == [] 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"226._invert_binary_tree.html":{"url":"226._invert_binary_tree.html","title":"226 invert binary tree","keywords":"","body":"226. Invert Binary Tree 题目: https://leetcode.com/problems/invert-binary-tree/ 难度: Easy 典型的递归题 class Solution(object): def invertTree(self, root): \"\"\" :type root: TreeNode :rtype: TreeNode \"\"\" if not root: return None self.invertTree(root.left) self.invertTree(root.right) root.left, root.right = root.right, root.left return root 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"227._basic_calculator_ii.html":{"url":"227._basic_calculator_ii.html","title":"227 basic calculator ii","keywords":"","body":"227. Basic Calculator II 题目: https://leetcode.com/problems/basic-calculator-ii/ 难度: Medium 思路： 瞄了一眼，基本上infix(中缀表达式)都是表达成postfix(后缀表达式)再来求值的。 比如 A + B C 写成 A B C + Infix Expression Prefix Expression Postfix Expression A + B + A B A B + A + B * C + A * B C A B C * + infix 中缀转postfix 后缀还有专门的算法：https://en.wikipedia.org/wiki/Shunting-yard_algorithm Create an empty stack called opstack for keeping operators. Create an empty list for output. Convert the input infix string to a list by using the string method split. Scan the token list from left to right. If the token is an operand, append it to the end of the output list. If the token is a left parenthesis, push it on the opstack. If the token is a right parenthesis, pop the opstack until the corresponding left parenthesis is removed. Append each operator to the end of the output list. If the token is an operator, *, /, +, or -, push it on the opstack. However, first remove any operators already on the opstack that have higher or equal precedence and append them to the output list. When the input expression has been completely processed, check the opstack. Any operators still on the stack can be removed and appended to the end of the output list. 可以看到中缀转后缀一个重要的点是： 当我们把operator +-*/ 放到opstack上时候，我们需要考虑/看是否有之前的operator有更高或者相等的precedence，这个时候我们需要优先（计算）把它放到output list. 参考 http://interactivepython.org/runestone/static/pythonds/BasicDS/InfixPrefixandPostfixExpressions.html AC代码 class Solution(object): def calculate(self, s): \"\"\" :type s: str :rtype: int \"\"\" def precedence(op): if op == '*' or op == '/': return 2 else: return 1 def cal(op, op1, op2): if op == '*': return op1 * op2 elif op == '/': return op1 / float(op2) elif op == '+': return op1 + op2 else: return op1 - op2 opstack = [] operands = [] # remove empty space and put operands and idx = 0 for i in range(idx, len(s)): if s[i] in '+-*/': operands.append(s[idx:i]) while len(opstack) > 0 and precedence(s[i]) = 2: op = opstack.pop() op2 = int(operands.pop()) op1 = int(operands.pop()) res = cal(op, op1, op2) operands.append(res) opstack.append(s[i]) idx = i + 1 operands.append(s[idx:]) while opstack: op = opstack.pop() op2 = int(operands.pop()) op1 = int(operands.pop()) res = cal(op, op1, op2) operands.append(res) return int(operands[0]) 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"228._summary_ranges.html":{"url":"228._summary_ranges.html","title":"228 summary ranges","keywords":"","body":"228. Summary Ranges 题目: https://leetcode.com/problems/summary-ranges/ 难度: Medium Just collect the ranges, then format and return them. class Solution(object): def summaryRanges(self, nums): \"\"\" :type nums: List[int] :rtype: List[str] \"\"\" ranges = [] for i in nums: if not ranges or i > ranges[-1][-1] + 1: ranges += [], ranges[-1][1:] = i, return ['->'.join(map(str, r)) for r in ranges] About the commas :-) ranges += [], r[1:] = n, Why the trailing commas? Because it turns the right hand side into a tuple and I get the same effects as these more common alternatives: ranges += [[]] or ranges.append([]) r[1:] = [n] Without the comma, … ranges += [] wouldn’t add [] itself but only its elements, i.e., nothing. r[1:] = n wouldn’t work, because my n is not an iterable. Why do it this way instead of the more common alternatives I showed above? Because it’s shorter and faster (according to tests I did a while back). 写到这里可能又有疑问了🤔️，为什么不可以直接写ranges[-1][1] = i呢，当然是会报IndexError: list assignment index out of range错误啦，那为什么ranges[-1][1:] = i,可以呢？ 简单来说 L1=L 与 L1=L[:] L1和L 都是对同一个对象的引用（所谓绑定的意思）。 L[:] 是生成了一个和L不同的新的对象，L1 变为了L[:] 这个对象的引用。 参考stefan 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"229._majority_element_ii.html":{"url":"229._majority_element_ii.html","title":"229 majority element ii","keywords":"","body":"229. Majority Element II 题目: https://leetcode.com/problems/majority-element-ii/ 难度: Medium 思路： majority element是两两比较扔掉不同的元素，然后最后会留下一个。 这里变成三三比较来扔东西, find all elements that appear more than ⌊ n/3 ⌋ times，所以最多可以有两个majority element ii. 最后再加一个比较来确认这些函数是majority element class Solution(object): def majorityElement(self, nums): \"\"\" :type nums: List[int] :rtype: List[int] \"\"\" cnt1 = 0 cnt2 = 0 maj1 = 0 maj2 = 0 for num in nums: if maj1 == num: cnt1 += 1 elif maj2 == num: cnt2 += 1 elif cnt1 == 0: maj1 = num cnt1 += 1 elif cnt2 == 0: maj2 = num cnt2 += 1 else: cnt1 -= 1 cnt2 -= 1 cnt1 = 0 cnt2 = 0 n = len(nums) res = [] for num in nums: if maj1 == num: cnt1 += 1 elif maj2 == num: cnt2 += 1 if cnt1 > n/3: res.append(maj1) if cnt2 > n/3: res.append(maj2) return res 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"230._kth_smallest_element_in_a_bst.html":{"url":"230._kth_smallest_element_in_a_bst.html","title":"230 kth smallest element in a bst","keywords":"","body":"230. Kth Smallest Element in a BST 题目: https://leetcode.com/problems/kth-smallest-element-in-a-bst/ 难度: Medium 跟昨天做的一道题类似，一上来就走取巧之路。 InOrder排序，输出，当然也完全可以用昨天的binary tree iterator,入stack,出stack,直到输出第k位 class Solution(object): def kthSmallest(self, root, k): \"\"\" :type root: TreeNode :type k: int :rtype: int \"\"\" self.root = root self.lst = [] self.inOrder(root) return self.lst[k-1] def inOrder(self, root): if root == None: return self.inOrder(root.left) self.lst.append(root.val) self.inOrder(root.right) 现在看到kth 就条件反射的想用divide & conquer, 扫root的左子树看nodes量，如果nodes数量是k-1，那么node就刚好是第k个，如果大于k > 左子树数量，扫右子树，同时更新root为root.right。 看到的言论： If we can change the BST node structure, We can add a new Integer to mark the number of element in the left sub-tree. when the node is not null. if k == node.leftNum + 1, return node if k > node.leftNum + 1, make k -= node.leftNum + 1, and then node = node.right otherwise, node = node.left 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"231._Power_of_Two.html":{"url":"231._Power_of_Two.html","title":"231 Power of Two","keywords":"","body":"231. Power of Two 题目: https://leetcode.com/problems/power-of-two/ 难度: Easy 思路： power of two 那是这个数字的binary 表示一定只有一个1 套用以前的代码leetcode191 这样会超时 class Solution(object): def isPowerOfTwo(self, n): # 此法超时 \"\"\" :type n: int :rtype: bool \"\"\" cnt = 0 while n != 0: n &= n - 1 cnt += 1 return cnt == 1 跟power of three一样递归，可以AC class Solution(object): def isPowerOfTwo(self, n): \"\"\" :type n: int :rtype: bool \"\"\" if n 也是有算法的wikipedia page The binary representation of integers makes it possible to apply a very fast test to determine whether a given positive integer x is a power of two: positive x is a power of two ⇔ (x & (x − 1)) is equal to zero. 注意特殊case 0的处理 class Solution(object): def isPowerOfTwo(self, n): \"\"\" :type n: int :rtype: bool \"\"\" return n & (n-1) == 0 if n != 0 else False 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"232._implement_queue_using_stacks.html":{"url":"232._implement_queue_using_stacks.html","title":"232 implement queue using stacks","keywords":"","body":"232. Implement Queue using Stacks 题目: https://leetcode.com/problems/implement-queue-using-stacks/ 难度: Easy 这个题没有乖乖听话，不过因为当年做过用两个stack来模拟queue 然后不得不说，我Python大法实在太厉害了 这功能强大的，我简直要啧啧啧 class Queue(object): def __init__(self): \"\"\" initialize your data structure here. \"\"\" self.lst = [] def push(self, x): \"\"\" :type x: int :rtype: nothing \"\"\" self.lst.append(x) def pop(self): \"\"\" :rtype: nothing \"\"\" del self.lst[0] def peek(self): \"\"\" :rtype: int \"\"\" return self.lst[0] def empty(self): \"\"\" :rtype: bool \"\"\" return self.lst == [] 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"234._palindrome_linked_list.html":{"url":"234._palindrome_linked_list.html","title":"234 palindrome linked list","keywords":"","body":"234. Palindrome Linked List 题目: https://leetcode.com/problems/palindrome-linked-list/ 难度: Easy 蠢了一下， 思路是：“先翻转整个链表（in-place），然后和之前的链表比较”，但是这样原链表都变了，肯定错。 如果新建一个链表，然后改造成原来链表的翻转链表，还是可行的，但是空间复杂度就是O(n)了。那还不如直接把List中元素拷贝到数组中直接比较，ac代码如下： class Solution(object): def isPalindrome(self, head): \"\"\" :type head: ListNode :rtype: bool \"\"\" vals = [] while head: vals += head.val, head = head.next return vals == vals[::-1] 这道题并不能算Easy吧： 思路二： 要想实现O(1)的空间复杂度，可以找到中间的节点，把linked list拆成两个部分，后半部分linkedlist reverse，然后比较两个linked list值是否相同，看例子： 1 -> 3 -> 1 拆成 1 和 1 1 -> 3 -> 5 ->5 -> 3 -> 1 拆成 1-> 3 -> 5 和 5 -> 3 -> 1 可以使用快慢指针来找到中间的节点。 class Solution(object): def isPalindrome(self, head): \"\"\" :type head: ListNode :rtype: bool \"\"\" fast = slow = head # 找到中间节点 while fast and fast.next: fast = fast.next.next slow = slow.next # 翻转后半部分 prev = None while slow: tmp = slow.next slow.next = prev prev = slow slow = tmp # 比较前后两部分 while prev: # while prev and head: if prev.val != head.val: return False prev = prev.next head = head.next return True 给个最终状态的例子： fast tmp None prev slow ^ ^ ^ | | | 1 --> 2 --> 3 但是注意最后的while prev不能换成while fast, 因为这是总节点数为奇数的情况，如果是偶数情况就不一样了，如下： tmp slow None prev fast ^ ^ ^ | | | 1 --> 2 --> 2 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"235._lowest_common_ancestor_of_a_binary_search_tree.html":{"url":"235._lowest_common_ancestor_of_a_binary_search_tree.html","title":"235 lowest common ancestor of a binary search tree","keywords":"","body":"235. Lowest Common Ancestor of a Binary Search Tree 题目： https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/ 难度 : Easy 两个node，一个大于root，一个小于root，那么必定root两边，共同的ancestor是root，同时再考虑同为空的状况 两个node，都比node小，到左边去寻找，那么先找到那个必定是common ancestor 两个node，都比node大，类似.... AC解法 class Solution(object): def lowestCommonAncestor(self, root, p, q): \"\"\" :type root: TreeNode :type p: TreeNode :type q: TreeNode :rtype: TreeNode \"\"\" if root == None or root == p or root == q: return root elif p.val 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"236._lowest_common_ancestor_of_a_binary_tree.html":{"url":"236._lowest_common_ancestor_of_a_binary_tree.html","title":"236 lowest common ancestor of a binary tree","keywords":"","body":"236. Lowest Common Ancestor of a Binary Tree 题目: https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/ 难度: Medium 思路 求root到node的path，然后对比path，最后一个想同的点就是lowest common ancestor 好开心，AC了 但是我根本不能在Runtime Distribution 上找到我，因为太慢了|||| class Solution(object): def lowestCommonAncestor(self, root, p, q): \"\"\" :type root: TreeNode :type p: TreeNode :type q: TreeNode :rtype: TreeNode \"\"\" pathP = self.pathTo(root,p) pathQ = self.pathTo(root,q) n = min(len(pathP), len(pathQ)) ans = root for i in range(n): if pathP[i] == pathQ[i]: ans = pathP[i] else: break return ans def pathTo(self, root, goal): # goal node ,path if root == None: return root stack = [(root, [root])] while stack: node, path = stack.pop() if node == goal: return path if node.left: stack.append((node.left, path + [node.left])) if node.right: stack.append((node.right, path + [node.right])) 递归解法，之所以我没有用递归因为有疑惑, BASE CASE 很容易想到，root 是none，或者p == root 或者q == root,那么LCA就是root，如果两个node一个在左边，一个在右边，那么LCA也是root，但是如果一个是6，另一个是4则有一点疑惑，但其实是没有问题的，因为这个时候给的总是他们的共同root，所以这个递归解法是没错的，总是想到递归是在那个状况下递归 _______3______ / \\ ___5__ ___1__ / \\ / \\ 6 _2 0 8 / \\ 7 4 AC代码 class Solution(object): def lowestCommonAncestor(self, root, p, q): \"\"\" :type root: TreeNode :type p: TreeNode :type q: TreeNode :rtype: TreeNode \"\"\" if root == None: return None if p == root or q == root: return root left = self.lowestCommonAncestor(self.left,p,q) right = self.lowestCommonAncestor(self.right,p,q) if left and right: return root return left if left is None else right 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"237._delete_node_in_a_linked_list.html":{"url":"237._delete_node_in_a_linked_list.html","title":"237 delete node in a linked list","keywords":"","body":"237. Delete Node in a Linked List 题目: https://leetcode.com/problems/delete-node-in-a-linked-list/ 难度: Easy 这道题，第一感觉，像删链表一样来删，把所有的node val前移一个,但是有个问题，为什么tail那个node还是存在？哼(ˉ(∞)ˉ)唧.. 已经被解答： http://stackoverflow.com/questions/38879291/python-delete-a-node-in-linked-list-given-just-access-to-that-node 另外一个O（1）的办法更好，把后一个node的val移到待删这个节点，并且把node.next = node.next.next 题目说了不会删最后一个点，所以node.next.next一定存在，所以直接让node的val等于它next的val，然后让node的next指向它的next的next，举个例子： 1->2->3->4->5->None,要删除第四个节点，就让4变成5，然后让第四个节点指向第五个节点的next， 这样原来的第四个节点就不存在了，虽然原来的第五个节点仍然存在且指向None，变成了1->2->3->5->None- O(1)时间 class Solution(object): def deleteNode(self, node): \"\"\" :type node: ListNode :rtype: void Do not return anything, modify node in-place instead. \"\"\" node.val = node.next.val node.next = node.next.next O(n)时间 class Solution(object): def deleteNode(self, node): \"\"\" :type node: ListNode :rtype: void Do not return anything, modify node in-place instead. \"\"\" while node.next: node.val = node.next.val prev, node = node, node.next # clear reference to tail prev.next = None 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"238._product_of_array_except_self.html":{"url":"238._product_of_array_except_self.html","title":"238 product of array except self","keywords":"","body":"238. Product of Array Except Self 题目: https://leetcode.com/problems/product-of-array-except-self/ 难度: Medium 不使用division 并且O(n) 想到的算法 O(n^2) 会超时 class Solution(object): def productExceptSelf(self,nums): \"\"\" :type nums: List[int] :rtype: List[int] \"\"\" lst = [] for i in range(len(nums)): lst.append(self.productWithoutI(nums,i)) return lst def productWithoutI(self,nums,i): product = 1 for j in range(len(nums)): if j != i: product *= nums[j] return product 如果用除法，也会有问题，如果有0出现也会变繁琐。 谷歌一下： 解法还是很棒的 output[i] = { i 前面的数的乘积} X { i 后面的数的乘积} class Solution(object): def productExceptSelf(self,nums): \"\"\" :type nums: List[int] :rtype: List[int] \"\"\" if nums == [] : return [] lft = [1] rgt = [1] product = 1 for i in range(1,len(nums)): product *= nums[i-1] lft.append(product) product = 1 for i in reversed(range(1,len(nums))): product *= nums[i] rgt.append(product) rgt.reverse() result = [] for i in range(len(nums)): result.append(lft[i]*rgt[i]) return result 空间O（n），再看到满足要求的“标准解法” class Solution(object): def productExceptSelf(self,nums): \"\"\" :type nums: List[int] :rtype: List[int] \"\"\" if nums == [] : return [] size = len(nums) output = [1] * size left = 1 for x in range(size-1): left *= nums[x] output[x+1] *= left right = 1 for x in range(size - 1, 0, -1): right *= nums[x] output[x-1] *= right return output 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"240._search_a_2d_matrix_ii.html":{"url":"240._search_a_2d_matrix_ii.html","title":"240 search a 2d matrix ii","keywords":"","body":"240. Search a 2D Matrix II 题目: https://leetcode.com/problems/search-a-2d-matrix-ii/ 难度: Medium 思路： 每行，每列都是sorted 但是比较好的策略是从右上角开始搜索，比如这样： matrix = [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] m, n = 0, col - 1 更新策略： matrix[m][n] target: 那么这一列往下走都会大于target，col - 1,往左走 否则找到 时间复杂度O(max(M,N))，因为每次都会往下或者往左走 用的算法是Saddleback class Solution(object): def searchMatrix(self, matrix, target): \"\"\" :type matrix: List[List[int]] :type target: int :rtype: bool \"\"\" if not matrix: return False row = len(matrix) col = len(matrix[0]) if row else 0 m, n = 0, col - 1 while m = 0: if matrix[m][n] target: n -= 1 else: return True return False 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"242._valid_anagram.html":{"url":"242._valid_anagram.html","title":"242 valid anagram","keywords":"","body":"242. Valid Anagram 题目： https://leetcode.com/problems/valid-anagram/ 难度 : Easy 一行瞬秒： class Solution(object): def isAnagram(self, s, t): \"\"\" :type s: str :type t: str :rtype: bool \"\"\" return collections.Counter(s) == collections.Counter(t) class Solution(object): def isAnagram(self, s, t): \"\"\" :type s: str :type t: str :rtype: bool \"\"\" return sorted(s) == sorted(t) 用字数统计，因为只可能是26个字母 class Solution(object): def isAnagram(self, s, t): \"\"\" :type s: str :type t: str :rtype: bool \"\"\" if len(s) != len(t): return False charCnt = [0] * 26 for i in range(len(s)): charCnt[ord(s[i]) - 97] += 1 charCnt[ord(t[i]) - 97] -= 1 for cnt in charCnt: if cnt != 0: return False return True 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"249._Group_Shifted_Strings.html":{"url":"249._Group_Shifted_Strings.html","title":"249 Group Shifted Strings","keywords":"","body":"249. Group Shifted Strings 难度: 中等 刷题内容 原题连接 https://leetcode.com/problems/group-shifted-strings/description/ 内容描述 Given a string, we can \"shift\" each of its letter to its successive letter, for example: \"abc\" -> \"bcd\". We can keep \"shifting\" which forms the sequence: \"abc\" -> \"bcd\" -> ... -> \"xyz\" Given a list of strings which contains only lowercase alphabets, group all strings that belong to the same shifting sequence. Example: Input: [\"abc\", \"bcd\", \"acef\", \"xyz\", \"az\", \"ba\", \"a\", \"z\"], Output: [ [\"abc\",\"bcd\",\"xyz\"], [\"az\",\"ba\"], [\"acef\"], [\"a\",\"z\"] ] 解题方案 思路 1 hash table存储pattern class Solution(object): def groupStrings(self, strings): \"\"\" :type strings: List[str] :rtype: List[List[str]] \"\"\" table = {} for w in strings: pattern = '' for i in range(1, len(w)): if ord(w[i]) - ord(w[i - 1]) >= 0: pattern += str(ord(w[i]) - ord(w[i - 1])) else: pattern += str(ord(w[i]) - ord(w[i - 1]) + 26) ## 这是为了处理'az'和'ba'的情况 if pattern in table: table[pattern].append(w) else: table[pattern] = [w] return [table[pattern] for pattern in table] 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"252._Meeting_Rooms.html":{"url":"252._Meeting_Rooms.html","title":"252 Meeting Rooms","keywords":"","body":"252. Meeting Rooms 题目： https://leetcode.com/problems/meeting-rooms/ 难度 : Easy 思路： 学了一下如何根据attribute 来sort object intervals.sort(key = lambda interval : interval.start) AC 代码 # Definition for an interval. # class Interval(object): # def __init__(self, s=0, e=0): # self.start = s # self.end = e class Solution(object): def canAttendMeetings(self, intervals): \"\"\" :type intervals: List[Interval] :rtype: bool \"\"\" n = len(intervals) if n 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"255._Verify_Preorder_Sequence_in_Binary_Search_Tree.html":{"url":"255._Verify_Preorder_Sequence_in_Binary_Search_Tree.html","title":"255 Verify Preorder Sequence in Binary Search Tree","keywords":"","body":"255. Verify Preorder Sequence in Binary Search Tree 题目: https://leetcode.com/problems/verify-preorder-sequence-in-binary-search-tree/ 难度: Medium 思路： 这道题让给了我们一个一维数组，让我们验证其是否为一个二叉搜索树的先序遍历出的顺序，我们都知道二叉搜索树的性质是左 10 / \\ 5 12 / \\ 2 6 preorder:[10, 5, 2, 6, 12] 如这个例子，我们先设一个最小值min_num，然后遍历数组，如果当前值小于这个最小值min_num，返回false，对于根节点，我们将其压入栈中，然后往后遍历，如果遇到的数字比栈顶元素小，说明是其左子树的点，继续压入栈中，直到遇到的数字比栈顶元素大，那么就是右边的值了，我们需要找到是哪个节点的右子树，所以我们更新low值并删掉栈顶元素，然后继续和下一个栈顶元素比较，如果还是大于，则继续更新low值和删掉栈顶，直到栈为空或者当前栈顶元素大于当前值停止，压入当前值，这样如果遍历完整个数组之前都没有返回false的话，最后返回true即可 参考Ethan Li 的技术专栏 O(n) time, O(n) space class Solution(object): def verifyPreorder(self, preorder): \"\"\" :type preorder: List[int] :rtype: bool \"\"\" stack = [] min_num = -1 stack[-1]: # 将路径中所有小于当前的数pop出来并更新最小值 min_num = stack.pop() stack.append(x) # 将当前值push进去 return True Follow up: O(n) time, O(1) space we realize that the preorder array can be reused as the stack thus achieve O(1) extra space, since the scanned items of preorder array is always more than or equal to the length of the stack. class Solution(object): def verifyPreorder(self, preorder): \"\"\" :type preorder: List[int] :rtype: bool \"\"\" # stack = preorder[:i], reuse preorder as stack min_num = -1 0 and x > preorder[i - 1]: min_num = preorder[i - 1] i -= 1 preorder[i] = x i += 1 return True 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"256._Paint_House.html":{"url":"256._Paint_House.html","title":"256 Paint House","keywords":"","body":"256. Paint House 题目: https://leetcode.com/problems/paint-house/ 难度: Medium 其实这个题目有实际意义诶，至少我的故乡？在要申请啥东西的时候就把街上的房子全刷了。 然后这个是相邻的房子不同色。 其实我觉得paint fense更难一点 思路： 数组 dp[x][3] 代表第x个房子paint r/g/b的值 AC代码 class Solution(object): def minCost(self, costs): \"\"\" :type costs: List[List[int]] :rtype: int \"\"\" m = len(costs) if m == 0 : return 0 elif m == 1 : return min(costs[0][0], costs[0][1],costs[0][2]) else: n = 3 if m else 0 dp = [[0 for i in range(3)] for j in range(m)] dp[0] = costs[0] for i in range(1,m): dp[i][0] = min(dp[i-1][1],dp[i-1][2]) + costs[i][0] dp[i][1] = min(dp[i-1][0],dp[i-1][2]) + costs[i][1] dp[i][2] = min(dp[i-1][0],dp[i-1][1]) + costs[i][2] return min(dp[m-1][0], dp[m-1][1], dp[m-1][2]) 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"257._binary_tree_paths.html":{"url":"257._binary_tree_paths.html","title":"257 binary tree paths","keywords":"","body":"257. Binary Tree Paths 难度: 简单 刷题内容 原题连接 https://leetcode.com/problems/binary-tree-paths/description/ 内容描述 Given a binary tree, return all root-to-leaf paths. Note: A leaf is a node with no children. Example: Input: 1 / \\ 2 3 \\ 5 Output: [\"1->2->5\", \"1->3\"] Explanation: All root-to-leaf paths are: 1->2->5, 1->3 解题方案 思路 1 递归+DFS class Solution(object): def binaryTreePaths(self, root): \"\"\" :type root: TreeNode :rtype: List[str] \"\"\" def helper(node, cur_path): if not node.left and not node.right: ## 到leaf了 res.append(cur_path+[node.val]) return if node.left: helper(node.left, cur_path+[node.val]) if node.right: helper(node.right, cur_path+[node.val]) res = [] if not root: return res helper(root, []) return ['->'.join([str(val) for val in path]) for path in res] 注意一点，很多人可能看到这里有好几次cur_path+[node.val]，觉得干嘛不直接写在最开头了，事实是这样做的话cur_path就已经变化了，因为要执行完if node.left才去执行if node.right，此时cur_path就不是原来的cur_path了。 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"258._Add_Digits.html":{"url":"258._Add_Digits.html","title":"258_ Add_Digits md","keywords":"","body":"258. Add Digits 题目: https://leetcode.com/problems/add-digits/ 难度: Easy 思路 这就简单的一p了。。 class Solution(object): def addDigits(self, num): \"\"\" :type num: int :rtype: int \"\"\" while num / 10 >= 1: tmp = 0 while num / 10 >= 1: tmp += num % 10 num /= 10 tmp += num % 10 num = tmp return num 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"261._Graph_Valid_Tree.html":{"url":"261._Graph_Valid_Tree.html","title":"261 Graph Valid Tree","keywords":"","body":"261. Graph Valid Tree 题目： https://leetcode.com/problems/graph-valid-tree/ 难度 : Medium 思路： graph 为 tree 两个条件： 这个图是connected 没有cycle 偷懒AC代码，直接在323题，Number of Connected Components in an Undirected Graph上改的AC代码： class Solution(object): def validTree(self, n, edges): \"\"\" :type n: int :type edges: List[List[int]] :rtype: bool \"\"\" def find(x): if uf[x] != x: uf[x] = find(uf[x]) return uf[x] def union(x,y): xRoot = find(x) yRoot = find(y) uf[xRoot] = yRoot uf = [i for i in range(n)] for node1, node2 in edges: # cycle exists if find(node1) == find(node2): print 'ha ' return False else: union(node1, node2) res = set() for i in range(n): res.add(find(i)) return len(res) == 1 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"263._ugly_number.html":{"url":"263._ugly_number.html","title":"263 ugly number","keywords":"","body":"263. Ugly Number 题目: https://leetcode.com/problems/ugly-number/ 难度: Easy 思路： 因为其prime factors 只包括 2, 3, 5，所以比如如果能被2 整除， n = n / 2， 直到不能被2整除，然后同样对3,5检验，如果最终结果为1，那么就是ugly number，否则不过关 注意一下边界条件，当num为0的时候，return一下False class Solution(object): def isUgly(self, num): \"\"\" :type num: int :rtype: bool \"\"\" if num == 0 : return False while num % 2 == 0: num = num / 2 while num % 3 == 0: num = num / 3 while num % 5 == 0: num = num / 5 if num == 1: return True return False 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"264._ugly_number_ii.html":{"url":"264._ugly_number_ii.html","title":"264 ugly number ii","keywords":"","body":"264. Ugly Number II 题目: https://leetcode.com/problems/ugly-number-ii/ 难度: Medium 思路： 暴力算法一定会超时 先看一个非常🐂的帖子，当我知道python 除了有list之外还有collections就已经被刷新了一次了，然后数据结构 x 数据结构，就展示了数据结构的魅力 http://stackoverflow.com/questions/4098179/anyone-know-this-python-data-structure 看一下deque + rotate： import collections a = collections.deque() a.append(2) a.append(5) a.append(7) a.append(9) #a deque([2, 5, 7, 9]) import bisect idx = bisect.bisect_left(a,3) #1 a.rotate(-idx) #deque([5, 7, 9, 2]) a.appendleft(3) #deque([3, 5, 7, 9, 2]) a.rotate(idx) # deque([2, 3, 5, 7, 9]) 这个rotate -是往左边rotate，看官网的介绍. Rotate the deque n steps to the right. If n is negative, rotate to the left. Rotating one step to the right is equivalent to: d.appendleft(d.pop()). 所以这样造成可以🐂的数据结构 用这个微调之后的fasttable来解决问题 import collections import bisect class FastTable: def __init__(self): self.__deque = collections.deque() def __len__(self): return len(self.__deque) def head(self): return self.__deque.popleft() def tail(self): return self.__deque.pop() def peek(self): return self.__deque[-1] def insert(self, obj): if obj in self.__deque: return index = bisect.bisect_left(self.__deque, obj) self.__deque.rotate(-index) self.__deque.appendleft(obj) self.__deque.rotate(index) class Solution(object): def nthUglyNumber(self, n): \"\"\" :type n: int :rtype: int \"\"\" q = FastTable() q.insert(1) while n > 0: x = q.head() q.insert(2*x) q.insert(3*x) q.insert(5*x) n -= 1 return x 还可以优化： 根据页面hint 来做的 class Solution(object): def nthUglyNumber(self, n): \"\"\" :type n: int :rtype: int \"\"\" if n == 1: return 1 else: import collections q2 = collections.deque() q3 = collections.deque() q5 = collections.deque() q2.append(2) q3.append(3) q5.append(5) while n > 1: x = min(q2[0],q3[0],q5[0]) if x == q2[0]: x = q2.popleft() q2.append(2*x) q3.append(3*x) q5.append(5*x) elif x == q3[0]: x = q3.popleft() q3.append(3*x) q5.append(5*x) else: x = q5.popleft() q5.append(5*x) n -= 1 return x 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"265._Paint_House_II.html":{"url":"265._Paint_House_II.html","title":"265 Paint House II","keywords":"","body":"265. Paint House II 题目: https://leetcode.com/problems/paint-house-ii/ 难度: Hard 思路： 感觉不像hard 题，知道为啥hard了，因为can you solve it in O(nk) runtime 数组 dp[x][k] 代表第x个房子paint 0..k的值 用paint house 1 改的AC代码： 不过这个时间复杂度是O(nkk)吧 class Solution(object): def minCostII(self, costs): \"\"\" :type costs: List[List[int]] :rtype: int \"\"\" n = len(costs) if n == 0 : return 0 elif n == 1 : return min (costs[0]) else: k = len(costs[0]) if n else 0 dp = [[0 for i in range(k)] for j in range(n)] dp[0] = costs[0] for i in range(1,n): for j in range(0,k): minVal = float('inf') for m in range(0,k): if m != j and dp[i-1][m] 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"266._Palindrome_Permutation.html":{"url":"266._Palindrome_Permutation.html","title":"266 Palindrome Permutation","keywords":"","body":"266. Palindrome Permutation 题目： https://leetcode.com/problems/palindrome-permutation/ 难度 : Easy 思路： hint 已经提示的很明显。数单字个数来处理 AC代码 class Solution(object): def canPermutePalindrome(self, s): \"\"\" :type s: str :rtype: bool \"\"\" lookup = {} for char in s: lookup[char] = lookup.get(char,0) + 1 res = 0 for char, cnt in lookup.items(): if cnt % 2 == 0 : continue else: res += 1 return res ​ 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"267._Palindrome_Permutation_II.html":{"url":"267._Palindrome_Permutation_II.html","title":"267 Palindrome Permutation II","keywords":"","body":"267. Palindrome Permutation II 题目： https://leetcode.com/problems/palindrome-permutation-ii/ 难度 : Medium 思路： 首先这个题目有个简单版本，那就是判断是否可以permutate 为 palindrome. 问题的关键是最多只能一个odd character. 写的这么不elegant，我也是服气！ AC代码： class Solution(object): def generatePalindromes(self, s): \"\"\" :type s: str :rtype: List[str] \"\"\" def permuteUnique(firstS): if len(firstS) == 0 : return [] if len(firstS) == 1 : return [firstS] res = [] for i in range(len(firstS)): if i > 0 and firstS[i] == firstS[i-1]: continue for j in permuteUnique(firstS[:i] + firstS[i+1:]): res.append([firstS[i]] + j) return res lookup = {} for char in s: lookup[char] = lookup.get(char, 0) + 1 res, firstS, oddChar = 0, [], '' for char, cnt in lookup.items(): if cnt % 2 == 0: for i in range(cnt/2): firstS.append(char) continue else: for i in range(cnt / 2): firstS.append(char) oddChar = char res += 1 if res >= 2: return [] else: res = permuteUnique(firstS) if len(res) == 0 and oddChar: return [oddChar] return map(lambda x: ''.join(x) + oddChar + ''.join(x[::-1]),res) 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"268._missing_number.html":{"url":"268._missing_number.html","title":"268 missing number","keywords":"","body":"268. Missing Number 题目: https://leetcode.com/problems/missing-number/ 难度: Medium 等差数列前n项和减去数组之和,一行瞬秒 ```python class Solution(object): def missingNumber(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" return len(nums) * (len(nums) + 1) / 2 - sum(nums) 第二种解法是位运算：位运算（异或运算） class Solution(object): def missingNumber(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" res = n = len(nums) for i in range(n): res ^= i res ^= nums[i] return res 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"270._Closest_Binary_Search_Tree_Value.html":{"url":"270._Closest_Binary_Search_Tree_Value.html","title":"270 Closest Binary Search Tree Value","keywords":"","body":"270. Closest Binary Search Tree Value 难度: 简单 刷题内容 原题连接 https://leetcode.com/problems/closest-binary-search-tree-value/description/ 内容描述 Given a non-empty binary search tree and a target value, find the value in the BST that is closest to the target. Note: Given target value is a floating point. You are guaranteed to have only one unique value in the BST that is closest to the target. Example: Input: root = [4,2,5,1,3], target = 3.714286 4 / \\ 2 5 / \\ 1 3 Output: 4 解题方案 思路 1 来个中序遍历，再判断哪个最close class Solution(object): def closestValue(self, root, target): \"\"\" :type root: TreeNode :type target: float :rtype: int \"\"\" res, diff = [], [] self.inorder(root, res) for i in res: diff.append(abs(i-target)) return res[diff.index(min(diff))] def inorder(self, root, res): if not root: return self.inorder(root.left, res) res.append(root.val) self.inorder(root.right, res) 思路 2 或者可以用更节省空间的方式，只保留一个closet，不断比较 class Solution(object): def closestValue(self, root, target): \"\"\" :type root: TreeNode :type target: float :rtype: int \"\"\" lst = [] def inorder(root): if root: inorder(root.left) lst.append(root.val) inorder(root.right) inorder(root) close = lst[0] diff = abs(target - lst[0]) for i in lst: if abs(target - i) 思路 3 AC代码，跟binary search tree 寻值一样, loop 一遍树来寻找 class Solution(object): def closestValue(self, root, target): \"\"\" :type root: TreeNode :type target: float :rtype: int \"\"\" close = root.val while root: close = root.val if abs(target - root.val) 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"276._Paint_Fence.html":{"url":"276._Paint_Fence.html","title":"276 Paint Fence","keywords":"","body":"276. Paint Fence 题目: https://leetcode.com/problems/paint-fence/ 难度: Easy 思路： 先解释一下题目意思： fence 栅栏， post 柱子 , no more than two adjacent fence posts have the same color.（一开始看漏，没有看到more than，以为相邻就不能同色）。 本来想画格子找规律，结果走偏了，所以老老实实写递推关系式，貌似是这样的 n = 0 : 全为0 n = 1 : 有 k种方式 n = 2 ：有 k * k 种 否则，第n个有两种可能， 跟 n-1 颜色不一样, 跟 n-1 颜色一样， fn = (k-1)fn-1 + (k-1) fn-2 画一下表：对一下递推关系式，正确✅ n 0 1 2 3 4 0 0 0 0 0 0 t 1 0 1 1 0 0 2 0 2 4 6 10 3 0 3 9 24 . 4 0 4 16 60 . AC 代码 class Solution(object): def numWays(self, n, k): \"\"\" :type n: int :type k: int :rtype: int \"\"\" if n == 0: return 0 else: if k == 0: return 0 elif n == 1: return k elif n == 2 : return k * k else: dp = [0 for i in range(n+1)] dp[0] = 0 dp[1] = k dp[2] = k * k for i in range(3,n+1): dp[i] = (k-1) * dp [i-1] + (k-1) * dp [i-2] return dp[-1] 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"277._Find_the_Celebrity.html":{"url":"277._Find_the_Celebrity.html","title":"277 Find the Celebrity","keywords":"","body":"277. Find the Celebrity 题目： https://leetcode.com/problems/find-the-celebrity/ 难度 : Medium 思路： 算法考试考过 celebrity 是 每个人都知道他，而他不认识任何别的人。 如果用图来看，那就每个别的人都有箭头指向c，而c没有任何出去的箭头。 O(N^2)的代码还是还是很容易想到的 但是我们可以有提升，那么就是可以check knows(a,b)，如果 a knows b，那么可以排除a是celebrity，否则可以排除b是celebrity. 最后还要确认一遍是否这个是真的celebrity AC代码 # The knows API is already defined for you. # @param a, person a # @param b, person b # @return a boolean, whether a knows b # def knows(a, b): class Solution(object): def findCelebrity(self, n): \"\"\" :type n: int :rtype: int \"\"\" if n == 0: return -1 c = 0 for i in xrange(1,n): if not knows(i, c): c = i for i in range(n): if c != i: if not knows(i,c) or knows(c,i): return -1 return c 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"278._First_Bad_Version.html":{"url":"278._First_Bad_Version.html","title":"278 First Bad Version","keywords":"","body":"278. First Bad Version 题目： https://leetcode.com/problems/first-bad-version/ 难度 : Easy 思路： 根据 search for a range 改的 class Solution(object): def firstBadVersion(self, n): \"\"\" :type n: int :rtype: int \"\"\" l, r = 0, n - 1 while l > 2) if not isBadVersion(mid): l = mid + 1 else: r = mid - 1 return l 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"279._perfect_squares.html":{"url":"279._perfect_squares.html","title":"279 perfect squares","keywords":"","body":"279. Perfect Squares 题目: https://leetcode.com/problems/perfect-squares/ 难度: Medium 思路一： DP, 状态转移方程: dp[i] = min(dp[i], dp[i - j * j] + 1) class Solution(object): def numSquares(self, n): \"\"\" :type n: int :rtype: int \"\"\" dp = [0] * (n+1) for i in range(n+1): dp[i] = i j = 1 while j * j 但是这个方法贼慢，beats 12%, 有时候提交甚至会超时，有时候又不会。。。。因此想别的办法 思路二： Static DP, beats 90.39% class Solution(object): dp = [0] def numSquares(self, n): \"\"\" :type n: int :rtype: int \"\"\" while len(self.dp) 进一步简化可以写成： class Solution(object): dp = [0] def numSquares(self, n): \"\"\" :type n: int :rtype: int \"\"\" while len(self.dp) 这里有个问题现在还没搞明白，以后再好好想一下，写成return self.dp[-1]提交就失败， Submission Result: Wrong Answer Input: 1024 Output: 4 Expected: 1 思路三： 还是慢，有个数学方法, runtime beats 98.48% import math class Solution(object): def numSquares(self, n): \"\"\" :type n: int :rtype: int \"\"\" def isSquare(num): tmp = int(math.sqrt(num)) return tmp * tmp == num while n & 3 == 0: # n % 4 == 0 n >>= 2 if n & 7 == 7: # n % 8 == 7 return 4 if isSquare(n): return 1 sqrt_n = int(math.sqrt(n)) for i in range(1, sqrt_n + 1): if isSquare(n-i*i): return 2 return 3 in order to understand, I suggest u read: here is the Lagrange's Four Square theorem - Limit the result to And this article, in which you can also find the way to present a number as a sum of four squares: 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"280._Wiggle_Sort.html":{"url":"280._Wiggle_Sort.html","title":"280 Wiggle Sort","keywords":"","body":"280. Wiggle Sort 题目： https://leetcode.com/problems/wiggle-sort/ 难度 : Medium 思路： 想的是比如bubble sort或者任何简单的比较sort，只是放数字的时候是按这样的大小顺序放： 1, n, 2, n-1,3, n-2…. 或者每个pass其实做两个sort，找出最大的和最小的。然后分别放在头尾。 这样的写法TLE: class Solution(object): def wiggleSort(self, nums): # 此法超时 \"\"\" :type nums: List[int] :rtype: void Do not return anything, modify nums in-place instead. \"\"\" n = len(nums) for i in range(n): # small bubble sort if i % 2 == 0: for j in range(n-1, i-1, -1): if nums[j] > nums[j-1]: nums[j], nums[j-1] = nums[j-1],nums[j] else: for j in range(n-1, i-1, -1): if nums[j] 但是貌似想复杂了，其实对于这个简单化，要求只有一个： 如果i是奇数，nums[i] >= nums[i - 1] 如果i是偶数，nums[i] 所以我们只要遍历一遍数组，把不符合的情况交换一下就行了。具体来说，如果nums[i] > nums[i - 1]， 则交换以后肯定有nums[i] AC 代码 class Solution(object): def wiggleSort(self, nums): \"\"\" :type nums: List[int] :rtype: void Do not return anything, modify nums in-place instead. \"\"\" for i in xrange(1, len(nums)): if ((i % 2) and nums[i] nums[i-1]): nums[i], nums[i-1] = nums[i-1], nums[i] 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"283._move_zeroes.html":{"url":"283._move_zeroes.html","title":"283 move zeroes","keywords":"","body":"283. Move Zeroes 题目: https://leetcode.com/problems/move-zeroes/ 难度: Easy 思路： 思路一：暴力 class Solution(object): def moveZeroes(self, nums): \"\"\" :type nums: List[int] :rtype: void Do not return anything, modify nums in-place instead. \"\"\" i = 0 while 0 in nums: nums.remove(0) i += 1 nums.extend([0]*i) 思路二： 一旦遇到不是0的就把它往前移动，移动非0完成，剩下的全部填0，看例子 0 1 0 3 12 也算双指针吧， 首先cur = 0， idx = 0，为0，不变，然后idx = 1，不为0，前移，数组变成 1 1 0 3 12 继续idx 这个时候是2，不变，继续处理,碰到3可以变成 1 3 0 3 12 这样知道变换完成，简直逆天啊，因为cur 总是小于idx，所以总可以保持这样的稳定性 class Solution(object): def moveZeroes(self, nums): \"\"\" :type nums: List[int] :rtype: void Do not return anything, modify nums in-place instead. \"\"\" cur,idx = 0,0 while idx 思路三： 传统的双指针，参考这里 http://fisherlei.blogspot.com/2015/10/leetcode-move-zeroes-solution.html 此法最快，beats 90.50% class Solution(object): def moveZeroes(self, nums): \"\"\" :type nums: List[int] :rtype: void Do not return anything, modify nums in-place instead. \"\"\" p0, p1 = 0, 0 # P1指向非0，p0指向0 while p0 相反，我觉得这样双指针反而没有上面的代码容易理解 思路四： 一个比较巧妙的方法： class Solution(object): def moveZeroes(self, nums): \"\"\" :type nums: List[int] :rtype: void Do not return anything, modify nums in-place instead. \"\"\" nums.sort(key= lambda x: 1 if x == 0 else 0) 原理就是原先为0的数优先级在此次sort中更高了，所以全部升序排列排到后面去了 但是这个解法被人说是没有满足题目no extra space的条件，详见Sayo timsort can require a temp array containing as many as N//2 pointers, which means as many as 2*N extra bytes on 32-bit boxes. 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"285._inorder_successor_in_bst.html":{"url":"285._inorder_successor_in_bst.html","title":"285 inorder successor in bst","keywords":"","body":"285. Inorder Successor in BST 难度: 中等 刷题内容 原题连接 https://leetcode.com/problems/inorder-successor-in-bst/description/ 内容描述 Given a binary search tree and a node in it, find the in-order successor of that node in the BST. Note: If the given node has no in-order successor in the tree, return null. Example 1: Input: root = [2,1,3], p = 1 2 / \\ 1 3 Output: 2 Example 2: Input: root = [5,3,6,2,4,null,null,1], p = 6 5 / \\ 3 6 / \\ 2 4 / 1 Output: null 解题方案 思路 1 首先可以去看一下二叉树的一些操作 BST的特性，对于一个node，它的所有左侧node都比它小，它的所有右侧node都比它大。最小的元素在最左边，最大的元素在最右边。 一个node x它的successor y 是满足y > x的最小值。两种情况，如果node x有right child，那么这个right child 中的最小值就是它的successor，否则就要往上走，如果走上去的parent使得这个node是其左边的孩子的话，那么successor我们也找到了。 因为状况可能是这样的： 3 / 1 / \\ 0 2 如果是寻找0的successor，那么我们往上一走，发现0的祖先是1，并且0是1的左孩子，找到，否则如果寻找2的successor，那么我们要往上走到3的部分，2是3的左subtree，这样才能解决问题。 伪码 function Succ(x) if Right(x) ̸= NIL then return Min(Right(x)) else p ← Parent(x) while p ̸= NIL and x = Right(p) do x←p p ← Parent(p) return p 这里伪码有点不适用是因为我们并没有这个parent指针，当然我们还是有trick方式的，就是我们从root开始走，直到找到这个node p，同时我们记录一路上看到的比p.val大的值，这样最后一个就是它的successor.其中最低的那一个就是他的successor. class Solution(object): def inorderSuccessor(self, root, p): \"\"\" :type root: TreeNode :type p: TreeNode :rtype: TreeNode \"\"\" def minNode(node): while node.left: node = node.left return node def searchP(root, p): if not root or root.val == p.val: return None else: succ = None while root != None and p.val != root.val: if p.val 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"286._Walls_and_Gates.html":{"url":"286._Walls_and_Gates.html","title":"286 Walls and Gates","keywords":"","body":"286. Walls and Gates 题目： https://leetcode.com/problems/walls-and-gates/ 难度 : Medium 思路： 乍一看feel like all pairs shortest path. naive的想法是针对所有为0的点做all pairs shortest path，然后最终得到的就是把INF替换保留最小的。时间复杂度是0的个数* BFS naive的想法AC class Solution(object): def wallsAndGates(self, rooms): \"\"\" :type rooms: List[List[int]] :rtype: void Do not return anything, modify rooms in-place instead. \"\"\" def legal(x,y): return x >= 0 and x = 0 and y rooms[x][y] + 1: rooms[x-1][y] = rooms[x][y] + 1 queue.append((x-1,y)) if legal(x+1,y) and rooms[x+1][y] > rooms[x][y] + 1 : rooms[x+1][y] = rooms[x][y] + 1 queue.append((x+1,y)) if legal(x,y-1) and rooms[x][y-1] > rooms[x][y] + 1: rooms[x][y-1] = rooms[x][y] + 1 queue.append((x,y-1)) if legal(x,y+1) and rooms[x][y+1] > rooms[x][y] + 1 : rooms[x][y+1] = rooms[x][y] + 1 queue.append((x,y+1)) row = len(rooms) col = len(rooms[0]) if row else 0 for i in range(row): for j in range(col): if rooms[i][j] == 0: bfs(rooms,i,j) 复习一下BFS的伪码 from wikipedia, 一开始有点小迷茫，那就是为什么没有keep一个visited的数据结构，但是随即反应过来，其实n.distance == INFINITY 已经是check它是否被visited 过了，我以上的代码并没有做这个操作，但是因为是格子状以及我仅在检查是否更小，所以也能AC. Breadth-First-Search(Graph, root): for each node n in Graph: n.distance = INFINITY n.parent = NIL create empty queue Q root.distance = 0 Q.enqueue(root) while Q is not empty: current = Q.dequeue() for each node n that is adjacent to current: if n.distance == INFINITY: n.distance = current.distance + 1 n.parent = current Q.enqueue(n) 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"289._game_of_life.html":{"url":"289._game_of_life.html","title":"289 game of life","keywords":"","body":"289. Game of Life 题目： https://leetcode.com/problems/game-of-life/ 难度 : Medium 直接一上来就没有考虑solve it in-place,考虑的是便利，简直是born for 便利 首先我把board拓宽了，宽，高各增加了两排。 因为这样求neighbor方便，针对原来的borad，现在新的big 对于 1 -> n-1 的部分 全都有八个neighbor，用了一个2d array来记录nbrs，再根据当下的nbr来判断更新，因为不能一边在board上loop一边更新. AC的效率还ok： class Solution(object): def gameOfLife(self, board): \"\"\" :type board: List[List[int]] :rtype: void Do not return anything, modify board in-place instead. \"\"\" def liveNeighbors(i,j): return big[i-1][j-1] + big[i-1][j] + big[i-1][j+1] + big[i][j-1] + big[i][j+1] + big[i+1][j-1] + big[i+1][j] + big[i+1][j+1] if board == [[]] : return row = len(board) col = len(board[0]) nbrs = [[0 for j in range(col)] for i in range(row)] big = [[ 0 for j in range(col+2) ] for i in range(row+2)] for i in range(1,row+1): for j in range(1,col+1): big[i][j] = board[i-1][j-1] for i in range(1,row+1): for j in range(1,col+1): nbrs[i-1][j-1] = liveNeighbors(i,j) for i in range(row): for j in range(col): if board[i][j] == 1: if nbrs[i][j] 谷歌了一下，大家都用到了temp 2d array嘛，哼(ˉ(∞)ˉ)唧。好吧，空间复杂度比我小。 很多的解法都是一样开了一个二维数组，即使没有像我一样扩展board.因为问题在于不能一边更新board 一边来做。 看了一下这边的思路： https://www.hrwhisper.me/leetcode-game-of-life/ http://www.cnblogs.com/grandyang/p/4854466.html 不开数组 我们可以使用状态机转换 o(╯□╰)o 感觉不知道在听什么 还是很迷茫的感觉， in-place AC代码 class Solution(object): def gameOfLife(self, board): \"\"\" :type board: List[List[int]] :rtype: void Do not return anything, modify board in-place instead. \"\"\" row = len(board) col = len(board[0]) if row else 0 dx = [-1,-1,-1,0,1,1,1,0] dy = [-1,0,1,1,1,0,-1,-1] for i in range(row): for j in range(col): cnt = 0 for k in range(8): x, y = i + dx[k], j + dy[k] if x >=0 and x =0 and y 3): board[i][j] = 2 elif board[i][j] == 0 and cnt == 3: board[i][j] = 3 for i in range(row): for j in range(col): board[i][j] %= 2 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"290._word_pattern.html":{"url":"290._word_pattern.html","title":"290 word pattern","keywords":"","body":"290. Word Pattern 题目： https://leetcode.com/problems/word-pattern/ 难度 : Easy 4.pattern = \"abba\", str = \"dog dog dog dog\" should return false. 因为这个的限制，所以中间加了一个loop用来查询是否这个a对应的已经出现过了。 不过其实也可以用两个dictionary来处理，可以O(n^3) -> O(n^2) class Solution(object): def wordPattern(self, pattern, str): \"\"\" :type pattern: str :type str: str :rtype: bool \"\"\" strList = str.split(' ') if len(pattern) != len(strList): return False lookup = {} for i in range(len(strList)): if pattern[i] not in lookup: for key in lookup: if lookup[key] == strList[i]: return False lookup[pattern[i]] = strList[i] elif lookup[pattern[i]] != strList[i]: return False return True 另外看到一段非常简短代码，使用了map函数，有待学习 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"292._nim_game.html":{"url":"292._nim_game.html","title":"292 nim game","keywords":"","body":"292. Nim Game 题目: https://leetcode.com/problems/nim-game/ 难度: Easy 对于总是优先开始的那方 有一到三块，总是赢 有四块，总是输 有五块，总是赢 所以如果自己想赢，总是要迫使对方拿之后，给自己遗留5块，或者三块以及以下。 如果是六块： 拿一块，对方五块，对方赢 拿两块，对方余下四块，我方赢 拿三块，余三块，对方赢 七块： 拿三块，余四块，迫使对方输，总是赢 本打算用递归来看，因为对方也可以重复使用这个函数，但是会超时，所以就看了一下hint n n == 4 总输 n = 5,6,7 总赢 n == 8， 先手如何选，总可以转成5,6,7 对方总会赢 所以 n % 4 == 0 时候，先手必输 简直是啊，有些游戏就是这样来必赢的啊，没想到你是这样的题目 class Solution(object): def canWinNim(self, n): \"\"\" :type n: int :rtype: bool \"\"\" return n % 4 != 0 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"293._Flip_Game.html":{"url":"293._Flip_Game.html","title":"293 Flip Game","keywords":"","body":"293. Flip Game 题目: https://leetcode.com/problems/flip-game/ 难度: Easy 思路 class Solution(object): def generatePossibleNextMoves(self, s): \"\"\" :type s: str :rtype: List[str] \"\"\" res = [] if not s or len(s) 这里要注意一个点：s[i+2:] 虽然i+2取不到，但是s[i+2:]就是一个空字符串。 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"296._Best_Meeting_Point.html":{"url":"296._Best_Meeting_Point.html","title":"296 Best Meeting Point","keywords":"","body":"296. Best Meeting Point 题目： https://leetcode.com/problems/best-meeting-point/ 难度 : Hard 思路： 提示是先从一维开始，其实一开始是略迷茫的，因为如果两个点，那么只要在这两个之间，一定就是最小值，线段长度。 不过倘若点增加到三个，那么就是第三个点处。 然后发现了一个很棒的stackoverflow page http://stackoverflow.com/questions/10402087/algorithm-for-minimum-manhattan-distance 因为一开始理解错误二维数组的输入，以为是给的locs这样的数组，所以直接这样写了，然后发现给的是格子，所以但是还是偷懒这样写了。 AC 代码 class Solution(object): def minTotalDistance(self, grid): \"\"\" :type grid: List[List[int]] :rtype: int \"\"\" res = 0 locs = [] m = len(grid) n = len(grid[0]) if m else 0 for i in range(m): for j in range(n): if grid[i][j] == 1: locs.append([i,j]) locs.sort(key = lambda point: point[0]) x = locs[len(locs)/2][0] for point in locs: res += abs(point[0] - x) locs.sort(key = lambda point: point[1]) y = locs[len(locs)/2][1] for point in locs: res += abs(point[1] - y) return res 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"298._Binary_Tree_Longest_Consecutive_Sequence.html":{"url":"298._Binary_Tree_Longest_Consecutive_Sequence.html","title":"298 Binary Tree Longest Consecutive Sequence","keywords":"","body":"298. Binary Tree Longest Consecutive Sequence 题目： https://leetcode.com/problems/binary-tree-longest-consecutive-sequence/ 难度 : Medium 思路： TLE代码，每个node求，然后求最大值 # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution(object): def longestConsecutive(self, root): \"\"\" :type root: TreeNode :rtype: int \"\"\" def consecutive(root): if root == None: return 0 else: left, right = 0,0 if root.left: if root.left.val == root.val + 1: left = 1 + consecutive(root.left) if root.right: if root.right.val == root.val + 1: right = 1 + consecutive(root.right) return max(left, right, 1) def dfs(root): s = [] s.append(root) while s: root = s.pop() res.append(consecutive(root)) if root.left: s.append(root.left) if root.right: s.append(root.right) if not root: return 0 res = [] dfs(root) return max(res) 其实第二次递归，也就是dfs其实是有点多余的？因为可以边走边保存最大值？ 因为可以 recursion,在参数中包含当前的连续seq长度 如果left, right child的value是连续的，那么就将长度+1传入下一个call AC代码 # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution(object): def longestConsecutive(self, root): \"\"\" :type root: TreeNode :rtype: int \"\"\" def dfs(root, curLen): self.result = max(curLen, self.result) if root.left: if root.left.val == root.val + 1: dfs(root.left, curLen + 1) else: dfs(root.left, 1) if root.right: if root.right.val == root.val + 1: dfs(root.right, curLen + 1) else: dfs(root.right,1) if not root: return 0 self.result = 0 dfs(root, 1) return self.result 这里值得注意的是这里的self.result其实相当于dfs的全局变量，也是利用了这个才做到边递归边记录边重置。 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"299._bulls_and_cows.html":{"url":"299._bulls_and_cows.html","title":"299 bulls and cows","keywords":"","body":"299. Bulls and Cows 题目: https://leetcode.com/problems/bulls-and-cows/ 难度: Easy 我花了很久时间来AC，因为想了边界条件 class Solution(object): def getHint(self, secret, guess): \"\"\" :type secret: str :type guess: str :rtype: str \"\"\" maps = {} for i in range(len(secret)): if secret[i] not in maps: maps[secret[i]] = [i] else: maps[secret[i]].append(i) mapg = {} for i in range(len(guess)): if guess[i] not in mapg: mapg[guess[i]] = [i] else: mapg[guess[i]].append(i) print maps, mapg a,b = 0,0 for key in maps.keys(): if key in mapg.keys(): common = list(set(mapg[key]) & set(maps[key])) #check for bull a += len(common) mapg[key] = [item for item in mapg[key] if item not in common] maps[key] = [item for item in maps[key] if item not in common] b += min(len(maps[key]), len(mapg[key])) return str(a) + 'A' + str(b) + 'B' 两种解法都....... 都这么短。。。。。 我Python还是用的不行啊 class Solution(object): def getHint(self, secret, guess): \"\"\" :type secret: str :type guess: str :rtype: str \"\"\" bull = sum(map(operator.eq, secret, guess)) sa = collections.Counter(secret) sb = collections.Counter(guess) cow = sum((sa & sb).values()) - bull return str(bull) + 'A' + str(cow) + 'B' bull = secret与guess下标与数值均相同的数字个数 cow = secret与guess中出现数字的公共部分 - bull 来分析一下这个解法 def getHint(self, secret, guess): bulls = sum(map(operator.eq, secret, guess)) both = sum(min(secret.count(x), guess.count(x)) for x in '0123456789') return '%dA%dB' % (bulls, both - bulls) 首先map的用法是,对于iterable中的每个元素应用function方法，将结果作为list返回 >>> def add100(x): ... return x+100 ... >>> hh = [11,22,33] >>> map(add100,hh) [111, 122, 133] 用'1123','0111' 来测试： map(operator.eq, secret, guess) [False, True, False, False] 就是将equal函数并行应用在两个string上，然后后面的解法也是粗暴简约和厉害 参考http://my.oschina.net/zyzzy/blog/115096 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"300._longest_increasing_subsequence.html":{"url":"300._longest_increasing_subsequence.html","title":"300 longest increasing subsequence","keywords":"","body":"300. Longest Increasing Subsequence 题目: https://leetcode.com/problems/longest-increasing-subsequence/ 难度: Medium 思路： 典型DP 递推关系式： 对于以num[i]结束的longest increasing subsequence的长度 dp[i] = dp[j] + 1 if num[i] > num[j] else 1 最后loop一圈，求出最长的 AC 代码 class Solution(object): def lengthOfLIS(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" if not nums: return 0 dp = [1 for i in range(len(nums))] for i in range(1, len(nums)): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[j]+1, dp[i]) return max(dp) 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"303._range_sum_query_-_immutable.html":{"url":"303._range_sum_query_-_immutable.html","title":"303 range sum query - immutable","keywords":"","body":"303. Range Sum Query - Immutable 题目： https://leetcode.com/problems/range-sum-query-immutable/ tag : DP 难度 : Easy sum(i, j) = nums[i] j = i sum(i,j) = sum[i,j-1] + nums[j] j > i Python代码 class NumArray(object): def __init__(self, nums): \"\"\" initialize your data structure here. :type nums: List[int] \"\"\" self.sums = nums for i in range(1, len(self.sums)): self.sums[i] = self.sums[i-1] + self.sums[i] def sumRange(self, i, j): \"\"\" sum of elements nums[i..j], inclusive. :type i: int :type j: int :rtype: int \"\"\" if i == 0 : return self.sums[j] else : return self.sums[j] - self.sums[i-1] 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"316._Remove_Duplicate_Letters.html":{"url":"316._Remove_Duplicate_Letters.html","title":"316 Remove Duplicate Letters","keywords":"","body":"316. Remove Duplicate Letters 题目: https://leetcode.com/problems/remove-duplicate-letters/ 难度: Hard 思路 这道题让我们移除重复字母，使得每个字符只能出现一次，而且结果要按最优的字母顺序排列，前提是不能打乱其原本的相对位置。 先用remaining统计所有出现字母出现过的次数； res就是输出结果的字母顺序(list)，最后用join连接起来作为返回值(str)； 在stack(set)中的元素意味着其已经出现在最终结果中； 对s中每个字母c，首先看它在stack中有没有出现过： 如果没有那么只要res最后一个字母的ASCII值大于c，且其剩余次数大于0，就将其在res和stack中删去，不停做此操作 如果有了那么说明已经出现在最终结果中，只需要将其统计次数减去1以防后面挪动位置要做判断 做完这些后必须要把c加入到stack和res中去，代表c已经加入到最终结果中的目前应该处于的位置 参考python的colloections之defaultdict模块 class Solution(object): def removeDuplicateLetters(self, s): \"\"\" :type s: str :rtype: str \"\"\" remaining = collections.defaultdict(int) for c in s: remaining[c] += 1 res, stack = [], set() for c in s: if c not in stack: while res and res[-1] > c and remaining[res[-1]] > 0: stack.remove(res.pop()) res.append(c) stack.add(c) remaining[c] -= 1 return ''.join(res) 还有别的一些优美的解法，参考stefan的回答 递归贪心版本 class Solution(object): def removeDuplicateLetters(self, s): \"\"\" :type s: str :rtype: str \"\"\" for c in sorted(set(s)): suffix = s[s.index(c):] if set(suffix) == set(s): return c + self.removeDuplicateLetters(suffix.replace(c, '')) return '' class Solution(object): def removeDuplicateLetters(self, s): \"\"\" :type s: str :rtype: str \"\"\" result = '' while s: i = min(map(s.rindex, set(s))) c = min(s[:i+1]) result += c s = s[s.index(c):].replace(c, '') return result class Solution(object): def removeDuplicateLetters(self, s): \"\"\" :type s: str :rtype: str \"\"\" rindex = {c: i for i, c in enumerate(s)} result = '' for i, c in enumerate(s): if c not in result: while c 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"319._Bulb_Switcher.html":{"url":"319._Bulb_Switcher.html","title":"319 Bulb Switcher","keywords":"","body":"319. Bulb Switcher 题目: https://leetcode.com/problems/Bulb-Switcher/ 难度: Medium 思路 bulb代表第一轮结束后的所有灯亮灭的情况，从第二轮开始 如果是最后一轮，则bulb的最后一个灯要switch 对于其他轮，相应的第i-1+C(i)个灯要siwitch，且C为常数，i-1+C(i)必须 但是发现这样提交会超时 Last executed input: 999999 class Solution(object): def bulbSwitch(self, n): \"\"\" :type n: int :rtype: int \"\"\" bulb = [1] * n for i in range(2,n+1): for x in range(i-1, n, i): bulb[x] = 1 if bulb[x] == 0 else 0 return bulb.count(1) 原来，这是一道智商碾压题： A bulb ends up on iff it is switched an odd number of times. Bulb i is switched in round d iff d divides i. So bulb i ends up on iff it has an odd number of >divisors. Divisors come in pairs, like i=12 has divisors 1 and 12, 2 and 6, and 3 and 4. Except if i is a >square, like 36 has divisors 1 and 36, 2 and 18, 3 and 12, 4 and 9, and double divisor 6. So bulb >i ends up on iff and only if i is a square. So just count the square numbers. 大概解释一下，当一个灯泡被执行偶数次switch操作时它是灭着的，当被执行奇数次switch操作时它是亮着的，那么这题就是要找出哪些编号的灯泡会被执行奇数次操作。 现在假如我们执行第i次操作，即从编号i开始对编号每次+i进行switch操作，对于这些灯来说， 如果其编号j（j=1,2,3,⋯,n）能够整除i，则编号j的灯需要执行switch操作。 具备这样性质的i是成对出现的，比如： 12 = 1 * 12， 12 = 2 * 6 12 = 3 * 4 所以编号为12的灯，在第1次，第12次；第2次，第6次；第3次，第4次一定会被执行Switch操作，这样的话，编号为12的灯执行偶数次switch，肯定为灭。 这样推出，完全平方数一定是亮着的，因为它有两个相同的因子，总因子数为奇数，如36 = 6 * 6，所以本题的关键在于找完全平方数的个数。 class Solution(object): def bulbSwitch(self, n): \"\"\" type n: int rtype: int \"\"\" # The number of full squares. return int(math.sqrt(n)) 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"322._Coin_Change.html":{"url":"322._Coin_Change.html","title":"322 Coin Change","keywords":"","body":"322. Coin Change 题目: https://leetcode.com/problems/coin-change/ 难度: Medium DP入门 递推方程式: dp[i] = min(dp[i-vj]+1)， vj 是硬币的面额 伪码： Set Min[i] equal to Infinity for all of i Min[0]=0 For i = 1 to S For j = 0 to N - 1 If (VjAC代码 class Solution(object): def coinChange(self, coins, amount): \"\"\" :type coins: List[int] :type amount: int :rtype: int \"\"\" dp = [ float('inf') for i in range(amount+1)] dp[0] = 0 for i in range(amount+1): for coin in coins: if coin 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"323._number_of_connected_components_in_an_undirected_graph.html":{"url":"323._number_of_connected_components_in_an_undirected_graph.html","title":"323 number of connected components in an undirected graph","keywords":"","body":"323. Number of Connected Components in an Undirected Graph 难度: 中等 刷题内容 原题连接 https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/description/ 内容描述 Given n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes), write a function to find the number of connected components in an undirected graph. Example 1: Input: n = 5 and edges = [[0, 1], [1, 2], [3, 4]] 0 3 | | 1 --- 2 4 Output: 2 Example 2: Input: n = 5 and edges = [[0, 1], [1, 2], [2, 3], [3, 4]] 0 4 | | 1 --- 2 --- 3 Output: 1 Note: You can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together in edges. 解题方案 思路 1 经典并查集题目，可以去总结部分先看看并查集的概念已经优化 class Solution(object): def countComponents(self, n, edges): \"\"\" :type n: int :type edges: List[List[int]] :rtype: int \"\"\" def find(x): # if uf[x] != x: # uf[x] = find(uf[x]) while x != uf[x]: uf[x] = uf[uf[x]] x = uf[x] return uf[x] def union(x, y): x_root = find(x) y_root = find(y) uf[x_root] = y_root uf = [i for i in range(n)] for (node1, node2) in edges: union(node1, node2) res = set([find(i) for i in range(n)]) return len(res) 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"324._Wiggle_Sort_II.html":{"url":"324._Wiggle_Sort_II.html","title":"324 Wiggle Sort II","keywords":"","body":"324. Wiggle Sort II 题目: https://leetcode.com/problems/wiggle-sort-ii/ 难度: Medium 思路： 首先这道题和Wiggle Sort要求不一样，不能有等于， 所以如果碰到一串‘1,1,1,1,1,1’，当调换顺序时候还是不会满足。 因此我们用新方法，首先将原数组排序，然后大的那一半数字降序插在奇数index上，小的那一半数字降序插在偶数index上 class Solution(object): def wiggleSort(self, nums): \"\"\" :type nums: List[int] :rtype: void Do not return anything, modify nums in-place instead. \"\"\" nums.sort() half = len(nums[::2]) nums[::2], nums[1::2] = nums[:half][::-1], nums[half:][::-1] Follow up O(n) time, O(1) space 思路： 首先想到的是将我们上面的排序方法用堆排序实现即可，建堆O(n)，调整堆O(lgN) 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"326._power_of_three.html":{"url":"326._power_of_three.html","title":"326 power of three","keywords":"","body":"326. Power of Three 题目： https://leetcode.com/problems/power-of-three/ 难度 : Easy 直接就上的递归 class Solution(object): def isPowerOfThree(self,n): \"\"\" :type n: int :rtype: bool \"\"\" if n 有一个follow up，可否不用 loop/recusion 看到了取巧的办法，因为是Given an integer,是有范围的（ 只用检查是否能被这个数整除 class Solution(object): def isPowerOfThree(self, n): \"\"\" :type n: int :rtype: bool \"\"\" return n > 0 and pow(3, 19) % n == 0 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"328._odd_even_linked_list.html":{"url":"328._odd_even_linked_list.html","title":"328 odd even linked list","keywords":"","body":"328. Odd Even Linked List 题目: https://leetcode.com/problems/odd-even-linked-list/ 难度: Medium 想法：因为相对顺序保持不变，所以可以拆list，然后再组合在一起？这样是满足题目要求的，因为linked list不像array，我们操作的时候只是用指向，没有分配新的空间。 class Solution(object): def oddEvenList(self, head): \"\"\" :type head: ListNode :rtype: ListNode \"\"\" if head == None or head.next == None or head.next.next == None: return head oddDummy = ListNode(-1) oddDummy.next = head evenDummy = ListNode(-1) evenDummy.next = head.next oddCur = oddDummy.next evenCur = evenDummy.next cur = head.next.next while cur: oddCur.next = cur oddCur = oddCur.next evenCur.next = cur.next evenCur = evenCur.next if cur.next: cur = cur.next.next else: cur = cur.next oddCur.next = evenDummy.next # print oddDummy.next.val return oddDummy.next 看别人的优雅代码 class Solution(object): def oddEvenList(self, head): \"\"\" :type head: ListNode :rtype: ListNode \"\"\" if head == None: return head # odd used to keep track of the tail of odd nodes odd = oddHead = head # record how many swaps happend even = evenHead = head.next while even and even.next: odd.next = even.next odd = odd.next even.next = odd.next even = even.next odd.next = evenHead return head intuitive and concise 1 → 2 → 3 → 4 → 5 → NULL 一开始 1 → 2 → 3 → 4 → 5 → NULL odd even even.next 1 → 3 → 4 → 5 → NULL odd ↑ 2 - 1 → 3 → 4 → 5 → NULL odd 2 - even 再loop一次： | ----------- | --------- ↓ ↓ 1 → 3 4 5 → NULL odd ↑ 2 - ↑ even 最后一步，再将两个odd的最后一个和evenHead连接起来，完工 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"334._increasing_triplet_subsequence.html":{"url":"334._increasing_triplet_subsequence.html","title":"334 increasing triplet subsequence","keywords":"","body":"334. Increasing Triplet Subsequence 题目: https://leetcode.com/problems/increasing-triplet-subsequence/ 难度: Medium 思路： 用longest increasing subsequence来求，超时 class Solution(object): def increasingTriplet(self, nums): \"\"\" :type nums: List[int] :rtype: bool \"\"\" if not nums: return False n = len(nums) dp = [1 for i in range(n)] for i in range(1,n): for j in range(i): if nums[i] > nums[j] : dp[i] = max(dp[i],dp[j] + 1) if dp[i] >= 3: return True return False 于是转而用Third Maximum Number的方法，维护一个当前最小和当前第二小，当碰到当前比较大，返回True，否则一圈走下来依旧不能满足，返回false. 想一下，如果不是求三个增长，如果是求两个的话，那么一定想到的是保存当前最小值，那么一旦后方遇到一个比较大的，就这样处理掉了。 所以对于任何一个num来说，有三种可能： 小于当前的最小值，那么更新当前最小值 小于当前第二小值，更新当前第二小值 如果以上两种都不是，那么是大于当前第二小值和最小值，于是这样就true 所以是求四个增长也是类似的么 AC代码 class Solution(object): def increasingTriplet(self, nums): \"\"\" :type nums: List[int] :rtype: bool \"\"\" # m - min, sm - second min m, sm = float('inf'), float('inf') for num in nums: print m, sm if m >= num: m = num elif sm >= num: sm = num else: return True return False 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"337._house_robber_iii.html":{"url":"337._house_robber_iii.html","title":"337 house robber iii","keywords":"","body":"337. House Robber III 题目: https://leetcode.com/problems/house-robber-iii/ 难度: Medium 思路： 参考 https://www.hrwhisper.me/leetcode-house-robber-iii/ 这个解法好像有点厉害 从root开始抢起来，最大能抢到的两个可能： 抢root和不抢root rob_root = max(rob_L + rob_R , no_rob_L + no_nob_R + root.val) no_rob_root = rob_L + rob_R 这个递归写起来就很厉害了 class Solution(object): def rob(self, root): \"\"\" :type root: TreeNode :rtype: int \"\"\" def dfs(root): if not root: return 0, 0 rob_L, no_rob_L = dfs(root.left) rob_R, no_rob_R = dfs(root.right) return max(no_rob_R + no_rob_L + root.val , rob_L + rob_R), rob_L + rob_R return dfs(root)[0] 对于每个node，我们return的是从这个node能抢到的最大值，以及不抢它能获得的最大值，这个递归简直我服 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"338._Counting_Bits.html":{"url":"338._Counting_Bits.html","title":"338 Counting Bits","keywords":"","body":"338. Counting Bits 题目: https://leetcode.com/problems/counting-bits/ 难度: Medium O(n*sizeof(integer)) 算法，其实就是把count of 1 bit拿来用： class Solution(object): def countBits(self, num): \"\"\" :type num: int :rtype: List[int] \"\"\" def hammingWeight(n): cnt = 0 while n != 0: n &= n -1 cnt += 1 return cnt res = [] for i in range(num+1): res.append(hammingWeight(i)) return res DP算法 - to be done 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"339._Nested_List_Weight_Sum.html":{"url":"339._Nested_List_Weight_Sum.html","title":"339 Nested List Weight Sum","keywords":"","body":"339. Nested List Weight Sum 题目: https://leetcode.com/problems/nested-list-weight-sum/ 难度: Easy 思路： 一开始没认真读题，直接上手开写： class Solution(object): def depthSum(self, nestedList): \"\"\" :type nestedList: List[NestedInteger] :rtype: int \"\"\" def dfs(nestedList): for item in nestedList: if item.isInteger(): self.res += item.getInteger() else: dfs(item.getList()) self.res = 0 dfs(nestedList) return self.res 然后注意到要weight by its depth. AC class Solution(object): def depthSum(self, nestedList): \"\"\" :type nestedList: List[NestedInteger] :rtype: int \"\"\" def dfs(nestedList,depth): for item in nestedList: if item.isInteger(): self.res += item.getInteger() * depth else: dfs(item.getList(), depth+1) self.res = 0 dfs(nestedList,1) return self.res 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"341._Flatten_Nested_List_Iterator.html":{"url":"341._Flatten_Nested_List_Iterator.html","title":"341 Flatten Nested List Iterator","keywords":"","body":"341. Flatten Nested List Iterator 题目: https://leetcode.com/problems/flatten-nested-list-iterator/ 难度: Medium class NestedIterator(object): def __init__(self, nestedList): \"\"\" Initialize your data structure here. :type nestedList: List[NestedInteger] \"\"\" def dfs(nestedList): for item in nestedList: if item.isInteger(): self.stack.append(item.getInteger()) else: dfs(item.getList()) self.stack = [] dfs(nestedList) def next(self): \"\"\" :rtype: int \"\"\" if self.hasNext(): return self.stack.pop(0) def hasNext(self): \"\"\" :rtype: bool \"\"\" return self.stack != [] 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"342._Power_of_Four.html":{"url":"342._Power_of_Four.html","title":"342 Power of Four","keywords":"","body":"342. Power of Four 题目： https://leetcode.com/problems/power-of-four/ 难度 : Easy 继续照抄power of three class Solution(object): def isPowerOfFour(self, num): \"\"\" :type num: int :rtype: bool \"\"\" if num 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"344._reverse_string.html":{"url":"344._reverse_string.html","title":"344 reverse string","keywords":"","body":"344. Reverse String 题目: https://leetcode.com/problems/reverse-string/ 难度: Easy 思路： 不要脸的python AC code: class Solution(object): def reverseString(self, s): \"\"\" :type s: str :rtype: str \"\"\" return s[::-1] 因为python不支持item assignment 所以如果非要用two pointer来做的话，那么会是这样 class Solution(object): def reverseString(self, s): \"\"\" :type s: str :rtype: str \"\"\" lst = list(s) n = len(lst) start, end = 0, n - 1 while start 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"345._Reverse_Vowels_of_a_String.html":{"url":"345._Reverse_Vowels_of_a_String.html","title":"345 Reverse Vowels of a String","keywords":"","body":"345. Reverse Vowels of a String 题目: https://leetcode.com/problems/Reverse-Vowels-of-a-String/ 难度: Easy 思路 字符串不可变，所以用list代替，最后join class Solution(object): def reverseVowels(self, s): \"\"\" :type s: str :rtype: str \"\"\" vowels = 'aeiou' string = list(s) i, j = 0, len(s) -1 while i 正则版本 class Solution(object): def reverseVowels(self, s): \"\"\" :type s: str :rtype: str \"\"\" vowels = re.findall('(?i)[aeiou]', s) return re.sub('(?i)[aeiou]', lambda m: vowels.pop(), s) 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"349._intersection_of_two_arrays.html":{"url":"349._intersection_of_two_arrays.html","title":"349 intersection of two arrays","keywords":"","body":"349. Intersection of Two Arrays 题目: https://leetcode.com/problems/intersection-of-two-arrays/ 难度: Easy Python一句话作弊 class Solution(object): def intersection(self, nums1, nums2): \"\"\" :type nums1: List[int] :type nums2: List[int] :rtype: List[int] \"\"\" return list(set(nums1).intersection(nums2)) 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"350._intersection_of_two_arrays_ii.html":{"url":"350._intersection_of_two_arrays_ii.html","title":"350 intersection of two arrays ii","keywords":"","body":"350. Intersection of Two Arrays II 题目: https://leetcode.com/problems/intersection-of-two-arrays-ii/ 难度: Easy sort之后用了双指针来走和看 class Solution(object): def intersect(self, nums1, nums2): \"\"\" :type nums1: List[int] :type nums2: List[int] :rtype: List[int] \"\"\" nums1.sort() nums2.sort() l1 = len(nums1) l2 = len(nums2) p1 = 0 p2 = 0 res = [] while p1 nums2[p2]: p2 += 1 else: res.append(nums1[p1]) p1 += 1 p2 += 1 return res 两行版本 class Solution(object): def intersect(self, nums1, nums2): \"\"\" :type nums1: List[int] :type nums2: List[int] :rtype: List[int] \"\"\" a, b = map(collections.Counter, (nums1, nums2)) return list((a & b).elements()) 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"353._Design_Snake_Game.html":{"url":"353._Design_Snake_Game.html","title":"353 Design Snake Game","keywords":"","body":"353. Design Snake Game 题目: https://leetcode.com/problems/design-snake-game/ 难度： Medium 思路： 纯正单纯方式 在TLE边缘AC AC代码 class SnakeGame(object): def __init__(self, width,height,food): \"\"\" Initialize your data structure here. @param width - screen width @param height - screen height @param food - A list of food positions E.g food = [[1,1], [1,0]] means the first food is positioned at [1,1], the second is at [1,0]. :type width: int :type height: int :type food: List[List[int]] \"\"\" self.width = width self.height = height self.food = food self.snake = [[0,0]] self.score = 0 def move(self, direction): \"\"\" Moves the snake. @param direction - 'U' = Up, 'L' = Left, 'R' = Right, 'D' = Down @return The game's score after the move. Return -1 if game over. Game over when snake crosses the screen boundary or bites its body. :type direction: str :rtype: int \"\"\" nextx, nexty = self.snake[0] if direction == 'U': nextx -= 1 if direction == 'L': nexty -=1 if direction == 'R': nexty +=1 if direction == 'D': nextx +=1 # nextx, nexty has food if self.food and [nextx,nexty] == self.food[0]: self.snake.insert(0,[nextx,nexty]) self.food = self.food[1:] self.score += 1 # netx, nety outside boundary else: self.snake = self.snake[:-1] self.snake.insert(0,[nextx,nexty]) if nextx self.height - 1 or nexty self.width - 1: return -1 noDupes = [] for snakePt in self.snake: # print snakePt, if snakePt not in noDupes: noDupes.append(snakePt) # print 'snake', self.snake # print 'noDpues', noDupes if len(noDupes) 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"361._Bomb_Enemy.html":{"url":"361._Bomb_Enemy.html","title":"361 Bomb Enemy","keywords":"","body":"361. Bomb Enemy 题目: https://leetcode.com/problems/bomb-enemy/ 难度: Medium 思路 首先，从每一行开始，从左到右，计算E的个数，然后一碰到W就将row_hits重置为0，一碰到0就将row_hits赋值给他 然后，从每一行开始，从右到左，原操作不变，唯一是碰到0的时候加上row_hits而不是直接等于row_hits 接下来，就是跟第二步一样的操作，只不过是变成了从每一列开始，从上到下 最后也是跟第二步一样的操作，只不过是变成了从每一列开始，并且是从下到上，然后就是每一次碰到0不但要加上col_hits的值还要决出max_hits 返回max_hits 时间复杂度是 O(m*n) * (m+n) if not grid or len(grid) == 0: return 0 max_hits = 0 nums = [[0 for i in range(len(grid[0]))] for j in range(len(grid))] for i in range(len(grid)): row_hits = 0 for j in range(len(grid[0])): if grid[i][j] == 'E': row_hits += 1 elif grid[i][j] == 'W': row_hits = 0 else: nums[i][j] = row_hits for i in range(len(grid)): row_hits = 0 for j in range(len(grid[0])-1, -1, -1): if grid[i][j] == 'E': row_hits += 1 elif grid[i][j] == 'W': row_hits = 0 else: nums[i][j] += row_hits for i in range(len(grid[0])): col_hits = 0 for j in range(len(grid)): if grid[j][i] == 'E': col_hits += 1 elif grid[j][i] == 'W': col_hits = 0 else: nums[j][i] += col_hits for i in range(len(grid[0])): col_hits = 0 for j in range(len(grid)-1, -1, -1): if grid[j][i] == 'E': col_hits +=1 elif grid[j][i] == 'W': col_hits = 0 else: nums[j][i] += col_hits max_hits = max(max_hits, nums[j][i]) return max_hits 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"364._Nested_List_Weight_Sum_II.html":{"url":"364._Nested_List_Weight_Sum_II.html","title":"364 Nested List Weight Sum II","keywords":"","body":"364. Nested List Weight Sum II 题目: https://leetcode.com/problems/nested-list-weight-sum-ii/ 难度: Medium 思路： 跟 Nested List Weight Sum I 的区别是这个是从不是数depth，是数层的高度： 比较naive的AC代码： class Solution(object): def depthSumInverse(self, nestedList): \"\"\" :type nestedList: List[NestedInteger] :rtype: int \"\"\" def level(nestedList,height): self.level = max(height, self.level) for item in nestedList: if not item.isInteger(): level(item.getList(), height + 1) def dfs(nestedList, height): for item in nestedList: if item.isInteger(): self.res += item.getInteger() * height else: dfs(item.getList(),height - 1) self.level = 1 self.res = 0 level(nestedList,1) dfs(nestedList, self.level) return self.res 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"366._Find_Leaves_of_Binary_Tree.html":{"url":"366._Find_Leaves_of_Binary_Tree.html","title":"366 Find Leaves of Binary Tree","keywords":"","body":"366. Find Leaves of Binary Tree 题目： https://leetcode.com/problems/find-leaves-of-binary-tree/ 难度 :Medium 按照它的要求，老老实实写了两个递归 findleaf 和 deleteleaf， 再组合起来 AC代码 class Solution(object): def findLeaves(self, root): \"\"\" :type root: TreeNode :rtype: List[List[int]] \"\"\" def findLeaf(root): if not root: return [] elif not root.left and not root.right: return [root.val] else: return findLeaf(root.left) + findLeaf(root.right) def removeLeaf(root): if not root: return None elif not root.left and not root.right: return None else: if root.left: root.left = removeLeaf(root.left) if root.right: root.right = removeLeaf(root.right) return root res = [] while root: res.append(findLeaf(root)) root = removeLeaf(root) return res 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"367._valid_perfect_square.html":{"url":"367._valid_perfect_square.html","title":"367 valid perfect square","keywords":"","body":"367. Valid Perfect Square 题目: https://leetcode.com/problems/valid-perfect-square/ 难度: Medium 直接用循环做也可以AC class Solution(object): def isPerfectSquare(self, num): \"\"\" :type num: int :rtype: bool \"\"\" if num == 1 or num == 4 : return True for i in xrange(num//2): if i*i == num: return True elif i*i > num: return False return False 然后发现有传说中的牛顿法 有待阅读，然后还有二分法 r = x while r*r > x: r = (r + x/r) / 2 return r*r == x 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"369._Plus_One_Linked_List.html":{"url":"369._Plus_One_Linked_List.html","title":"369 Plus One Linked List","keywords":"","body":"369.Plus One Linked List 题目： https://leetcode.com/problems/plus-one-linked-list/ 难度 : Medium 类似题目： plus one，plus one 用递归和循环写了，对于linked list，因为most significant digit在首位，递归写起来不方便，用循环尝试，然后代码并没有实质上的区别。 class Solution(object): def plusOne(self, head): \"\"\" :type head: ListNode :rtype: ListNode \"\"\" lst = [] cur = head while cur: lst.append(cur) cur = cur.next carry = 1 for i in range(len(lst)-1,-1,-1): lst[i].val += carry if lst[i].val 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"371._sum_of_two_integers.html":{"url":"371._sum_of_two_integers.html","title":"371 sum of two integers","keywords":"","body":"371. Sum of Two Integers 题目: https://leetcode.com/problems/sum-of-two-integers/ 难度: Easy 思路 谷歌答案 位运算 XOR x y output 0 0 0 1 0 1 0 1 1 1 1 0 AND x y output 0 0 0 1 0 1 0 1 1 1 1 1 如果对x和y来做加法（x和y都是一位的），那么末位会是x xor y，进位会是x and y python没有左移，用c++来看 class Solution { public: int getSum(int a, int b) { while (b != 0 ){ int c = a & b; a = a ^ b; b = c 实际上看到答案还是没有那么明白的，还是动手算算 a = 6 (0110) b = 15 (1111) 1st --------- carry = a & b = 0110 a = a ^ b = 1001 b = 1100 2nd --------- carry = a & b = 1000 a = a ^ b = 0101 b = 10000 3rd ---------- carry = a & b = 0 a = a ^ b = 10101 b = 0 这个时候a 的值是2^4 + 2^2 + 2^0 = 16+4+1 = 21 虽然convence了我自己，但是表示依旧迷茫ing 也知道位运算需要待补啊 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"374._Guess_Number_Higher_or_Lower.html":{"url":"374._Guess_Number_Higher_or_Lower.html","title":"374 Guess Number Higher or Lower","keywords":"","body":"374. Guess Number Higher or Lower 题目: https://leetcode.com/problems/guess-number-higher-or-lower/ 难度: Easy 思路 二分 class Solution(object): def guessNumber(self, n): \"\"\" :type n: int :rtype: int \"\"\" l, r = 1, n while l > 2) if guess(mid) == 1: l = mid + 1 elif guess(mid) == -1: r = mid - 1 else: return mid 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"377._combination_sum_iv.html":{"url":"377._combination_sum_iv.html","title":"377 combination sum iv","keywords":"","body":"377. Combination Sum IV 题目: https://leetcode.com/problems/combination-sum-iv/ 难度: Medium 直接用combination sum的思路： 超时 class Solution(object): def combinationSum4(self, candidates, target): \"\"\" :type candidates: List[int] :type target: int :rtype: List[List[int]] \"\"\" def combSum(candidates, target, start, valueList): length = len(candidates) if target == 0 : res.append(valueList) for i in range(start, length): if target 说起来标签是dp,也知道是dp啊,状态转移方程： 参考: http://www.cnblogs.com/grandyang/p/5705750.html 我们需要一个一维数组dp，其中dp[i]表示目标数为i的解的个数，然后我们从1遍历到target，对于每一个数i，遍历nums数组，如果i>=x, dp[i] += dp[i - x]。这个也很好理解，比如说对于[1,2,3] 4，这个例子，当我们在计算dp[3]的时候，3可以拆分为1+x，而x即为dp[2]，3也可以拆分为2+x，此时x为dp[1]，3同样可以拆为3+x，此时x为dp[0]，我们把所有的情况加起来就是组成3的所有情况了 AC代码 class Solution(object): def combinationSum4(self, candidates, target): \"\"\" :type candidates: List[int] :type target: int :rtype: List[List[int]] \"\"\" dp = [0 for i in range(target+1)] dp[0] = 1 for i in range(target+1): for candidate in candidates: if i >= candidate: dp[i] += dp[i - candidate] return dp[-1] 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"378._kth_smallest_element_in_a_sorted_matrix.html":{"url":"378._kth_smallest_element_in_a_sorted_matrix.html","title":"378 kth smallest element in a sorted matrix","keywords":"","body":"378. Kth Smallest Element in a Sorted Matrix 题目: https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/ 难度: Medium 思路一：暴力法 class Solution(object): def kthSmallest(self, matrix, k): \"\"\" :type matrix: List[List[int]] :type k: int :rtype: int \"\"\" tmp = [] for row in matrix: for column in row: tmp.append(column) tmp.sort() return tmp[k-1] if tmp and len(tmp)>0 else None 思路二： 两个tag ： binary search， heap 先来heap 利用heap,先对第一行所有元素加入heap,每个元素下面同一列的元素必然比他们大 重复K-1次下面的过程 取现在的root 将root下面的元素加入heap 可以手写一个例子来看 参考： https://lefttree.gitbooks.io/leetcode/content/dataStructure/heap/kthSmallestInMatrix.html class Solution(object): def kthSmallest(self, matrix, k): \"\"\" :type matrix: List[List[int]] :type k: int :rtype: int \"\"\" if not matrix: return 0 heap = [] row = len(matrix) col = len(matrix[0]) for i in range(col): # heap store its value and location heapq.heappush(heap, (matrix[0][i], 0, i)) print heap for j in range(k-1): cur = heappop(heap) x = cur[1] y = cur[2] if x+1 思路三： heapq一行 class Solution(object): def kthSmallest(self, matrix, k): \"\"\" :type matrix: List[List[int]] :type k: int :rtype: int \"\"\" return list(heapq.merge(*matrix))[k-1] 思路四； binary search class Solution(object): def kthSmallest(self, matrix, k): \"\"\" :type matrix: List[List[int]] :type k: int :rtype: int \"\"\" l, r = matrix[0][0], matrix[-1][-1] while l > 2) if sum(bisect.bisect_right(row, mid) for row in matrix) 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"382._linked_list_random_node.html":{"url":"382._linked_list_random_node.html","title":"382 linked list random node","keywords":"","body":"382. Linked List Random Node 题目: https://leetcode.com/problems/linked-list-random-node/ 难度: Medium tag：reservoir sampling 水塘抽样 思路： n选k 这样来看，有k个元素，那么这个时候全部选中,当第k+1个元素进来的时候，生成一个随机数r，如果 r 那么r被替换掉的概率是 1 / k + 1, 不被替换掉的概率是 k / k + 1 (不生成r) k+2来继续： 被替换掉的概率 1 / k + 2, 不被替换掉的概率 (k + 1) / (k+2) 所以最终被选中的（不被替换掉的概率是） k / n 随机 √ 针对这道题目来看 一开始选head为choice 出现第二个，生成[1,2]之间的随机数，如果r = 2，则用新的来替换choice 出现第三个，生成[1,2,3]之间的随机数，如果r = 3，则替换 再写简单一点就是 每次以 1/i 来决定是否用新的元素来替换选中元素，那么就是 i - 1 / i 不替换，它之前被选中的概率就是 1 / i-1 ，所以最终被选中的概率是 1/i 这个对于linked list更优之处在于它不用reverse 时间复杂度 O(N)， 空间复杂度O(K) 然后AC class Solution(object): def __init__(self, head): \"\"\" @param head The linked list's head. Note that the head is guaranteed to be not null, so it contains at least one node. :type head: ListNode \"\"\" self.head = head def getRandom(self): \"\"\" Returns a random node's value. :rtype: int \"\"\" choice = self.head cur = self.head i = 1 while cur.next: cur = cur.next i += 1 rd = random.randint(1,i) if rd == i: choice = cur return choice.val 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"383._ransom_note.html":{"url":"383._ransom_note.html","title":"383 ransom note","keywords":"","body":"383. Ransom Note 题目： https://leetcode.com/problems/ransom-note/ 难度 : Easy 略微想了一下，用了一个dictionary来存magazine里面的单字出现的个数，然后来对应check是否可以用来组成ransomNote class Solution(object): def canConstruct(self, ransomNote, magazine): \"\"\" :type ransomNote: str :type magazine: str :rtype: bool \"\"\" maps = {} for i in magazine: if i in maps: maps[i] += 1 else: maps[i] = 1 for i in ransomNote: if i not in maps: return False else: maps[i] -= 1 if maps[i] 解法2： class Solution(object): def canConstruct(self, ransomNote, magazine): \"\"\" :type ransomNote: str :type magazine: str :rtype: bool \"\"\" magCounter = collections.Counter(magazine) ranCounter = collections.Counter(ransomNote) for k in ranCounter: if ranCounter.get(k) > magCounter.get(k): return False return True 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"384._Shuffle_an_Array.html":{"url":"384._Shuffle_an_Array.html","title":"384 Shuffle an Array","keywords":"","body":"384. Shuffle an Array 题目： https://leetcode.com/problems/shuffle-an-array/ 难度 : Medium 思路： 这就是洗牌算法吧，洗牌算法几种常见的： http://www.cnblogs.com/tudas/p/3-shuffle-algorithm.html http://www.matrix67.com/blog/archives/879 也是有wikipedia page的: https://en.wikipedia.org/wiki/Fisher–Yates_shuffle 最简单的算法是很容易想到的， O(N^2) 然后就是modern 算法： -- To shuffle an array a of n elements (indices 0..n-1): for i from n−1 downto 1 do j ← random integer such that 0 ≤ j ≤ i exchange a[j] and a[i] 这个感觉还是比较容易证明的，一开始生成的数字 1/n 概率 没选中，下一个 n-1 /n * 1/ n-1 = 1/n， 所以每个位置都是等概率的？ 这个有很妙的点： 比如五个人顺序抽签，只要不uncover 结果，那么就是等概率的。 但是第一个人抽奖之后uncover结果，比如他没有抽中 → 那么概率就会变。 AC代码： class Solution(object): def __init__(self, nums): \"\"\" :type nums: List[int] :type size: int \"\"\" self.lst = nums def reset(self): \"\"\" Resets the array to its original configuration and return it. :rtype: List[int] \"\"\" return self.lst def shuffle(self): \"\"\" Returns a random shuffling of the array. :rtype: List[int] \"\"\" import random res = self.lst[:] n = len(res) for i in range(n-1,0,-1): j = random.randint(0,i) res[i], res[j] = res[j], res[i] return res 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"386._Lexicographical_Numbers.html":{"url":"386._Lexicographical_Numbers.html","title":"386 Lexicographical Numbers","keywords":"","body":"386. Lexicographical Numbers 字典序排数 难度: 中等 刷题内容 原题连接 https://leetcode.com/problems/lexicographical-numbers/description/ https://leetcode-cn.com/problems/lexicographical-numbers/description/ 内容描述 给定一个整数 n, 返回从 1 到 n 的字典顺序。 例如， 给定 n =1 3，返回 [1,10,11,12,13,2,3,4,5,6,7,8,9] 。 请尽可能的优化算法的时间复杂度和空间复杂度。 输入的数据 n 小于等于 5,000,000。 解题方案 思路 1 那当然是直接转换成string比较排序啊，多么暴力，简单明了, beats 66.87% 时间复杂度：O(NlogN) 空间复杂度：O(N)class Solution(object): def lexicalOrder(self, n): \"\"\" :type n: int :rtype: List[int] \"\"\" return sorted(range(1, n+1), key=lambda x: str(x)) 思路 2 其实我们每次只要知道下一个数是啥就行了 例如对于67这个数， 它的下一个数要么是670（如果670 要么是68（如果68 (cur + 1) % 10 != 0, 然后对于尾数是9的数字我们要一直除以10让它尾数不是9之后再加1，即199 --> 2的过程 要么是7（当然7肯定小于n了，因为67都出现了） 时间复杂度：O(N) 空间复杂度：O(1) 这个方法beats 94.59% class Solution(object): def lexicalOrder(self, n): \"\"\" :type n: int :rtype: List[int] \"\"\" res = [] cur = 1 for i in range(n): res.append(cur) if (cur * 10 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"387._first_unique_character_in_a_string.html":{"url":"387._first_unique_character_in_a_string.html","title":"387 first unique character in a string","keywords":"","body":"387. First Unique Character in a String 题目: https://leetcode.com/problems/first-unique-character-in-a-string/ 难度: Easy 思路一： Python作弊法 用Python的Counter模块 可以参考 https://pymotw.com/2/collections/counter.html class Solution(object): def firstUniqChar(self, s): \"\"\" :type s: str :rtype: int \"\"\" d = collections.Counter(s) for x,c in enumerate(s): if d[c] == 1: return x return -1 思路二： 利用问题的特性，因为只有可能是小写字母，所以可以用一个长度为26的array, 先数一遍char的数量，然后enumerate从左往右又来 class Solution(object): def firstUniqChar(self, s): \"\"\" :type s: str :rtype: int \"\"\" cnt = [0 for i in range(26)] for char in s: cnt[ord(char) - ord('a')] += 1 for idx, char in enumerate(s): if cnt[ord(char) - ord('a')] == 1: return idx return -1 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"388._Longest_Absolute_File_Path.html":{"url":"388._Longest_Absolute_File_Path.html","title":"388 Longest Absolute File Path","keywords":"","body":"388. Longest Absolute File Path 题目: https://leetcode.com/problems/longest-absolute-file-path/ 难度: Medium 思路 我们首先观察到每个文件夹或者是文件前面都会有一个'\\n', 还有对应其层数个数的'\\t'. 所以首先根据'\\n'分行，然后算出该文件/文件夹的层数depth 如果是文件，我们需要更新maxlen 如果是文件夹，我们需要更新该depth下的pathlen 程序变量解释 maxlen 代表目前最大子串的长度 pathlen 每一个depth下对应的path长度 特别需要注意的是，'\\t'的长度是1 有的人仍然会有疑问，每次碰到文件夹都直接更新pathlen会不会导致本来长的反而变得短了，但是我们可以看到字符串的排版格式，每层path都是严格有自己的分级的， 因此不会出现这样的问题。 例如: The string \"dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile2.ext\" represents: dir subdir1 file1.ext subsubdir1 subdir2 subsubdir2 file2.ext 其最大长度是32, \"dir/subdir2/subsubdir2/file2.ext\" 如果变成\"dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\\n\\tsubdir20\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile2.ext\"， dir subdir1 file1.ext subsubdir1 subdir20 subsubdir2 file2.ext 最大长度就是33, - 如果变成 ```\"dir\\n\\tsubdir1000000000000\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile2.ext\" dir subdir10000000000000 file1.ext subsubdir1 subdir20 subsubdir2 file2.ext 最大长度就是34,\"dir/subdir10000000000000/file1.ext\" class Solution(object): def lengthLongestPath(self, input): \"\"\" :type input: str :rtype: int \"\"\" maxlen = 0 pathlen = {0 : 0} for line in input.splitlines(): name = line.lstrip('\\t') depth = len(line) - len(name) # 前面有几个'\\t', depth就是几 if '.' in name: maxlen = max(maxlen, pathlen[depth] + len(name)) else: pathlen[depth+1] = pathlen[depth] + len(name) + 1 #加1是为了加上一个path分隔符'/'的长度 return maxlen 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"389._find_the_difference.html":{"url":"389._find_the_difference.html","title":"389 find the difference","keywords":"","body":"389. Find the Difference 题目: https://leetcode.com/problems/find-the-difference/ 难度: Easy 用个字典来记录，把s加进去，把t减掉，最后剩下那个要么个数为1，要么个数为-1 class Solution(object): def findTheDifference(self, s, t): \"\"\" :type s: str :type t: str :rtype: str \"\"\" res = {} for i in s: res[i] = res.get(i, 0) + 1 for j in t: res[j] = res.get(j, 0) - 1 for key in res: if abs(res[key]) == 1: # 这里用 abs 是因为新增加的那个字母在 s 中可能未出现过 return key 还有一个简单的方法 class Solution(object): def findTheDifference(self, s, t): \"\"\" :type s: str :type t: str :rtype: str \"\"\" from collections import Counter return list((Counter(t) - Counter(s)).keys()).pop() 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"392._is_subsequence.html":{"url":"392._is_subsequence.html","title":"392 is subsequence","keywords":"","body":"392. Is Subsequence 难度: 中等 刷题内容 原题连接 https://leetcode.com/problems/is-subsequence/description/ 内容描述 Given a string s and a string t, check if s is subsequence of t. You may assume that there is only lower case English letters in both s and t. t is potentially a very long (length ~= 500,000) string, and s is a short string (= 1B, and you want to check one by one to see if T has its subsequence. In this scenario, how would you change your code? 解题方案 思路 1 follow up question很有意思 最naive的思路表现形式如下： beats 53.74% class Solution(object): def isSubsequence(self, s, t): \"\"\" :type s: str :type t: str :rtype: bool \"\"\" if s == '': return True for i in xrange(len(t)): if t[i] == s[0]: return self.isSubsequence(s[1:],t[i+1:]) return False 思路 2 递归操作以及对字符串的操作太过于昂贵，所以用index来处理，节省了时间和空间 class Solution(object): def isSubsequence(self, s, t): \"\"\" :type s: str :type t: str :rtype: bool \"\"\" if s == '': return True ps, pt = 0, 0 while ps = len(s) 精妙绝伦！！ 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"394._decode_string.html":{"url":"394._decode_string.html","title":"394 decode string","keywords":"","body":"394. Decode String 题目: https://leetcode.com/problems/decode-string/ 难度: Medium 思路: 感觉像用栈做运算。 s = \"3[a2[c]]\" ⬇️ s = 3 ( a + 2 ( c ) ) 遇到非右括号全部入栈，碰到右括号出栈直到左括号，这个就算运算符2 → op2 然后检查，直到stack空掉或者碰到下一个非数字，这个就算运算符1 → op1 算出op1 和 op2 之后把这个res继续入栈。然后接着处理 代码不是很优美 class Solution(object): def decodeString(self, s): \"\"\" :type s: str :rtype: str \"\"\" s = list(s) stack = [] while s: char = s.pop(0) if char != ']': stack.append(char) else: op1, op2 = '','' popChar = stack.pop() while popChar != '[': op2 = popChar + op2 popChar = stack.pop() while stack and stack[-1] in ['0','1','2','3','4','5','6','7','8','9']: popChar = stack.pop() op1 = popChar + op1 res = int(op1) * op2 for char in res: stack.append(char) return ''.join(stack) 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"400._Nth_Digit.html":{"url":"400._Nth_Digit.html","title":"400 Nth Digit","keywords":"","body":"400. Nth Digit 题目: https://leetcode.com/problems/nth-digit/ 难度: Easy 思路： 这道简单题我服， tag是math，找规律 1- 9 : 9 → 只占1位 9 10 - 99: 90 → 两位 90 * 2 100 - 999: 900 → 三位 900 * 3 1000 - 9999: 9000 → 四位 9000 * 4 AC代码来之不易，是参考别人的，这里的for i in range(9)， 其实无论range多少都可以吧 class Solution(object): def findNthDigit(self, n): \"\"\" :type n: int :rtype: int \"\"\" for i in range(9): d = 9 * 10 ** i if n 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"401._binary_watch.html":{"url":"401._binary_watch.html","title":"401 binary watch","keywords":"","body":"401. Binary Watch 题目: https://leetcode.com/problems/binary-watch/ 难度: Easy 思路： 一看到位操作，我的内心是拒绝的。 我也有想这样的想法，因为其实可以的组合并没有那么多，干脆枚举算了，然而也没有动手来写，直到被发了题解的截屏。 class Solution(object): def readBinaryWatch(self, num): \"\"\" :type num: int :rtype: List[str] \"\"\" hour = { 0 : ['0'], 1:['1','2','4','8'], 2:['3','5','6','9','10'], 3:['7','11'] } minute = { 0:['00'], 1: ['01','02','04','08','16','32'], 2: ['03','05','06','09','10','12','17','18','20','24','33','34','36','40','48'], 3: ['07','11','13','14','19','21','22','25','26','28','35','37','38','41','42','44','49','50','52','56'], 4: ['15','23','27','29','30','39','43','45','46','51','53','54','57','58'], 5: ['31','47','55','59'] } res = [] #num = num for hour + num for minute i = 0 while i 关于循环那处，因为hour的led最多只有4个，所以这样写循环 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"404._sum_of_left_leaves.html":{"url":"404._sum_of_left_leaves.html","title":"404 sum of left leaves","keywords":"","body":"404. Sum of Left Leaves 题目: https://leetcode.com/problems/sum-of-left-leaves/ 难度: Easy 思路： 典型递归，检查root的左孩子是不是node，是的话加上它的值，不是的话递归去求它的孩子们的，对于右边，递归的求sum of left leaves class Solution(object): def sumOfLeftLeaves(self, root): \"\"\" :type root: TreeNode :rtype: int \"\"\" def isLeaf(node): if node == None: return False if node.left == None and node.right == None: return True return False res = 0 if root: if isLeaf(root.left): res += root.left.val else: res += self.sumOfLeftLeaves(root.left) if root.right: res += self.sumOfLeftLeaves(root.right) return res 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"405._Convert_a_Number_to_Hexadecimal.html":{"url":"405._Convert_a_Number_to_Hexadecimal.html","title":"405 Convert a Number to Hexadecimal","keywords":"","body":"405. Convert a Number to Hexadecimal 题目: https://leetcode.com/problems/convert-a-number-to-hexadecimal/ 难度: Easy wikipedia两个page: 十六进制 例子： 4877÷16=304....13(D) 304÷16=19....0 19÷16=1....3 1÷16=0....1 這樣就計到4877(10)=130D(16) 补码 一個數字的二補數就是將該數字作位元反相運算（即一補數或反码），再將結果加1。在二補數系統中，一個負數就是用其對應正數的二補數來表示 看给的这个-1的例子 0000 0000 0000 0000 0000 0000 0000 0001 1111 1111 1111 1111 1111 1111 1111 1110 +1 1111 1111 1111 1111 1111 1111 1111 1111 f f f f f f f f 也可以参考这里: 基础03：原码、反码、补码 这里我一开始迷茫和晕了一下，但是随后反应过来，这些数字在电脑里使用二进制存的，而负数也是用二进制的补码存的。所以其实AC代码应当很简单。 参考： https://github.com/kamyu104/LeetCode/blob/master/Python/convert-a-number-to-hexadecimal.py AC代码： class Solution(object): def toHex(self, num): \"\"\" :type num: int :rtype: str \"\"\" if not num : return \"0\" result = [] hexStr =\"0123456789abcdef\" while num and len(result) != 8: h = num & 15 result.append(hexStr[h]) num >>= 4 return ''.join(result[::-1]) 每次看后四位的结果，把它存起来,比如还是是看4877 它在计算机内部的表示是： 0b1001100001101 num & 15 1101 & 15 = 13(d) num >>=4 0b100110000 num & 15 0000 & 15 = 0 num >>=4 0b10011 num & 15 10011 & 15 = 9 num >>=4 0001 num & 15 0001 & 15 = 1 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"406._Queue_Reconstruction_by_Height.html":{"url":"406._Queue_Reconstruction_by_Height.html","title":"406 Queue Reconstruction by Height","keywords":"","body":"406. Queue Reconstruction by Height 题目: https://leetcode.com/problems/queue-reconstruction-by-height/ 难度: Medium 思路： People are only counting (in their k-value) taller or equal-height others standing in front of them. So a smallest person is completely irrelevant for all taller ones. And of all smallest people, the one standing most in the back is even completely irrelevant for everybody else. Nobody is counting that person. So we can first arrange everybody else, ignoring that one person. And then just insert that person appropriately. Now note that while this person is irrelevant for everybody else, everybody else is relevant for this person - this person counts exactly everybody in front of them. So their count-value tells you exactly the index they must be standing. So you can first solve the sub-problem with all but that one person and then just insert that person appropriately. And you can solve that sub-problem the same way, first solving the sub-sub-problem with all but the last-smallest person of the subproblem. And so on. The base case is when you have the sub-…-sub-problem of zero people. You’re then inserting the people in the reverse order, i.e., that overall last-smallest person in the very end and thus the first-tallest person in the very beginning. That’s what the above solution does, Sorting the people from the first-tallest to the last-smallest, and inserting them one by one as appropriate. 参考stefan class Solution(object): def reconstructQueue(self, people): \"\"\" :type people: List[List[int]] :rtype: List[List[int]] \"\"\" people.sort(key=lambda (h, k): (-h, k)) queue = [] for p in people: queue.insert(p[1], p) return queue 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"412._fizz_buzz.html":{"url":"412._fizz_buzz.html","title":"412 fizz buzz","keywords":"","body":"412. Fizz Buzz 题目: https://leetcode.com/problems/fizz-buzz/ 难度: Easy 一行 class Solution(object): def fizzBuzz(self, n): \"\"\" :type n: int :rtype: List[str] \"\"\" return [(not i%3)*\"Fizz\" + (not i%5)*\"Buzz\" or str(i) for i in range(1, n+1)] class Solution(object): def fizzBuzz(self, n): \"\"\" :type n: int :rtype: List[str] \"\"\" return [str(i) if (i%3!=0 and i%5!=0) else (('Fizz'*(i%3==0)) + ('Buzz'*(i%5==0))) for i in range(1,n+1)] 就是easy，不过可以参见这里，有一些讨论 http://codereview.stackexchange.com/questions/763/two-fizzbuzz-solutions 我觉得这里一个用yield的想法还蛮不错 # the fizbuz logic, returns an iterator object that # calculates one value at a time, not all ot them at once def fiz(numbers): for i in numbers: if i % 15 == 0: yield 'fizbuz' elif i % 5 == 0: yield 'buz' elif i % 3 == 0: yield 'fiz' else: yield str(i) # xrange evaluates lazily, good for big numbers # matches well with the lazy-eval generator function numbers = xrange(1,2**20) # this gets one number, turns that one number into fuz, repeat print ' '.join(fiz(numbers)) # returns: 1 2 fiz 4 buz fiz [...] fiz 1048573 1048574 fizbuz clearly separates fizbuz logic from concatenation is as plain and readeable as possible generator iterator does not keep all the array in memory so that you can do it on arbitrary numbers (see Euler problem #10) What I do not like in this solution is the three ifs, whereas the problem can be solved with two. Answer: because yield is efficient when you do not want to keep big arrays in memory just to iterate through them. But this question is not about big arrays. 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"413._Arithmetic_Slices.html":{"url":"413._Arithmetic_Slices.html","title":"413 Arithmetic Slices","keywords":"","body":"413. Arithmetic Slices 题目： https://leetcode.com/problems/arithmetic-slices/ 难度 : Medium 思路： tag 是DP 数从 i 到 j 之间的这个arithmetic 数 我的方法时间复杂度比较高O(N^2)，从 i 开始数它的arithmetic slice，每个i数一遍，到 j AC代码 class Solution(object): def numberOfArithmeticSlices(self, A): \"\"\" :type A: List[int] :rtype: int \"\"\" n = len(A) if n 应该可以优化到O(N) 不需要每个每个开始数，可以边数边移动 可以参考http://www.cnblogs.com/grandyang/p/5968340.html O(N) 代码 class Solution(object): def numberOfArithmeticSlices(self, A): \"\"\" :type A: List[int] :rtype: int \"\"\" n = len(A) if n 2: res += (cnt-1) * (cnt-2) / 2 cnt = 2 if cnt > 2: res += (cnt-1) * (cnt-2) / 2 return res 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"414._third_maximum_number.html":{"url":"414._third_maximum_number.html","title":"414 third maximum number","keywords":"","body":"414. Third Maximum Number 题目: https://leetcode.com/problems/third-maximum-number/ 难度: Easy 思路: 用三个变量来记录，max， secondmax, thirdmax， 遇到比max还大的就更新，当前max降级为secondmax，当前secondmax降级为thirdmax 遇到比max小但是比secondmax大的也这样做降级处理 更thirdmax AC代码 class Solution(object): def thirdMax(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" m, sm, tm = float('-inf'), float('-inf'), float('-inf') for num in nums: if num > m: tm = sm sm = m m = num elif num sm: tm = sm sm = num elif num tm: tm = num return tm if tm != float('-inf') else m 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"415._add_strings.html":{"url":"415._add_strings.html","title":"415 add strings","keywords":"","body":"415. Add Strings 难度: Easy 刷题内容 原题连接 https://leetcode.com/problems/add-strings/description/ 内容描述 Given two non-negative integers num1 and num2 represented as string, return the sum of num1 and num2. Note: The length of both num1 and num2 is 解题方案 思路 1 题目说不能直接将input转换为int，那我就一次只转换一位，真tm简单！ class Solution(object): def addStrings(self, num1, num2): \"\"\" :type num1: str :type num2: str :rtype: str \"\"\" def str2int(num): res = 0 for i in range(len(num)-1, -1, -1): res += int(num[i]) * pow(10, len(num)-1-i) return res return str(str2int(num1) + str2int(num2)) 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"416._Partition_Equal_Subset_Sum.html":{"url":"416._Partition_Equal_Subset_Sum.html","title":"416 Partition Equal Subset Sum","keywords":"","body":"416. Partition Equal Subset Sum 难度: 中等 刷题内容 原题连接 https://leetcode.com/problems/partition-equal-subset-sum/description/ 内容描述 Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal. Note: Each of the array element will not exceed 100. The array size will not exceed 200. Example 1: Input: [1, 5, 11, 5] Output: true Explanation: The array can be partitioned as [1, 5, 5] and [11]. Example 2: Input: [1, 2, 3, 5] Output: false Explanation: The array cannot be partitioned into equal sum subsets. 解题方案 思路 1 动态规划 dp[i]代表nums中能否找出一个subset的sum等于i，例如dp[0] = True是必然的，因为我们只要取空子集，那么其sum一定为0 class Solution(object): def canPartition(self, nums): \"\"\" :type nums: List[int] :rtype: bool \"\"\" if not nums or len(nums) == 0: return True if sum(nums) % 2 != 0: ## 总和必须为偶数，否则肯定无法取两个集合的sum相等 return False half_sum = sum(nums)/2 dp = [False] * (half_sum+1) dp[0] = True for i in range(len(nums)): for j in range(half_sum, nums[i]-1, -1): dp[j] = dp[j] or dp[j-nums[i]] print(dp) return dp[half_sum] 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"421._Maximum_XOR_of_Two_Numbers_in_an_Array.html":{"url":"421._Maximum_XOR_of_Two_Numbers_in_an_Array.html","title":"421 Maximum XOR of Two Numbers in an Array","keywords":"","body":"421. Maximum XOR of Two Numbers in an Array 题目: https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/ 难度: Medium 题目要求O(N)时间 看了半天的解法居然超时， class Solution(object): # 此法超时 def findMaximumXOR(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" '''The maxResult is a record of the largest XOR we got so far. if it's 11100 at i = 2, it means before we reach the last two bits, 11100 is the biggest XOR we have, and we're going to explore whether we can get another two '1's and put them into maxResult''' max_res, mask = 0, 0 '''This is a greedy part, since we're looking for the largest XOR, we start from the very begining, aka, the 31st postition of bits.''' for i in range(32)[::-1]: '''The mask will grow like 100..000 , 110..000, 111..000, then 1111...111 for each iteration, we only care about the left parts''' mask |= (1 只好想别的办法 参考stefan class Solution(object): def findMaximumXOR(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" answer = 0 for i in range(32)[::-1]: answer > i for num in nums} answer += any(answer^1 ^ p in prefixes for p in prefixes) return answer 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"422._Valid_Word_Square.html":{"url":"422._Valid_Word_Square.html","title":"422 Valid Word Square","keywords":"","body":"422. Valid Word Square 题目： https://leetcode.com/problems/valid-word-square/ 难度 : Easy 思路： 就是对比一个矩阵内 xy == yx? try /except 真是好用 AC代码 class Solution(object): def validWordSquare(self, words): \"\"\" :type words: List[str] :rtype: bool \"\"\" n = len(words) for i in xrange(n): m = len(words[i]) for j in xrange(m): try: if words[i][j] != words[j][i]: return False except: return False return True 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"434._number_of_segments_in_a_string.html":{"url":"434._number_of_segments_in_a_string.html","title":"434 number of segments in a string","keywords":"","body":"434. Number of Segments in a String 题目: https://leetcode.com/problems/number-of-segments-in-a-string/ 难度: Easy 作弊神器Python class Solution(object): def countSegments(self, s): \"\"\" :type s: str :rtype: int \"\"\" return len(s.split()) 不过对于比如C++这种语言来说，应该是O(N),扫一圈应该也能得到正确答案 总之拿Python做string的题目就是作弊啊 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"435._Non-overlapping_Intervals.html":{"url":"435._Non-overlapping_Intervals.html","title":"435 Non-overlapping Intervals","keywords":"","body":"435. Non-overlapping Intervals 难度: 中等 刷题内容 原题连接 https://leetcode.com/problems/non-overlapping-intervals/description/ 内容描述 Given a collection of intervals, find the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping. Note: You may assume the interval's end point is always bigger than its start point. Intervals like [1,2] and [2,3] have borders \"touching\" but they don't overlap each other. Example 1: Input: [ [1,2], [2,3], [3,4], [1,3] ] Output: 1 Explanation: [1,3] can be removed and the rest of intervals are non-overlapping. Example 2: Input: [ [1,2], [1,2], [1,2] ] Output: 2 Explanation: You need to remove two [1,2] to make the rest of intervals non-overlapping. Example 3: Input: [ [1,2], [2,3] ] Output: 0 Explanation: You don't need to remove any of the intervals since they're already non-overlapping. 解题方案 思路 1 先按照start排序，然后每次如果下一个的start小于前一个的end的时候意味着我们需要删掉一个了，但是我们尽量留下end比较小的那个Interval，具体看代码会比较清晰 # Definition for an interval. # class Interval(object): # def __init__(self, s=0, e=0): # self.start = s # self.end = e class Solution(object): def eraseOverlapIntervals(self, intervals): \"\"\" :type intervals: List[Interval] :rtype: int \"\"\" if not intervals or len(intervals) == 0: return 0 res = 0 intervals = sorted(intervals, key=lambda x:x.start) cur_end = intervals[0].end for i in range(1, len(intervals)): if intervals[i].start 思路 2 又发现有大佬比我牛p多了，代码更nice，跟646题比较像 首先按照end排序，我们可以知道的，一旦后面一个Interval的start比前一个的end小的话，这个时候我们就需要删除掉当前的这个Interval, 反之则前面的那些Interval已经成立了，我们只需要更新cur_end为当前Interval的end class Solution(object): def eraseOverlapIntervals(self, intervals): \"\"\" :type intervals: List[Interval] :rtype: int \"\"\" intervals.sort(key = lambda x: x.end) res, cur_end = 0, -float(\"inf\") for i in intervals: if cur_end > i.start: res += 1 else: cur_end = i.end return res 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"437._path_sum_iii.html":{"url":"437._path_sum_iii.html","title":"437 path sum iii","keywords":"","body":"437. Path Sum III 题目: https://leetcode.com/problems/path-sum-iii/ 难度: Easy 思路： class Solution(object): def pathSum(self, root, sum): \"\"\" :type root: TreeNode :type sum: int :rtype: int \"\"\" if not root: return 0 res = self.auxPathSum(root, sum) res += self.pathSum(root.left, sum) res += self.pathSum(root.right, sum) return res def auxPathSum(self, root, sum): if not root: return 0 if sum == root.val: # 因为可能有负值, 所以sum为0也会有解, 必须加上 return 1 + self.auxPathSum(root.left, 0) + self.auxPathSum(root.right, 0) else: return self.auxPathSum(root.left, sum - root.val) + self.auxPathSum(root.right, sum - root.val) 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"438._Find_All_Anagrams_in_a_String.html":{"url":"438._Find_All_Anagrams_in_a_String.html","title":"438 Find All Anagrams in a String","keywords":"","body":"438. Find All Anagrams in a String 题目: https://leetcode.com/problems/Find-All-Anagrams-in-a-String/ 难度: Easy 思路 刚开始打算直接遍历整个s，时间复杂度为O(m*n),m和n分别为字符串p和s的长度，但是超时了 class Solution(object): # 此法超时 def findAnagrams(self, s, p): \"\"\" :type s: str :type p: str :rtype: List[int] \"\"\" l, res = len(p), [] for i in range(len(s)): if collections.Counter(s[i:i+l]) == collections.Counter(p): res.append(i) return res 于是用双指针，left和right都从0开始往后遍历 class Solution(object): def findAnagrams(self, s, p): \"\"\" :type s: str :type p: str :rtype: List[int] \"\"\" res, cnts = [], [0] * 26 for c in p: cnts[ord(c) - ord('a')] += 1 left, right = 0, 0 while right 模板大法好 class Solution(object): def findAnagrams(self, s, p): \"\"\" :type s: str :type p: str :rtype: List[int] \"\"\" res = [] if len(p) > len(s): return res maps = collections.Counter(p) counter = len(maps.keys()) begin, end, head, length = 0, 0, 0, sys.maxint while end 0: counter += 1 if end - begin == len(p): res.append(begin) begin += 1 return res 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"439._Ternary_Expression_Parser.html":{"url":"439._Ternary_Expression_Parser.html","title":"439 Ternary Expression Parser","keywords":"","body":"439. Ternary Expression Parser 题目: https://leetcode.com/problems/ternary-expression-parser/ 难度: Medium 思路： 其实这个和算术运算蛮像，但是不同于运算，有operator precedence差别，这个是三目运算，并且需要检查是否符合运算规则。 运用stack 然后每次查看是否形成运算式再来做处理 AC代码： class Solution(object): def parseTernary(self, expression): \"\"\" :type expression: str :rtype: str \"\"\" n = len(expression) stack = [] for i in range(n-1, -1, -1): char = expression[i] stack.append(char) if len(stack) >= 5: op0 = stack.pop() op1 = stack.pop() op2 = stack.pop() op3 = stack.pop() op4 = stack.pop() if op1 == '?' and op3 == ':': res = op2 if op0 == 'T' else op4 stack.append(res) else: stack.append(op4) stack.append(op3) stack.append(op2) stack.append(op1) stack.append(op0) return stack[0] 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"441._arranging_coins.html":{"url":"441._arranging_coins.html","title":"441 arranging coins","keywords":"","body":"441. Arranging Coins 题目: https://leetcode.com/problems/arranging-coins/ 难度: Easy 可以直接O(1),公式： i(i+1)/2 = n 解i i = ( sqrt(8*n+1) -1 )/ 2 import math class Solution(object): def arrangeCoins(self, n): \"\"\" :type n: int :rtype: int \"\"\" return int((math.sqrt( 8 * n + 1) - 1 )/ 2 ) 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"448._Find_All_Numbers_Disappeared_in_an_Array.html":{"url":"448._Find_All_Numbers_Disappeared_in_an_Array.html","title":"448 Find All Numbers Disappeared in an Array","keywords":"","body":"448. Find All Numbers Disappeared in an Array 题目: https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/ 难度: Easy class Solution(object): def findDisappearedNumbers(self, nums): \"\"\" :type nums: List[int] :rtype: List[int] \"\"\" return list(set(range(1, len(nums)+1)) - set(nums)) 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"450._Delete_Node_in_a_BST.html":{"url":"450._Delete_Node_in_a_BST.html","title":"450 Delete Node in a BST","keywords":"","body":"450. Delete Node in a BST 题目： https://leetcode.com/problems/delete-node-in-a-bst/ 难度 : Medium 思路： 从二叉搜索树中删除节点x的方法如下: • 如果x没有子节点，或者只有一个孩子，直接将x“切下”; • 否则，x有两个孩子，我们用其右子树中的最小值替换掉x，然后将右子树中的这一最小值递归的“切掉”。​ AC代码 class Solution(object): def deleteNode(self, root, key): \"\"\" :type root: TreeNode :type key: int :rtype: TreeNode \"\"\" def findmin(root): while root.left: root = root.left return root if not root : return None elif key root.val : root.right = self.deleteNode(root.right, key) else: if root.left and root.right: tmp = findmin(root.right) root.val = tmp.val root.right = self.deleteNode(root.right, tmp.val) else: if not root.left: root = root.right elif not root.right: root = root.left return root ​ 其实这个代码还是需要花点时间来理解，需要画个图，理解这个root是每个stack return回去然后被接在原来的树上的，if 这个node并不是在node左右。 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"453._Minimum_Moves_to_Equal_Array_Elements.html":{"url":"453._Minimum_Moves_to_Equal_Array_Elements.html","title":"453 Minimum Moves to Equal Array Elements","keywords":"","body":"453. Minimum Moves to Equal Array Elements 题目： https://leetcode.com/problems/minimum-moves-to-equal-array-elements/ 难度 : Easy 思路： naive TLE 代码： 每次都是给并不是最大的元素加1直到全部相等。 class Solution(object): def minMoves(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" res = 0 while(not all(x == nums[0] for x in nums)): nums.sort() for i in range(len(nums) - 1): nums[i] += 1 res += 1 return res 给的测试例子是 [1,2147483647]能不TLE么？tag 是Math，所以要用观察到的结果来做吧？ 所以就是每个和最小值来比，看到底要增加多少，这是观察，但不是证明 AC代码 class Solution(object): def minMoves(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" res = 0 minVal = min(nums) for num in nums: res += num -minVal return res 类证明： 其实给n-1个数字加1，效果等同于给那个未被选中的数字减1，比如数组[1，2，3], 给除去最大值的其他数字加1，变为[2，3，3]，我们全体减1，并不影响数字间相对差异，变为[1，2，2]，这个结果其实就是原始数组的最大值3自减1，那么问题也可能转化为，将所有数字都减小到最小值，这样难度就大大降低了，我们只要先找到最小值，然后累加每个数跟最小值之间的差值即可 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"459._Repeated_Substring_Pattern.html":{"url":"459._Repeated_Substring_Pattern.html","title":"459 Repeated Substring Pattern","keywords":"","body":"459. Repeated Substring Pattern 题目: https://leetcode.com/problems/Repeated-Substring-Pattern/ 难度: Easy 思路 如果存在这样的子串，那么子串的第一个字符和最后一个字符肯定跟父字符串s的相同。 因此构建一个新字符串s*2（两个父字符串相加），去掉首尾字符 如果此时能在其中找到s，说明存在这样的子串 class Solution(object): def repeatedSubstringPattern(self, s): \"\"\" :type s: str :rtype: bool \"\"\" return (s*2)[1:-1].find(s) != -1 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"461._Hamming_Distance.html":{"url":"461._Hamming_Distance.html","title":"461 Hamming Distance","keywords":"","body":"461. Hamming Distance 题目： https://leetcode.com/problems/hamming-distance/ 难度 : Easy 有wikipedia的page： https://en.wikipedia.org/wiki/Hamming_distance 其实思路还是比较简单的 先用异或，再求hamming weight For binary strings a and b the Hamming distance is equal to the number of ones (Hamming weight) in a XOR b. 一行无敌 class Solution(object): def hammingDistance(self, x, y): \"\"\" :type x: int :type y: int :rtype: int \"\"\" return bin(x^y).count('1') AC代码 class Solution(object): def hammingDistance(self, x, y): \"\"\" :type x: int :type y: int :rtype: int \"\"\" dist = 0 val = x ^ y while val: dist += 1 val &= val - 1 return dist 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"463._Island_Perimeter.html":{"url":"463._Island_Perimeter.html","title":"463 Island Perimeter","keywords":"","body":"463. Island Perimeter 题目: https://leetcode.com/problems/island-perimeter/ 难度: Easy 思路： class Solution(object): def islandPerimeter(self, grid): \"\"\" :type grid: List[List[int]] :rtype: int \"\"\" # 每一个陆地单元格的周长为4，当两单元格上下或者左右相邻时，令周长减2 h = len(grid) w = len(grid[0]) if h else 0 ans = 0 for x in range(h): for y in range(w): if grid[x][y] == 1: ans += 4 # 因为x+1还在后面，所以不需要考虑，即只需要考虑左边和上边，因为循环已经出现过该点了 if x > 0 and grid[x - 1][y]: ans -= 2 if y > 0 and grid[x][y - 1]: ans -= 2 return ans 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"467._Unique_Substrings_in_Wraparound_String.html":{"url":"467._Unique_Substrings_in_Wraparound_String.html","title":"467 Unique Substrings in Wraparound String","keywords":"","body":"467. Unique Substrings in Wraparound String 题目: https://leetcode.com/problems/Unique-Substrings-in-Wraparound-String/ 难度: Medium 思路: 有个无限长的字符串s，是由无数个「abcdefghijklmnopqrstuvwxyz」组成的。现在给你一个字符串p，求多少个p的非空子串在s中出现了？ 　　 先考虑s的特性，满足条件（在s中）的p的子串只可能是abcd……z的连续序列（z后面是a）， 我们只需要处理p中连续的部分就可以了。但是 举个例子，h-k的序列出现了，a-z的序列也出现了，那么只需要计算a-z的子串个数就可以了，因为h-k已经包含在a-z里了。考虑所有包含的情况，似乎就变得复杂了，a-z还可能被包含在x-za-z中，甚至更长的序列中。 　　但是如果考虑以某个字母结尾的子串个数，那么p中以该字母结尾的连续序列长度，就是满足条件的子串个数。如果以字母x结尾的连续序列有多个， 我们只需要最长的一个即可，因为其他短的序列都已经被长的包含进去了，例如'bcd'和'abcd'，有了'abcd'就知道以d结尾的子串有4个，分别是‘d’,'cd','bcd','abcd'，‘bcd’已经被包含进去了。最后求和，问题就解决了。 这样思考就非常简单了，代码也可以很容易写出来。 class Solution(object): def findSubstringInWraproundString(self, p): \"\"\" :type p: str :rtype: int \"\"\" letters = [0] * 26 #开始默认每个都是0 length = 0 for i in range(len(p)): curr = ord(p[i]) - ord('a') if i > 0 and ord(p[i-1]) != (curr-1)%26 + ord('a'): #一旦开始不相等了就要将length重置为0 length = 0 length += 1 #否则就说明继续与前面一个字符是连续的，length要加1才行 if length > letters[curr]: #length一直加，如果到i这个字符length比它的目前的最大连续子串长度还要长，那么肯定要更新letters letters[curr] = length return sum(letters) 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"469._Convex_Polygon.html":{"url":"469._Convex_Polygon.html","title":"469 Convex Polygon","keywords":"","body":"469. Convex Polygon 题目： https://leetcode.com/problems/convex-polygon/ 难度 : Medium 思路： 凸多边形 记得讲过convex hull，然而已经不知道是啥了。。。。 看wikipedia它的性质 https://en.wikipedia.org/wiki/Convex_polygon The polygon is entirely contained in a closed half-plane defined by each of its edges. http://stackoverflow.com/questions/471962/how-do-determine-if-a-polygon-is-complex-convex-nonconvex 这个算法很有意思也很make sense，叫包礼物。不过也是对付convex hull的，看到有人提这个： You can make things a lot easier than the Gift-Wrapping Algorithm... that's a good answer when you have a set of points w/o any particular boundary and need to find the convex hull. A polygon is a set of points in a list where the consecutive points form the boundary. It is much easier to figure out whether a polygon is convex or not (and you don't have to calculate any angles, either): For each consecutive pair of edges of the polygon (each triplet of points), compute the z-component of the cross product of the vectors defined by the edges pointing towards the points in increasing order. Take the cross product of these vectors: The polygon is convex if the z-components of the cross products are either all positive or all negative. Otherwise the polygon is nonconvex. given p[k], p[k+1], p[k+2] each with coordinates x, y: dx1 = x[k+1]-x[k] dy1 = y[k+1]-y[k] dx2 = x[k+2]-x[k+1] dy2 = y[k+2]-y[k+1] zcrossproduct = dx1 dy2 - dy1 dx2 If there are N points, make sure you calculate N cross products, e.g. be sure to use the triplets (p[N-2],p[N-1],p[0]) and (p[N-1],p[0],p[1]). 所以根据这个答案AC代码 class Solution(object): def isConvex(self, points): \"\"\" :type points: List[List[int]] :rtype: bool \"\"\" n = len(points) zcrossproduct = None for i in range(-2, n-2): x = [ points[i][0], points[i+1][0], points[i+2][0] ] y = [ points[i][1], points[i+1][1], points[i+2][1] ] dx1 = x[1] - x[0] dy1 = y[1] - y[0] dx2 = x[2] - x[1] dy2 = y[2] - y[1] if not zcrossproduct: zcrossproduct = dx1 * dy2 - dy1 * dx2 elif ( dx1 * dy2 - dy1 * dx2 ) * zcrossproduct 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"476._Number_Complement.html":{"url":"476._Number_Complement.html","title":"476 Number Complement","keywords":"","body":"476. Number Complement 题目: https://leetcode.com/problems/number-complement/ 难度: Easy class Solution(object): def findComplement(self, num): \"\"\" :type num: int :rtype: int \"\"\" i = 1 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"477._Total_Hamming_Distance.html":{"url":"477._Total_Hamming_Distance.html","title":"477 Total Hamming Distance","keywords":"","body":"477. Total Hamming Distance 题目: https://leetcode.com/problems/total-hamming-distance/ 难度: Medium 思路： 第一想法就是暴力，直接超时 class Solution(object): # 此法超时 def totalHammingDistance(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" res = 0 for i in range(len(nums)): for j in range(i+1, len(nums)): res += bin(nums[i]^nums[j]).count('1') return res 前面的解法是O(n^2)所以超时，所以我们想想有没有O(n)的解法 对于所有的数字，我们先从右数第一位开始算，如果一共有n个数字，其中k个数字的右数第一位是‘1’，其他n-k个数字的右数第一位是‘0’， 所以这一位对最终res的贡献就是k*(n-k),这样我们的时间复杂度就是O(32n)，也就是O(N)了 for each “column” or bit position, once you count the number of set bits you can figure out the number of pairs that will contribute to the count using combination logic. Consider you have 10 numbers and only one of them is a 1 the rest are zeros. How many (1, 0) pairs can you make? Clearly you can make 9, pair the 1 with each of the other 9 zeros. If you have 2 ones, you can pair each of those with the other 8 zeros giving 2*8 = 16. Keep going and you see that you can pair each 1 with each zero so the number of pairs is just the number of 1’s times the number of 0’s. This would be an O(32 * n) solution which is an O(n) solution, no space used. AC代码 class Solution(object): def totalHammingDistance(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" # iterate thru \"column\" or bit position # Note: you could stop at 10^9 as stated in the problem if you want to optimize res = 0 for i in range(32): mask = 1 上面的代码简化一下就是stefan大神(老流氓罒ω罒)的无敌一行了 class Solution(object): # 此法超时 def totalHammingDistance(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" return sum(b.count('0') * b.count('1') for b in zip(*map('{:032b}'.format, nums))) 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"485._Max_Consecutive_Ones.html":{"url":"485._Max_Consecutive_Ones.html","title":"485 Max Consecutive Ones","keywords":"","body":"485. Max Consecutive Ones 题目: https://leetcode.com/problems/max-consecutive-ones/ 难度: Easy 思路： 一行无敌 class Solution(object): def findMaxConsecutiveOnes(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" return len(max(''.join(map(str, nums)).split('0'))) class Solution(object): def findMaxConsecutiveOnes(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" res, count = [], 0 for x in nums: count = 0 if x == 0 else count + 1 res.append(count) return max(res) 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"494._Target_Sum.html":{"url":"494._Target_Sum.html","title":"494 Target Sum","keywords":"","body":"494. Target Sum 难度: 中等 刷题内容 原题连接 https://leetcode.com/problems/target-sum/description/ 内容描述 You are given a list of non-negative integers, a1, a2, ..., an, and a target, S. Now you have 2 symbols + and -. For each integer, you should choose one from + and - as its new symbol. Find out how many ways to assign symbols to make sum of integers equal to target S. Example 1: Input: nums is [1, 1, 1, 1, 1], S is 3. Output: 5 Explanation: -1+1+1+1+1 = 3 +1-1+1+1+1 = 3 +1+1-1+1+1 = 3 +1+1+1-1+1 = 3 +1+1+1+1-1 = 3 There are 5 ways to assign symbols to make the sum of nums be target 3. Note: The length of the given array is positive and will not exceed 20. The sum of elements in the given array will not exceed 1000. Your output answer is guaranteed to be fitted in a 32-bit integer. 解题方案 思路 1 递归，findSum(s, start_idx) 函数的意思是从start_index开始向后的子集合能有几种得到s的方法 class Solution(object): def findTargetSumWays(self, nums, S): \"\"\" :type nums: List[int] :type S: int :rtype: int \"\"\" def findSum(s, start_idx): if start_idx == len(nums): return 1 if s == 0 else 0 return findSum(s+nums[start_idx], start_idx+1) + findSum(s-nums[start_idx], start_idx+1) return findSum(S, 0) 但是这样会超时，所以用cache 记一下 class Solution(object): def findTargetSumWays(self, nums, S): \"\"\" :type nums: List[int] :type S: int :rtype: int \"\"\" def findSum(s, start_idx): if start_idx == len(nums): return 1 if s == 0 else 0 if (s, start_idx) not in cache: cache[(s, start_idx)] = findSum(s+nums[start_idx], start_idx+1) + findSum(s-nums[start_idx], start_idx+1) return cache[(s, start_idx)] cache = {} return findSum(S, 0) 思路 2 首先我们要找到一个集合 X 的正sum和其补集 Y 的负sum之和为target. 则有 sum(X) - sum(Y) = target 又有 sum(X) + sum(Y) = sum(nums) ---> 因此由 1 式和 2 式证得：sum(X) = (sum(nums) + target) / 2 因此题目就变成了找到了一个subset的正sum为(sum(nums) + target) / 2 于是动态规划，利用leetcode416题的思想 但是这次dp[i]代表的是能够找出几个subset的sum等于i, 例如dp[0] = 1是必然的，因为我们只能取空子集，才能得到sum为0 class Solution(object): def findTargetSumWays(self, nums, S): \"\"\" :type nums: List[int] :type S: int :rtype: int \"\"\" def subsetSum(s): dp = [0] * (s+1) dp[0] = 1 for i in range(len(nums)): for j in range(s, nums[i]-1, -1): dp[j] += dp[j-nums[i]] return dp[-1] if sum(nums) 0: return 0 return subsetSum((S+sum(nums))/2) 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"536._Construct_Binary_Tree_from_String.html":{"url":"536._Construct_Binary_Tree_from_String.html","title":"536 Construct Binary Tree from String","keywords":"","body":"536. Construct Binary Tree from String 难度: 中等 刷题内容 原题连接 https://leetcode.com/problems/construct-binary-tree-from-string/description/ 内容描述 You need to construct a binary tree from a string consisting of parenthesis and integers. The whole input represents a binary tree. It contains an integer followed by zero, one or two pairs of parenthesis. The integer represents the root's value and a pair of parenthesis contains a child binary tree with the same structure. You always start to construct the left child node of the parent first if it exists. Example: Input: \"4(2(3)(1))(6(5))\" Output: return the tree root node representing the following tree: 4 / \\ 2 6 / \\ / 3 1 5 Note: There will only be '(', ')', '-' and '0' ~ '9' in the input string. An empty tree is represented by \"\" instead of \"()\". 解题方案 思路 1 递归，每次先找到左子树，然后判断有无右子树，继续下去 class Solution(object): def str2tree(self, s): \"\"\" :type s: str :rtype: TreeNode \"\"\" if not s or len(s) == 0: return None if '(' not in s: return TreeNode(int(s)) def paren_pair_idx(s): paren_count = 0 for i in range(len(s)): if s[i] == '(': paren_count += 1 elif s[i] == ')': paren_count -= 1 if paren_count == 0 and i > s.find('('): return (s.find('('), i) root = TreeNode(int(s[:s.find('(')])) (paren_left, paren_right) = paren_pair_idx(s) root.left = self.str2tree(s[paren_left+1: paren_right]) if paren_right 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"587._Erect_the_Fence.html":{"url":"587._Erect_the_Fence.html","title":"587 Erect the Fence","keywords":"","body":"587. Erect the Fence 题目: https://leetcode.com/problems/Erect-the-Fence/ 难度: Hard 思路 题目要求用一个围栏把所有的点（🌲）围起来，然后求处于围栏上点（🌲）的集合。 我们可以发现，从最左边的那个点一直往右走，只要一直都是走的逆时针方向，那么我们一定可以找到这条围栏。那么接下来就考虑最简单的情况， 只有两个点p和q，我们从p走到q，当p到原点这条直线的斜率小于q到原点这条直线的斜率时，p->q就是沿逆时针方向走的； 接下来考虑3个点:p，q，r，以p为参照点（即前面的原点），那么从q走到r的时候，只要q到q这条直线的斜率小于r到p这条直线的斜率，q->r就是沿逆时针方向走的。 因此，我们只要构建一个orientation函数，就可以判断出目前我们的围栏是不是沿着逆时针在走下去了。 我们用一个stack来存放目前认为在围栏上的点的集合，然后把所有的点按照指定规则排好序：先按照点的x坐标升序排列，如果x相等则按照点的y坐标升序排列。这样我们依次取点，只要stack里面的点大于等于2个我们就要无限进行判断是否走的是逆时针，如果不是就把stack里面最后那个点pop出去（可能一直pop到只剩一个点），否则就把目前的这个点加入到stack中去，因为目前它还是在逆时针方向上的。 从左往右走完一遍points之后，我们围栏的下部分lower hull就构建好了，此时我们还要构建围栏的upper hull，因此我们将points逆序一下，从右往左再来一次遍历，仍然看是否走的是逆时针。但是这次遍历我们需要进行一个判断，就是之前放进stack的点，此时我们还是会经过它，如果它已经在stack里面了，我们就不需要再加进去了，同时这样也避免了我们把最左边的点重复加进去。 python # import functools class Solution: def outerTrees(self, points): \"\"\" :type points: List[Point] :rtype: List[Point] \"\"\" def orientation(p, q, r): return (q.y - p.y)*(r.x - p.x) - (r.y - p.y)*(q.x - p.x) # def myComparator(p,q): # return p.x - q.x if p.x != q.x else p.y - q.y stack= [] # points.sort(key = functools.cmp_to_key(myComparator)) points.sort(key = lambda p: (p.x, p.y)) for i in range(len(points)): while (len(stack) >= 2 and orientation(stack[-2],stack[-1],points[i]) > 0): stack.pop() stack.append(points[i]) points.reverse(); for i in range(len(points)): while (len(stack) >= 2 and orientation(stack[-2],stack[-1],points[i]) > 0): stack.pop() if points[i] not in stack: stack.append(points[i]) return stack 简化python版本 class Solution(object): def outerTrees(self, points): \"\"\" :type points: List[Point] :rtype: List[Point] \"\"\" def orientation(p, q, r): return (q.y - p.y) * (r.x - q.x) - \\ (q.x - p.x) * (r.y - q.y) hull = [] points.sort(key=lambda p: (p.x, p.y)) for i in itertools.chain(xrange(len(points)), \\ reversed(xrange(len(points)))): while len(hull) >= 2 and \\ orientation(hull[-2], hull[-1], points[i]) > 0: hull.pop() hull.append(points[i]) return list(set(hull)) 下面是小傅大神的代码，本来想叫‘’傅神‘’的，结果这名字🤦‍♂️（手动捂脸）小傅每日一题587 另外其中的stack.pop()这行代码注释掉也是可以的 java class Solution { public List outerTrees(Point[] points) { List res = new ArrayList(); Arrays.sort(points, new Comparator(){ @Override public int compare(Point p, Point q){ return p.x == q.x ? p.y - q.y : p.x - q.x; } }); Stack stack = new Stack<>(); for (int i = 0; i = 2 && orientation(stack.get(stack.size() - 2), stack.peek(), points[i]) > 0){ stack.pop(); } stack.push(points[i]); } //stack.pop(); for (int i = points.length - 1; i >= 0; i--){ while(stack.size() >= 2 && orientation(stack.get(stack.size() - 2), stack.peek(), points[i]) > 0){ stack.pop(); } stack.push(points[i]); } res.addAll(new HashSet<>(stack)); return res; } public int orientation(Point p, Point q, Point r){ return (q.y - p.y)*(r.x - p.x) - (r.y - p.y)*(q.x - p.x); } } Author: Keqi Huang If you like it, please spread your support 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"599._Minimum_Index_Sum_of_Two_Lists.html":{"url":"599._Minimum_Index_Sum_of_Two_Lists.html","title":"599 Minimum Index Sum of Two Lists","keywords":"","body":"599. Minimum Index Sum of Two Lists 题目: https://leetcode.com/problems/Minimum-Index-Sum-of-Two-Lists/ 难度: Easy 思路 两个list，我们首先要取得它们相同的部分，并且之后我们还要知道哪个相同的字符串在两个list中的index之和是最小的。 所以我们首先遍历list1，只要目前这个字符串在list2中，我们就以[字符串，index之和]的形式将其存放到ress中，同时维护一个index保持为最小index之和的值 对于ress，我们遍历，只要某一项的index之和等于最小index之和我们就将他的字符串以i[0]的形式append到res中去， return res 程序变量解释 ress format: [[string1, sumOfIndex1], [string2, sumOfIndex2]... ] index 最小sunOfIndex值 res 最终结果，foramt: [string1, string2,. ...] python class Solution: def findRestaurant(self, list1, list2): \"\"\" :type list1: List[str] :type list2: List[str] :rtype: List[str] \"\"\" ress = [] index = 2000 for i in list1: if i in list2: ress.append([i, list1.index(i)+list2.index(i)]) index = min(index, list1.index(i)+list2.index(i)) res = [] for i in ress: if i[1] == index: res.append(i[0]) return res Author: Keqi Huang If you like it, please spread your support 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"606._Construct_String_from_Binary_Tree.html":{"url":"606._Construct_String_from_Binary_Tree.html","title":"606 Construct String from Binary Tree","keywords":"","body":"606. Construct String from Binary Tree 难度: 简单 刷题内容 原题连接 https://leetcode.com/problems/construct-string-from-binary-tree/description/ 内容描述 You need to construct a string consists of parenthesis and integers from a binary tree with the preorder traversing way. The null node needs to be represented by empty parenthesis pair \"()\". And you need to omit all the empty parenthesis pairs that don't affect the one-to-one mapping relationship between the string and the original binary tree. Example 1: Input: Binary tree: [1,2,3,4] 1 / \\ 2 3 / 4 Output: \"1(2(4))(3)\" Explanation: Originallay it needs to be \"1(2(4)())(3()())\", but you need to omit all the unnecessary empty parenthesis pairs. And it will be \"1(2(4))(3)\". Example 2: Input: Binary tree: [1,2,3,null,4] 1 / \\ 2 3 \\ 4 Output: \"1(2()(4))(3)\" Explanation: Almost the same as the first example, except we can't omit the first parenthesis pair to break the one-to-one mapping relationship between the input and the output. 解题方案 思路 1 递归 class Solution(object): def tree2str(self, t): \"\"\" :type t: TreeNode :rtype: str \"\"\" if not t: return '' res = str(t.val) if t.left and t.right: res += '(' + self.tree2str(t.left) + ')' + '(' + self.tree2str(t.right) + ')' elif not t.left and t.right: res += '()(' + self.tree2str(t.right) + ')' elif t.left and not t.right: res += '(' + self.tree2str(t.left) + ')' return res 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"611._Valid_Triangle_Number.html":{"url":"611._Valid_Triangle_Number.html","title":"611 Valid Triangle Number","keywords":"","body":"611. Valid Triangle Number 有效三角形的个数 难度: 中等 刷题内容 原题连接 https://leetcode.com/problems/valid-triangle-number/description/ https://leetcode-cn.com/problems/valid-triangle-number/description/ 内容描述 给定一个包含非负整数的数组，你的任务是统计其中可以组成三角形三条边的三元组个数。 示例 1: 输入: [2,2,3,4] 输出: 3 解释: 有效的组合是: 2,3,4 (使用第一个 2) 2,3,4 (使用第二个 2) 2,2,3 注意: 数组长度不超过1000。 数组里整数的范围为 [0, 1000]。 解题方案 思路 1 明确一点，三角形三边为a, b, c，那么何时满足可以组成一个三角形呢？ 要同时满足以下3点： a + b > c a + c > b b + c > a 首先对数组逆向排序，固定第一个数字，我们发现nums[i] >= nums[j] >= nums[k], 所以我们现在只需要保证nums[j] + nums[k] > nums[i]即可， 因为nums[i] + nums[j] > nums[k]和nums[i] + nums[k] > nums[j]是肯定的 后面开始二分，分两种情况： 如果nums[j] + nums[k] > nums[i]，那么我们只需要将j += 1使得比较式前面变小继续判断， 并且res += k - j，因为组合i, j, [j+1...k]都可以满足比较式，我们需要全部加起来，后面不会再次判断了 如果nums[j] + nums[k] ，那么我们只需要将k -= 1使得比较式前面变大继续判断是否满足比较式 class Solution(object): def triangleNumber(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" nums = sorted(nums)[::-1] res = 0 for i in range(len(nums)-2): j, k = i + 1, len(nums) - 1 while j nums[i]: res += k - j j += 1 else: k -= 1 return res 这里真的我遇到了两次坑，首先如果我们排序用的是正向排序的话，那么我们需要做的是固定最后一个数，否则会出现（假如固定第一个数）： 等式满足，我们将j -= 1``，那么就有可能漏掉了一种情况，就是原本组合i, j, [j+1...k-1]```可以满足，但是我们这里没有加上 等式满足，我们将k += 1``，那么就有可能漏掉了一种情况，就是原本组合i, [j+1...k-1], k```可以满足，但是我们这里没有加上 所以二分法真的没有那么简单，我们需要充分根据实际场景去改变我们的固定位置和前后更新方向 这里也给出正向排序的代码： class Solution(object): def triangleNumber(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" nums.sort() res = 0 for k in range(len(nums)-1, 1, -1): i, j = 0, k - 1 while i nums[k]: res += j - i j -= 1 else: i += 1 return res 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"646._Maximum_Length_of_Pair_Chain.html":{"url":"646._Maximum_Length_of_Pair_Chain.html","title":"646 Maximum Length of Pair Chain","keywords":"","body":"646. Maximum Length of Pair Chain 难度: 中等 刷题内容 原题连接 https://leetcode.com/problems/maximum-length-of-pair-chain/description/ 内容描述 You are given n pairs of numbers. In every pair, the first number is always smaller than the second number. Now, we define a pair (c, d) can follow another pair (a, b) if and only if b [3,4] Note: The number of given pairs will be in the range [1, 1000]. 解题方案 思路 1 先按照start --> end中的end排序，即pairs = sorted(pairs, key=lambda x:x[1]) 原因在于，你想想看，如果我们已经取得了最长的那一条序列，end最小的那个pair肯定在里面对不对？ 如果你说不对，那假设它不在里面，现在max_chain的第一个pair是不是至少可以被end最小的那个pair替代，因为我的end比你更小，你都可以我为什么不可以，甚至如果我的 end比你的start小的话，我还可以加在你前面呢，这样max_chain岂不是就不是最长的chain了？ 综上所述，我们只要先按照start --> end中的end排序，然后从第一个慢慢向下判断就行，如果不符合就跳过，符合我们就把长度加1，这样最后肯定是对的。 AC代码如下： class Solution(object): def findLongestChain(self, pairs): \"\"\" :type pairs: List[List[int]] :rtype: int \"\"\" if not pairs or len(pairs) == 0: return 0 pairs = sorted(pairs, key=lambda x:x[1]) res, i = 0, -1 while i + 1 发现有大佬比我牛p多了，代码更nice class Solution(object): def findLongestChain(self, pairs): \"\"\" :type pairs: List[List[int]] :rtype: int \"\"\" if not pairs or len(pairs) == 0: return 0 cur, res = float('-inf'), 0 for p in sorted(pairs, key=lambda x: x[1]): if cur 思路 2 动态规划 思路看代码就理解了，不宜多说 class Solution(object): def findLongestChain(self, pairs): \"\"\" :type pairs: List[List[int]] :rtype: int \"\"\" if not pairs or len(pairs) == 0: return 0 pairs = sorted(pairs, key=lambda x:x[0]) dp = [1] * len(pairs) for i in range(1, len(pairs)): for j in range(i): dp[i] = max(dp[i], dp[j] + 1 if pairs[i][0] > pairs[j][1] else dp[j]) return dp[-1] 这样会超时，不知道为啥，然后改了下代码的写法就过了，beats 2.21% 哈哈哈哈哈, 管它呢，过了就行，代码如下： class Solution(object): def findLongestChain(self, pairs): \"\"\" :type pairs: List[List[int]] :rtype: int \"\"\" if not pairs or len(pairs) == 0: return 0 pairs = sorted(pairs, key=lambda x:x[0]) dp = [1] * len(pairs) for i in range(1, len(pairs)): dp[i] = max([dp[j] + 1 if pairs[i][0] > pairs[j][1] else dp[j] for j in range(i)]) return dp[-1] 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"647._Palindromic_Substrings.html":{"url":"647._Palindromic_Substrings.html","title":"647 Palindromic Substrings","keywords":"","body":"647. Palindromic Substrings 题目: https://leetcode.com/problems/Palindromic-Substrings/ 难度: Medium 思路 这道题要求给定一个字符串中的所有回文子串的个数，所以我想到了Manacher算法， Manacher算法 Manacher算法增加两个辅助变量id和mx，其中id表示最大回文子串中心的位置，mx则为id+P[id]，也就是最大回文子串的边界。得到一个很重要的结论： 如果mx > i，那么P[i] >= Min(P[2 * id - i], mx - i) . 为什么这样说呢，下面解释 下面，令j = 2*id - i，也就是说j是i关于id的对称点。 当 mx - i > P[j] 的时候，以S[j]为中心的回文子串包含在以S[id]为中心的回文子串中，由于i和j对称，以S[i]为中心的回文子串必然包含在以S[id]为中心的回文子串中，所以必有P[i] = P[j]； 当 P[j] >= mx - i 的时候，以S[j]为中心的回文子串不一定完全包含于以S[id]为中心的回文子串中，但是基于对称性可知，下图中两个绿框所包围的部分是相同的，也就是说以S[i]为中心的回文子串，其向右至少会扩张到mx的位置，也就是说 P[i] >= mx - i。至于mx之后的部分是否对称，再具体匹配。 所以P[i] >= Min(P[2 id - i], mx - i)，因为以j为中心的绘回文子串的左边界可能会比mx关于id的对称点要大，此时只能证明P[i]=P[2 id - i] 此外，对于 mx thining-in-lc-5 这道题的基本思想是将以每一个字符为中心的回文子串个数相加，还是用一个小例子来解释 其实，以‘#’为中心的回文子串就代表这个子串的长度是偶数，类似于'abba'这种 但是其实这个字符本身也是一个回文子串，所以叠加的形式是count += (P[i]+1)/2，为什么呢，以下是解释： 对于每一个以字符‘#’为中心的回文子串，其P值绝对是偶数，所以(P[i]+1)/2 = P[i]/2，并不影响 对于每一个以非字符‘#’为中心的回文子串，其P值绝对是奇数，这就保证了单个字母的回文子串(例如'a'也算一个回文子串)也被加起来了，因为(P[i]+1)/2 = P[i]/2+1 class Solution(object): def countSubstrings(self, s): \"\"\" :type s: str :rtype: str \"\"\" def preProcess(s): if not s: return ['^', '$'] T = ['^'] for c in s: T += ['#', c] T += ['#', '$'] return T T = preProcess(s) P = [0] * len(T) id, mx, count = 0, 0, 0 for i in range(1,len(T) - 1): j = 2*id - i if mx > i: P[i] = min(mx - i, P[j]) else: P[i] = 0 while T[i+P[i]+1] == T[i-P[i]-1]: P[i] += 1 if (i + P[i]) > mx: id, mx = i, i + P[i] for i in range(len(P)): count += (P[i]+1)/2 return count python无敌啊！！！有没有天理啊，手动滑稽😏😏😏😏！一行解法： class Solution(object): def countSubstrings(self, s): \"\"\" :type s: str :rtype: int \"\"\" return sum(len(os.path.commonprefix((s[:i][::-1], s[i:]))) + len(os.path.commonprefix((s[:i][::-1], s[i + 1:]))) + 1 for i in range(len(s))) 解释下为啥要加两次，因为回文串有以下两种形式： ‘abcba’ 'abba' 那为啥要加那个1呢，上面解释过了，单个字符也算是一个回文子串呀，嘻嘻😁 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"657._Judge_Route_Circle.html":{"url":"657._Judge_Route_Circle.html","title":"657 Judge Route Circle","keywords":"","body":"657. Judge Route Circle 题目: https://leetcode.com/problems/judge-route-circle/ 难度: Easy class Solution(object): def judgeCircle(self, moves): \"\"\" :type moves: str :rtype: bool \"\"\" return moves.count('D') == moves.count('U') and moves.count('R') == moves.count('L') 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"665._Non-decreasing_Array.html":{"url":"665._Non-decreasing_Array.html","title":"665 Non-decreasing Array","keywords":"","body":"665. Non-decreasing Array 题目: https://leetcode.com/problems/Non-decreasing-Array/ 难度: Easy 思路 从index=1的元素依次检查，只要不符合规则则让count+1，如果count>1则肯定不符合返回False 但是我们在发现nums[i]小于nums[i-1]的时候，我们就必须要对原数组作出改变了，来让它的后面index部分尽可能满足条件 下面就是两种情况： 2,4,2,6 如果是这种情况，当index=2时，不满足条件，但是i=0的元素是小于i=2处元素的，我们需要改变的是i-1处的元素，也就是将4改变成i=2处元素即2，最终变成2,2,2,6 3,4,2,6 这种情况如果我们将4变成2那么仍然是不满足条件的，此时我们需要将2变成4，即将i处元素变为i-1处元素 在每一次不符合条件的时候我们都检查一下count，如果count大于1的话我们就返回False，否则最终就返回True class Solution(object): def checkPossibility(self, nums): \"\"\" :type nums: List[int] :rtype: bool \"\"\" count = 0 for i in range(1,len(nums)): if nums[i] 1: return False if i - 2 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"672._Bulb_Switcher_II.html":{"url":"672._Bulb_Switcher_II.html","title":"672 Bulb Switcher II","keywords":"","body":"672. Bulb Switcher II 题目: https://leetcode.com/problems/Bulb-Switcher-II/ 难度: Medium 思路 这道题又是一个数学题。找规律呀找规律。 我们只需要考虑当 n2 and m >=3, 结果肯定是 8. The four buttons: Flip all the lights. Flip lights with even numbers. Flip lights with odd numbers. Flip lights with (3k + 1) numbers, k = 0, 1, 2, ... 如果我们使用了 button 1 和 2, 其效果等同于使用 button 3 。 类似的.. 1 + 2 --> 3 1 + 3 --> 2 2 + 3 --> 1 所以，只有 8 种情形。 灯全亮, 操作1, 操作2, 操作3, 操作4, 操作1+4, 操作2+4, 操作3+4 并且当 n>2 and m>=3 时，我们就能够获得所有的情形。 m\\n 0 1 2 3 4 0 1 1 1 1 1 1 1 2 3 4 4 2 1 2 4 7 7 3 1 2 3 8 8 class Solution(object): def flipLights(self, n, m): \"\"\" :type n: int :type m: int :rtype: int \"\"\" if m * n == 0: return 1 if n == 1: return 2 if n == 2: return 4 - (m % 2) if m == 1: return 4 if m == 2: return 7 return 8 还有两位大佬的两行解法： class Solution(object): def flipLights(self, n, m): m, n = min(3, m), min(3, n) return 1 if n * m == 0 else self.flipLights(n - 1, m) + self.flipLights( n - 1, m - 1) class Solution(object): def flipLights(self, n, m): n = min(n, 3) return min(1 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"681._Next_Closest_Time.html":{"url":"681._Next_Closest_Time.html","title":"681 Next Closest Time","keywords":"","body":"681. Next Closest Time 题目: https://leetcode.com/problems/next-closest-time/ 难度: Medium 思路 题目说输入一个时间，format是HH:MM, 然后输出接下来最近的一个时间，且这个时间的数字必须要在输入的时间中可以找到，所以我们用h, m 分别代表输入时间的小时数和分钟数，然后可以计算出输入时间的总分钟数curr，在未来的一天之内，我们一分钟一分钟往下面试，第一个满足的就直接 作为结果就行了. class Solution(object): def nextClosestTime(self, time): \"\"\" :type time: str :rtype: str \"\"\" h, m = time.split(\":\") curr = int(h) * 60 + int(m) # 这里要注意h可能会是0开头的，如输入的时间为01:22，所以需要int(h)和int(m) result = None for i in xrange(curr+1, curr+1441): t = i % 1440 h, m = t // 60, t % 60 result = \"%02d:%02d\" % (h, m) if set(result) 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"682._Baseball_Game.html":{"url":"682._Baseball_Game.html","title":"682 Baseball Game","keywords":"","body":"682. Baseball Game 题目: https://leetcode.com/problems/Baseball-Game/ 难度: Easy 思路 points用来存放每一次的分数，最后求和。 class Solution(object): def calPoints(self, ops): \"\"\" :type ops: List[str] :rtype: int \"\"\" points = [] for i in ops: if i == 'C': points.pop() elif i == 'D': points.append(2 * points[-1]) elif i == '+': points.append(points[-1] + points[-2]) else: points.append(int(i)) return sum(points) 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"685._Redundant_Connection_II.html":{"url":"685._Redundant_Connection_II.html","title":"685 Redundant Connection II","keywords":"","body":"685. Redundant Connection II 题目： https://leetcode.com/problems/redundant-connection-ii/ 难度 : Hard 我们先定义一下，每条边的第一个点是parent，第二个点是child，例如 2 -> 1 中 node 2 就是 parent，而 node 1 就是 child 明确这个之后，我们要知道图中有一条边是 invalid 的，去除它之后整个图就变成了一棵树，那么什么情况下一个边会导致树变成图呢： 如果一个child 在此之前已经有过一个parent了，那么意味着它有两个parent，这在树中肯定是不合法的。 在代码中体现为node_parent[child] != child，这说明在碰到此时的parent之前我们就已经更新过node_parent[child]了，即child之前已经有一个parent了 如果一个child 的 parent 的 parent（或者一直往上找） 就是 child 本身，那么这意味着有环，这在树中也肯定是不合法的。 在代码中体现为find(node_parents, parent) == child, 这说明child的parent的parent或以上就是child本身，即有环。 例如 1 --> 2 --> 1或者1 --> 2 --> 3 --> 1 因此我们可以定义一个列表 node_parent，在最开始的时候，此列表的 index 和 value 一一相等。 然后我们对edges进行第一轮遍历（正序遍历），并且用count来计数不合法的边： 如果只找到一条不合法的边，那么直接返回它即可 如果有超过一条不合法的边，那么我们就进行第二轮遍历（逆序遍历），返回碰到的第一条不合法的边， 这里是为了节约时间，因为如题意我们要返回的是最后一条出现的边，那么我们逆序就更省时间嘛 class Solution(object): def findRedundantDirectedConnection(self, edges): \"\"\" :type edges: List[List[int]] :rtype: List[int] \"\"\" def find(node_parent, parent): return parent if node_parent[parent] == parent else find(node_parent, node_parent[parent]) n, count = len(edges), 0 # 用 count 来计数不合法的边 node_parent = [i for i in range(n+1)] res = [0, 0] # 第一轮查找不合法的边 （正序） for i in range(n): parent, child = edges[i][0], edges[i][1] if node_parent[child] != child or find(node_parent, parent) == child: res = edges[i] count += 1 else: node_parent[child] = parent if count == 1: # 如果只有一条不合法的边，直接返回 return res # 重置 node_parent 并开始第二轮查找 （逆序） node_parent = [i for i in range(n+1)] for i in range(n-1, -1, -1): parent, child = edges[i][0], edges[i][1] if node_parent[child] != child or find(node_parent, parent) == child: return edges[i] else: node_parent[child] = parent return res 这道题感谢xyzxuyizhen大佬， 看到他的思路才逃离了我之前的很复杂的想法。 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"687._Longest_Univalue_Path.html":{"url":"687._Longest_Univalue_Path.html","title":"687 Longest Univalue Path","keywords":"","body":"687. Longest Univalue Path 题目: https://leetcode.com/problems/longest-univalue-path/ 难度: Easy 思路 这道题也只能算个easy题目，根据传进来的root，我们只要从它的左右节点不停的递归下去，只要其value值与root一样， 该方向上的length就加1，最后我们将左右方向上的length相加, 递归取最大值 很重要的一点就是，Note: The length of path between two nodes is represented by the number of edges between them. 因此是self.res = max(self.res, left_arrow + right_arrow), return max(left_arrow, right_arrow) 而不是self.res = max(self.res, left_arrow + right_arrow + 1), return max(left_arrow + 1, right_arrow + 1) # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution(object): def longestUnivaluePath(self, root): \"\"\" :type root: TreeNode :rtype: int \"\"\" self.res = 0 def dir_length(node): if not node: return 0 left_len = dir_length(node.left) # 左节点的length right_len = dir_length(node.right) # 右节点的length left_dir, right_dir = 0, 0 if node.left and node.left.val == node.val: left_dir = left_len + 1 # 当前节点的左节点方向的length if node.right and node.right.val == node.val: right_dir = right_len + 1 # 当前节点的右边节点方向的length self.res = max(self.res, left_dir + right_dir) return max(left_dir, right_dir) dir_length(root) return self.res 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"693._Binary_Number_with_Alternating_Bits.html":{"url":"693._Binary_Number_with_Alternating_Bits.html","title":"693 Binary Number with Alternating Bits","keywords":"","body":"693. Binary Number with Alternating Bits 交替位二进制数 难度: 中等 刷题内容 原题连接 https://leetcode.com/problems/binary-number-with-alternating-bits/description/ https://leetcode-cn.com/problems/binary-number-with-alternating-bits/description/ 内容描述 给定一个正整数，检查他是否为交替位二进制数：换句话说，就是他的二进制数相邻的两个位数永不相等。 示例 1: 输入: 5 输出: True 解释: 5的二进制数是: 101 示例 2: 输入: 7 输出: False 解释: 7的二进制数是: 111 示例 3: 输入: 11 输出: False 解释: 11的二进制数是: 1011 示例 4: 输入: 10 输出: True 解释: 10的二进制数是: 1010 解题方案 思路 1 太简单了，可以一行秒，但是太难看了，还是多写几行吧 调用bin函数转换成二进制以后再转换成字符串，注意二进制前面2为是‘0b’,要记得去掉 class Solution(object): def hasAlternatingBits(self, n): \"\"\" :type n: int :rtype: bool \"\"\" tmp = str(bin(n))[2:] res = [tmp[i] != tmp[i-1] for i in range(1, len(tmp))] return all(res) 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"701._Insert_into_a_Binary_Search_Tree.html":{"url":"701._Insert_into_a_Binary_Search_Tree.html","title":"701 Insert into a Binary Search Tree","keywords":"","body":"701. Insert into a Binary Search Tree 难度: 困难 刷题内容 原题连接 https://leetcode.com/problems/longest-valid-parentheses 内容描述 Given the root node of a binary search tree (BST) and a value to be inserted into the tree, insert the value into the BST. Return the root node of the BST after the insertion. It is guaranteed that the new value does not exist in the original BST. Note that there may exist multiple valid ways for the insertion, as long as the tree remains a BST after insertion. You can return any of them. For example, Given the tree: 4 / \\ 2 7 / \\ 1 3 And the value to insert: 5 You can return this binary search tree: 4 / \\ 2 7 / \\ / 1 3 5 This tree is also valid: 5 / \\ 2 7 / \\ 1 3 \\ 4 解题方案 思路 1 就一句话，看到树🌲就想到递归，太简单了，30秒敲完答案 class Solution(object): def insertIntoBST(self, root, val): \"\"\" :type root: TreeNode :type val: int :rtype: TreeNode \"\"\" if not root: return TreeNode(val) if val root.val: root.right = self.insertIntoBST(root.right, val) return root 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"707._Design_Linked_List.html":{"url":"707._Design_Linked_List.html","title":"707 Design Linked List","keywords":"","body":"707. Design Linked List 难度: Easy 刷题内容 原题连接 https://leetcode.com/problems/design-linked-list/description/ 内容描述 Design your implementation of the linked list. You can choose to use the singly linked list or the doubly linked list. A node in a singly linked list should have two attributes: val and next. val is the value of the current node, and next is a pointer/reference to the next node. If you want to use the doubly linked list, you will need one more attribute prev to indicate the previous node in the linked list. Assume all nodes in the linked list are 0-indexed. Implement these functions in your linked list class: get(index) : Get the value of the index-th node in the linked list. If the index is invalid, return -1. addAtHead(val) : Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. addAtTail(val) : Append a node of value val to the last element of the linked list. addAtIndex(index, val) : Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. deleteAtIndex(index) : Delete the index-th node in the linked list, if the index is valid. Example: MyLinkedList linkedList = new MyLinkedList(); linkedList.addAtHead(1); linkedList.addAtTail(3); linkedList.addAtIndex(1, 2); // linked list becomes 1->2->3 linkedList.get(1); // returns 2 linkedList.deleteAtIndex(1); // now the linked list is 1->3 linkedList.get(1); // returns 3 Note: All values will be in the range of [1, 1000]. The number of operations will be in the range of [1, 1000]. Please do not use the built-in LinkedList library. 解题方案 思路 1 用list模拟，太简单了，🙄️🙄️🙄️ class MyLinkedList(object): def __init__(self): \"\"\" Initialize your data structure here. \"\"\" self.lst = [] def get(self, index): \"\"\" Get the value of the index-th node in the linked list. If the index is invalid, return -1. :type index: int :rtype: int \"\"\" if index > len(self.lst) - 1 or index len(self.lst): return elif index == len(self.lst): self.lst.append(val) else: self.lst.insert(index, val) def deleteAtIndex(self, index): \"\"\" Delete the index-th node in the linked list, if the index is valid. :type index: int :rtype: void \"\"\" if index > len(self.lst) - 1 or index 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"740._delete_and_earn.html":{"url":"740._delete_and_earn.html","title":"740 delete and earn","keywords":"","body":"740. Delete and Earn 题目: https://leetcode.com/problems/delete-and-earn/ 难度: Medium class Solution(object): def deleteAndEarn(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" dp = [0] * 10001 for num in nums: dp[num] += num for i in range(2, 10001): dp[i] = max(dp[i]+dp[i-2], dp[i-1]) return dp[-1] 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"760._Find_Anagram_Mappings.html":{"url":"760._Find_Anagram_Mappings.html","title":"760 Find Anagram Mappings","keywords":"","body":"760. Find Anagram Mappings 题目: https://leetcode.com/problems/find-anagram-mappings/ 难度: Easy class Solution(object): def anagramMappings(self, A, B): \"\"\" :type A: List[int] :type B: List[int] :rtype: List[int] \"\"\" if not A: return [] res = [] for i in A: res.append(B.index(i)) return res 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"774._Minimize_Max_Distance_to_Gas_Station.html":{"url":"774._Minimize_Max_Distance_to_Gas_Station.html","title":"774 Minimize Max Distance to Gas Station","keywords":"","body":"774. Minimize Max Distance to Gas Station 难度: 困难 刷题内容 原题连接 https://leetcode.com/problems/minimize-max-distance-to-gas-station/description/ 内容描述 On a horizontal number line, we have gas stations at positions stations[0], stations[1], ..., stations[N-1], where N = stations.length. Now, we add K more gas stations so that D, the maximum distance between adjacent gas stations, is minimized. Return the smallest possible value of D. Example: Input: stations = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], K = 9 Output: 0.500000 Note: stations.length will be an integer in range [10, 2000]. stations[i] will be an integer in range [0, 10^8]. K will be an integer in range [1, 10^6]. Answers within 10^-6 of the true value will be accepted as correct. 解题方案 思路 1 首先明确一下题意，如果目前最大的一个距离是D的话，只要现在我们能够让最大的距离全都变小就行了，也就是说通过在最大距离的station之间再加一些station即可， 加了之后现在原来的最大距离就变小了，就可以了。明确一点，我们需要返回的是我们用最多k个station所能构造出的最小的最大距离。 于是我们判断一下需要我们额外加的stations数目是否小于等于k： 若是，且当前最大距离小于10^-6则返回当前最大距离 若不是，则继续追加stations数目，继续让最大距离变小 class Solution(object): def minmaxGasDist(self, stations, K): \"\"\" :type stations: List[int] :type K: int :rtype: float \"\"\" def possible(D): return sum(int((stations[i+1] - stations[i]) / D) for i in xrange(len(stations) - 1)) 1e-6: mid = (l + r) / 2.0 if possible(mid): r = mid else: l = mid return l 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"777._Swap_Adjacent_in_LR_String.html":{"url":"777._Swap_Adjacent_in_LR_String.html","title":"777 Swap Adjacent in LR String","keywords":"","body":"777. Swap Adjacent in LR String 在LR字符串中交换相邻字符 难度: 中等 刷题内容 原题连接 https://leetcode.com/problems/swap-adjacent-in-lr-string/description/ https://leetcode-cn.com/problems/swap-adjacent-in-lr-string/description/ 内容描述 在一个由 'L' , 'R' 和 'X' 三个字符组成的字符串（例如\"RXXLRXRXL\"）中进行移动操作。一次移动操作指用一个\"LX\"替换一个\"XL\"，或者用一个\"XR\"替换一个\"RX\"。现给定起始字符串start和结束字符串end，请编写代码，当且仅当存在一系列移动操作使得start可以转换成end时， 返回True。 示例 : 输入: start = \"RXXLRXRXL\", end = \"XRLXXRRLX\" 输出: True 解释: 我们可以通过以下几步将start转换成end: RXXLRXRXL -> XRXLRXRXL -> XRLXRXRXL -> XRLXXRRXL -> XRLXXRRLX 注意: 1 解题方案 思路 1 这道题就是一道坑比题，为什么我这么说，题目都说了是 Adjacent，然后XL换成LX的情况居然包括\"XXXXXLXXXX\"到\"LXXXXXXXXX\"， 你说这是 Adjacent吗，XL不相邻也可以换，我去nm的，不好意思爆粗口了。 先说一下XL必须相邻的解法吧，不能白费我功夫啊。 动态规划：dp[i]代表以index i结尾的字串是否能够被替换成功，首先dp[0]必须等于False吧，所以我们初始化全部设为False，然后把dp[1]也先判断好 那么很显然，对于dp[i]有下面的情况： dp[i-1] == True 如果start[i] == end[i]，那么dp[i] = True 如果start[i] != end[i]，那么这里我们不做操作，因为初始化就是False dp[i-1] == False 如果start[i] == end[i]，那么dp[i] = False 如果start[i] != end[i]，那么只有当最后两个字符可以转换且dp[i-2] == True的情况下dp[i]才为True 最后返回dp[-1] class Solution(object): def canTransform(self, start, end): \"\"\" :type start: str :type end: str :rtype: bool \"\"\" if not start or len(start) == 0: return True if len(start) == 1: return False dp = [False for i in range(len(start))] if start[:2] == 'XL' and end[:2] == 'LX' or start[:2] == 'RX' and end[:2] == 'XR' or start[:2] == end[:2]: dp[1] = True for i in range(2, len(dp)): if dp[i-1]: if start[i] == end[i]: dp[i] = True else: if start[i] == 'L' and start[i-1] == 'X' and end[i] == 'X' and end[i-1] == 'L' and dp[i-2]: dp[i] = True if start[i] == 'X' and start[i-1] == 'R' and end[i] == 'R' and end[i-1] == 'X' and dp[i-2]: dp[i] = True return dp[-1] 接下来说一下XL可以不相邻的情况吧。 用rx 和 xl来存储出现了可以替换的可能性，即当start出现X或者R的时候,如果后面又开始出现结尾情况了， 我们就要pop一下对应的rx 和 xl中的一个 class Solution(object): def canTransform(self, start, end): \"\"\" :type start: str :type end: str :rtype: bool \"\"\" if not start or len(start) == 0 or start == end: return True if len(start) == 1: return False xl, rx = [], [] for i in range(len(start)): if start[i] == end[i]: continue elif start[i] == 'X' and end[i] == 'L': xl.append('L') elif start[i] == 'L' and end[i] == 'X': if not xl: return False xl.pop() elif start[i] == 'R' and end[i] == 'X': rx.append('R') elif start[i] == 'X' and end[i] == 'R': if not rx: return False rx.pop() else: return False return not rx and not xl 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"844._Backspace_String_Compare.html":{"url":"844._Backspace_String_Compare.html","title":"844 Backspace String Compare","keywords":"","body":"844. Backspace String Compare 题目: https://leetcode.com/problems/backspace-string-compare/ 难度: Easy 思路 就看一下两个字符串变化完之后是不是相等就行了， 时间复杂度：O(n) 空间复杂度：O(n) class Solution(object): def backspaceCompare(self, S, T): \"\"\" :type S: str :type T: str :rtype: bool \"\"\" def afterChange(s): res = '' for i in s: if i == '#': res = '' if len(res) == 0 else res[:-1] else: res += i return res return afterChange(S) == afterChange(T) 我们一直在努力 apachecn/Interview (adsbygoogle = window.adsbygoogle || []).push({}); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?84fca651656bc67b4b2d56605b6d0852\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127082511-1'); const gitalk = new Gitalk({ clientID: '03eb95143c1b933f80bd', clientSecret: '0fe7c3da3e15e943d1276e37732c848f8a94660a', repo: 'Interview', owner: 'apachecn', admin: ['jiangzhonglian', 'wizardforcel'], id: md5(location.pathname), distractionFreeMode: false }) gitalk.render('gitalk-container') Copyright © ibooker.org.cn 2019 all right reserved，由 ApacheCN 团队提供支持该文件修订时间： 2020-03-07 11:33:38 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"}}